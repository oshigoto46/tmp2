var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/lib/vendor.js
var require_vendor = __commonJS({
  "src/lib/vendor.js"(exports, module2) {
    var DEPENDENCIES = {};
    var getDependencies = () => {
      return DEPENDENCIES;
    };
    var setDependencies2 = (value) => {
      Object.assign(DEPENDENCIES, value);
    };
    Object.assign(module2.exports, { getDependencies, setDependencies: setDependencies2 });
  }
});

// src/lib/class/Registry.js
var require_Registry = __commonJS({
  "src/lib/class/Registry.js"(exports, module2) {
    var Registry = class {
      constructor() {
        this.data = {};
      }
      unregister(name) {
        if (!name) {
          this.data = {};
        } else {
          delete this.data[name];
        }
      }
      register(name, callback) {
        this.data[name] = callback;
      }
      registerMany(formats) {
        Object.keys(formats).forEach((name) => {
          this.data[name] = formats[name];
        });
      }
      get(name) {
        const format = this.data[name];
        return format;
      }
      list() {
        return this.data;
      }
    };
    var Registry_default = Registry;
    module2.exports = Registry_default;
  }
});

// src/lib/api/defaults.js
var require_defaults = __commonJS({
  "src/lib/api/defaults.js"(exports, module2) {
    var defaults = {};
    var defaults_default = defaults;
    defaults.defaultInvalidTypeProduct = void 0;
    defaults.defaultRandExpMax = 10;
    defaults.pruneProperties = [];
    defaults.ignoreProperties = [];
    defaults.ignoreMissingRefs = false;
    defaults.failOnInvalidTypes = true;
    defaults.failOnInvalidFormat = true;
    defaults.alwaysFakeOptionals = false;
    defaults.optionalsProbability = null;
    defaults.fixedProbabilities = false;
    defaults.useExamplesValue = false;
    defaults.useDefaultValue = false;
    defaults.requiredOnly = false;
    defaults.minItems = 0;
    defaults.maxItems = null;
    defaults.minLength = 0;
    defaults.maxLength = null;
    defaults.resolveJsonPath = false;
    defaults.reuseProperties = false;
    defaults.fillProperties = true;
    defaults.replaceEmptyByRandomValue = false;
    defaults.random = Math.random;
    defaults.renderTitle = true;
    defaults.renderDescription = true;
    defaults.renderComment = false;
    module2.exports = defaults_default;
  }
});

// src/lib/class/OptionRegistry.js
var require_OptionRegistry = __commonJS({
  "src/lib/class/OptionRegistry.js"(exports, module2) {
    var Registry = require_Registry();
    var defaults = require_defaults();
    var OptionRegistry = class extends Registry {
      constructor() {
        super();
        this.data = __spreadValues({}, defaults);
        this._defaults = defaults;
      }
      get defaults() {
        return __spreadValues({}, this._defaults);
      }
    };
    var OptionRegistry_default = OptionRegistry;
    module2.exports = OptionRegistry_default;
  }
});

// src/lib/api/option.js
var require_option = __commonJS({
  "src/lib/api/option.js"(exports, module2) {
    var OptionRegistry = require_OptionRegistry();
    var registry = new OptionRegistry();
    function optionAPI(nameOrOptionMap, optionalValue) {
      if (typeof nameOrOptionMap === "string") {
        if (typeof optionalValue !== "undefined") {
          return registry.register(nameOrOptionMap, optionalValue);
        }
        return registry.get(nameOrOptionMap);
      }
      return registry.registerMany(nameOrOptionMap);
    }
    optionAPI.getDefaults = () => registry.defaults;
    var option_default = optionAPI;
    module2.exports = option_default;
  }
});

// src/lib/core/constants.js
var require_constants = __commonJS({
  "src/lib/core/constants.js"(exports, module2) {
    var ALLOWED_TYPES = ["integer", "number", "string", "boolean"];
    var SCALAR_TYPES = ALLOWED_TYPES.concat(["null"]);
    var ALL_TYPES = ["array", "object"].concat(SCALAR_TYPES);
    var MOST_NEAR_DATETIME = 2524608e6;
    var MIN_INTEGER = -1e8;
    var MAX_INTEGER = 1e8;
    var MIN_NUMBER = -100;
    var MAX_NUMBER = 100;
    var constants_default = {
      ALLOWED_TYPES,
      SCALAR_TYPES,
      ALL_TYPES,
      MIN_NUMBER,
      MAX_NUMBER,
      MIN_INTEGER,
      MAX_INTEGER,
      MOST_NEAR_DATETIME
    };
    module2.exports = constants_default;
  }
});

// node_modules/ret/lib/types.js
var require_types = __commonJS({
  "node_modules/ret/lib/types.js"(exports, module2) {
    module2.exports = {
      ROOT: 0,
      GROUP: 1,
      POSITION: 2,
      SET: 3,
      RANGE: 4,
      REPETITION: 5,
      REFERENCE: 6,
      CHAR: 7
    };
  }
});

// node_modules/ret/lib/sets.js
var require_sets = __commonJS({
  "node_modules/ret/lib/sets.js"(exports) {
    var types = require_types();
    var INTS = () => [{ type: types.RANGE, from: 48, to: 57 }];
    var WORDS = () => {
      return [
        { type: types.CHAR, value: 95 },
        { type: types.RANGE, from: 97, to: 122 },
        { type: types.RANGE, from: 65, to: 90 }
      ].concat(INTS());
    };
    var WHITESPACE = () => {
      return [
        { type: types.CHAR, value: 9 },
        { type: types.CHAR, value: 10 },
        { type: types.CHAR, value: 11 },
        { type: types.CHAR, value: 12 },
        { type: types.CHAR, value: 13 },
        { type: types.CHAR, value: 32 },
        { type: types.CHAR, value: 160 },
        { type: types.CHAR, value: 5760 },
        { type: types.RANGE, from: 8192, to: 8202 },
        { type: types.CHAR, value: 8232 },
        { type: types.CHAR, value: 8233 },
        { type: types.CHAR, value: 8239 },
        { type: types.CHAR, value: 8287 },
        { type: types.CHAR, value: 12288 },
        { type: types.CHAR, value: 65279 }
      ];
    };
    var NOTANYCHAR = () => {
      return [
        { type: types.CHAR, value: 10 },
        { type: types.CHAR, value: 13 },
        { type: types.CHAR, value: 8232 },
        { type: types.CHAR, value: 8233 }
      ];
    };
    exports.words = () => ({ type: types.SET, set: WORDS(), not: false });
    exports.notWords = () => ({ type: types.SET, set: WORDS(), not: true });
    exports.ints = () => ({ type: types.SET, set: INTS(), not: false });
    exports.notInts = () => ({ type: types.SET, set: INTS(), not: true });
    exports.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });
    exports.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });
    exports.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });
  }
});

// node_modules/ret/lib/util.js
var require_util = __commonJS({
  "node_modules/ret/lib/util.js"(exports) {
    var types = require_types();
    var sets = require_sets();
    var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
    var SLSH = { "0": 0, "t": 9, "n": 10, "v": 11, "f": 12, "r": 13 };
    exports.strToChars = function(str) {
      var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
      str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
        if (lbs) {
          return s;
        }
        var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
        var c = String.fromCharCode(code);
        if (/[[\]{}^$.|?*+()]/.test(c)) {
          c = "\\" + c;
        }
        return c;
      });
      return str;
    };
    exports.tokenizeClass = (str, regexpStr) => {
      var tokens = [];
      var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g;
      var rs, c;
      while ((rs = regexp.exec(str)) != null) {
        if (rs[1]) {
          tokens.push(sets.words());
        } else if (rs[2]) {
          tokens.push(sets.ints());
        } else if (rs[3]) {
          tokens.push(sets.whitespace());
        } else if (rs[4]) {
          tokens.push(sets.notWords());
        } else if (rs[5]) {
          tokens.push(sets.notInts());
        } else if (rs[6]) {
          tokens.push(sets.notWhitespace());
        } else if (rs[7]) {
          tokens.push({
            type: types.RANGE,
            from: (rs[8] || rs[9]).charCodeAt(0),
            to: rs[10].charCodeAt(0)
          });
        } else if (c = rs[12]) {
          tokens.push({
            type: types.CHAR,
            value: c.charCodeAt(0)
          });
        } else {
          return [tokens, regexp.lastIndex];
        }
      }
      exports.error(regexpStr, "Unterminated character class");
    };
    exports.error = (regexp, msg) => {
      throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
    };
  }
});

// node_modules/ret/lib/positions.js
var require_positions = __commonJS({
  "node_modules/ret/lib/positions.js"(exports) {
    var types = require_types();
    exports.wordBoundary = () => ({ type: types.POSITION, value: "b" });
    exports.nonWordBoundary = () => ({ type: types.POSITION, value: "B" });
    exports.begin = () => ({ type: types.POSITION, value: "^" });
    exports.end = () => ({ type: types.POSITION, value: "$" });
  }
});

// node_modules/ret/lib/index.js
var require_lib = __commonJS({
  "node_modules/ret/lib/index.js"(exports, module2) {
    var util = require_util();
    var types = require_types();
    var sets = require_sets();
    var positions = require_positions();
    module2.exports = (regexpStr) => {
      var i = 0, l, c, start = { type: types.ROOT, stack: [] }, lastGroup = start, last = start.stack, groupStack = [];
      var repeatErr = (i2) => {
        util.error(regexpStr, `Nothing to repeat at column ${i2 - 1}`);
      };
      var str = util.strToChars(regexpStr);
      l = str.length;
      while (i < l) {
        c = str[i++];
        switch (c) {
          case "\\":
            c = str[i++];
            switch (c) {
              case "b":
                last.push(positions.wordBoundary());
                break;
              case "B":
                last.push(positions.nonWordBoundary());
                break;
              case "w":
                last.push(sets.words());
                break;
              case "W":
                last.push(sets.notWords());
                break;
              case "d":
                last.push(sets.ints());
                break;
              case "D":
                last.push(sets.notInts());
                break;
              case "s":
                last.push(sets.whitespace());
                break;
              case "S":
                last.push(sets.notWhitespace());
                break;
              default:
                if (/\d/.test(c)) {
                  last.push({ type: types.REFERENCE, value: parseInt(c, 10) });
                } else {
                  last.push({ type: types.CHAR, value: c.charCodeAt(0) });
                }
            }
            break;
          case "^":
            last.push(positions.begin());
            break;
          case "$":
            last.push(positions.end());
            break;
          case "[":
            var not;
            if (str[i] === "^") {
              not = true;
              i++;
            } else {
              not = false;
            }
            var classTokens = util.tokenizeClass(str.slice(i), regexpStr);
            i += classTokens[1];
            last.push({
              type: types.SET,
              set: classTokens[0],
              not
            });
            break;
          case ".":
            last.push(sets.anyChar());
            break;
          case "(":
            var group = {
              type: types.GROUP,
              stack: [],
              remember: true
            };
            c = str[i];
            if (c === "?") {
              c = str[i + 1];
              i += 2;
              if (c === "=") {
                group.followedBy = true;
              } else if (c === "!") {
                group.notFollowedBy = true;
              } else if (c !== ":") {
                util.error(regexpStr, `Invalid group, character '${c}' after '?' at column ${i - 1}`);
              }
              group.remember = false;
            }
            last.push(group);
            groupStack.push(lastGroup);
            lastGroup = group;
            last = group.stack;
            break;
          case ")":
            if (groupStack.length === 0) {
              util.error(regexpStr, `Unmatched ) at column ${i - 1}`);
            }
            lastGroup = groupStack.pop();
            last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
            break;
          case "|":
            if (!lastGroup.options) {
              lastGroup.options = [lastGroup.stack];
              delete lastGroup.stack;
            }
            var stack = [];
            lastGroup.options.push(stack);
            last = stack;
            break;
          case "{":
            var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
            if (rs !== null) {
              if (last.length === 0) {
                repeatErr(i);
              }
              min = parseInt(rs[1], 10);
              max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
              i += rs[0].length;
              last.push({
                type: types.REPETITION,
                min,
                max,
                value: last.pop()
              });
            } else {
              last.push({
                type: types.CHAR,
                value: 123
              });
            }
            break;
          case "?":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types.REPETITION,
              min: 0,
              max: 1,
              value: last.pop()
            });
            break;
          case "+":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types.REPETITION,
              min: 1,
              max: Infinity,
              value: last.pop()
            });
            break;
          case "*":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types.REPETITION,
              min: 0,
              max: Infinity,
              value: last.pop()
            });
            break;
          default:
            last.push({
              type: types.CHAR,
              value: c.charCodeAt(0)
            });
        }
      }
      if (groupStack.length !== 0) {
        util.error(regexpStr, "Unterminated group");
      }
      return start;
    };
    module2.exports.types = types;
  }
});

// node_modules/drange/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/drange/lib/index.js"(exports, module2) {
    "use strict";
    var SubRange = class {
      constructor(low, high) {
        this.low = low;
        this.high = high;
        this.length = 1 + high - low;
      }
      overlaps(range) {
        return !(this.high < range.low || this.low > range.high);
      }
      touches(range) {
        return !(this.high + 1 < range.low || this.low - 1 > range.high);
      }
      add(range) {
        return new SubRange(Math.min(this.low, range.low), Math.max(this.high, range.high));
      }
      subtract(range) {
        if (range.low <= this.low && range.high >= this.high) {
          return [];
        } else if (range.low > this.low && range.high < this.high) {
          return [
            new SubRange(this.low, range.low - 1),
            new SubRange(range.high + 1, this.high)
          ];
        } else if (range.low <= this.low) {
          return [new SubRange(range.high + 1, this.high)];
        } else {
          return [new SubRange(this.low, range.low - 1)];
        }
      }
      toString() {
        return this.low == this.high ? this.low.toString() : this.low + "-" + this.high;
      }
    };
    var DRange = class {
      constructor(a, b) {
        this.ranges = [];
        this.length = 0;
        if (a != null)
          this.add(a, b);
      }
      _update_length() {
        this.length = this.ranges.reduce((previous, range) => {
          return previous + range.length;
        }, 0);
      }
      add(a, b) {
        var _add = (subrange) => {
          var i = 0;
          while (i < this.ranges.length && !subrange.touches(this.ranges[i])) {
            i++;
          }
          var newRanges = this.ranges.slice(0, i);
          while (i < this.ranges.length && subrange.touches(this.ranges[i])) {
            subrange = subrange.add(this.ranges[i]);
            i++;
          }
          newRanges.push(subrange);
          this.ranges = newRanges.concat(this.ranges.slice(i));
          this._update_length();
        };
        if (a instanceof DRange) {
          a.ranges.forEach(_add);
        } else {
          if (b == null)
            b = a;
          _add(new SubRange(a, b));
        }
        return this;
      }
      subtract(a, b) {
        var _subtract = (subrange) => {
          var i = 0;
          while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {
            i++;
          }
          var newRanges = this.ranges.slice(0, i);
          while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {
            newRanges = newRanges.concat(this.ranges[i].subtract(subrange));
            i++;
          }
          this.ranges = newRanges.concat(this.ranges.slice(i));
          this._update_length();
        };
        if (a instanceof DRange) {
          a.ranges.forEach(_subtract);
        } else {
          if (b == null)
            b = a;
          _subtract(new SubRange(a, b));
        }
        return this;
      }
      intersect(a, b) {
        var newRanges = [];
        var _intersect = (subrange) => {
          var i = 0;
          while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {
            i++;
          }
          while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {
            var low = Math.max(this.ranges[i].low, subrange.low);
            var high = Math.min(this.ranges[i].high, subrange.high);
            newRanges.push(new SubRange(low, high));
            i++;
          }
        };
        if (a instanceof DRange) {
          a.ranges.forEach(_intersect);
        } else {
          if (b == null)
            b = a;
          _intersect(new SubRange(a, b));
        }
        this.ranges = newRanges;
        this._update_length();
        return this;
      }
      index(index) {
        var i = 0;
        while (i < this.ranges.length && this.ranges[i].length <= index) {
          index -= this.ranges[i].length;
          i++;
        }
        return this.ranges[i].low + index;
      }
      toString() {
        return "[ " + this.ranges.join(", ") + " ]";
      }
      clone() {
        return new DRange(this);
      }
      numbers() {
        return this.ranges.reduce((result, subrange) => {
          var i = subrange.low;
          while (i <= subrange.high) {
            result.push(i);
            i++;
          }
          return result;
        }, []);
      }
      subranges() {
        return this.ranges.map((subrange) => ({
          low: subrange.low,
          high: subrange.high,
          length: 1 + subrange.high - subrange.low
        }));
      }
    };
    module2.exports = DRange;
  }
});

// node_modules/randexp/lib/randexp.js
var require_randexp = __commonJS({
  "node_modules/randexp/lib/randexp.js"(exports, module2) {
    var ret = require_lib();
    var DRange = require_lib2();
    var types = ret.types;
    module2.exports = class RandExp {
      constructor(regexp, m) {
        this._setDefaults(regexp);
        if (regexp instanceof RegExp) {
          this.ignoreCase = regexp.ignoreCase;
          this.multiline = regexp.multiline;
          regexp = regexp.source;
        } else if (typeof regexp === "string") {
          this.ignoreCase = m && m.indexOf("i") !== -1;
          this.multiline = m && m.indexOf("m") !== -1;
        } else {
          throw new Error("Expected a regexp or string");
        }
        this.tokens = ret(regexp);
      }
      _setDefaults(regexp) {
        this.max = regexp.max != null ? regexp.max : RandExp.prototype.max != null ? RandExp.prototype.max : 100;
        this.defaultRange = regexp.defaultRange ? regexp.defaultRange : this.defaultRange.clone();
        if (regexp.randInt) {
          this.randInt = regexp.randInt;
        }
      }
      gen() {
        return this._gen(this.tokens, []);
      }
      _gen(token, groups) {
        var stack, str, n, i, l;
        switch (token.type) {
          case types.ROOT:
          case types.GROUP:
            if (token.followedBy || token.notFollowedBy) {
              return "";
            }
            if (token.remember && token.groupNumber === void 0) {
              token.groupNumber = groups.push(null) - 1;
            }
            stack = token.options ? this._randSelect(token.options) : token.stack;
            str = "";
            for (i = 0, l = stack.length; i < l; i++) {
              str += this._gen(stack[i], groups);
            }
            if (token.remember) {
              groups[token.groupNumber] = str;
            }
            return str;
          case types.POSITION:
            return "";
          case types.SET:
            var expandedSet = this._expand(token);
            if (!expandedSet.length) {
              return "";
            }
            return String.fromCharCode(this._randSelect(expandedSet));
          case types.REPETITION:
            n = this.randInt(token.min, token.max === Infinity ? token.min + this.max : token.max);
            str = "";
            for (i = 0; i < n; i++) {
              str += this._gen(token.value, groups);
            }
            return str;
          case types.REFERENCE:
            return groups[token.value - 1] || "";
          case types.CHAR:
            var code = this.ignoreCase && this._randBool() ? this._toOtherCase(token.value) : token.value;
            return String.fromCharCode(code);
        }
      }
      _toOtherCase(code) {
        return code + (97 <= code && code <= 122 ? -32 : 65 <= code && code <= 90 ? 32 : 0);
      }
      _randBool() {
        return !this.randInt(0, 1);
      }
      _randSelect(arr) {
        if (arr instanceof DRange) {
          return arr.index(this.randInt(0, arr.length - 1));
        }
        return arr[this.randInt(0, arr.length - 1)];
      }
      _expand(token) {
        if (token.type === ret.types.CHAR) {
          return new DRange(token.value);
        } else if (token.type === ret.types.RANGE) {
          return new DRange(token.from, token.to);
        } else {
          let drange = new DRange();
          for (let i = 0; i < token.set.length; i++) {
            let subrange = this._expand(token.set[i]);
            drange.add(subrange);
            if (this.ignoreCase) {
              for (let j = 0; j < subrange.length; j++) {
                let code = subrange.index(j);
                let otherCaseCode = this._toOtherCase(code);
                if (code !== otherCaseCode) {
                  drange.add(otherCaseCode);
                }
              }
            }
          }
          if (token.not) {
            return this.defaultRange.clone().subtract(drange);
          } else {
            return this.defaultRange.clone().intersect(drange);
          }
        }
      }
      randInt(a, b) {
        return a + Math.floor(Math.random() * (1 + b - a));
      }
      get defaultRange() {
        return this._range = this._range || new DRange(32, 126);
      }
      set defaultRange(range) {
        this._range = range;
      }
      static randexp(regexp, m) {
        var randexp;
        if (typeof regexp === "string") {
          regexp = new RegExp(regexp, m);
        }
        if (regexp._randexp === void 0) {
          randexp = new RandExp(regexp, m);
          regexp._randexp = randexp;
        } else {
          randexp = regexp._randexp;
          randexp._setDefaults(regexp);
        }
        return randexp.gen();
      }
      static sugar() {
        RegExp.prototype.gen = function() {
          return RandExp.randexp(this);
        };
      }
    };
  }
});

// src/lib/core/random.js
var require_random = __commonJS({
  "src/lib/core/random.js"(exports, module2) {
    var RandExp = require_randexp();
    var optionAPI = require_option();
    var env = require_constants();
    function getRandomInteger(min, max) {
      min = typeof min === "undefined" ? env.MIN_INTEGER : min;
      max = typeof max === "undefined" ? env.MAX_INTEGER : max;
      return Math.floor(optionAPI("random")() * (max - min + 1)) + min;
    }
    function _randexp(value) {
      RandExp.prototype.max = optionAPI("defaultRandExpMax");
      RandExp.prototype.randInt = (a, b) => a + Math.floor(optionAPI("random")() * (1 + (b - a)));
      const re = new RandExp(value);
      return re.gen();
    }
    function pick(collection) {
      return collection[Math.floor(optionAPI("random")() * collection.length)];
    }
    function shuffle(collection) {
      let tmp;
      let key;
      let length = collection.length;
      const copy = collection.slice();
      for (; length > 0; ) {
        key = Math.floor(optionAPI("random")() * length);
        length -= 1;
        tmp = copy[length];
        copy[length] = copy[key];
        copy[key] = tmp;
      }
      return copy;
    }
    function getRandom(min, max) {
      return optionAPI("random")() * (max - min) + min;
    }
    function number(min, max, defMin, defMax, hasPrecision = false) {
      defMin = typeof defMin === "undefined" ? env.MIN_NUMBER : defMin;
      defMax = typeof defMax === "undefined" ? env.MAX_NUMBER : defMax;
      min = typeof min === "undefined" ? defMin : min;
      max = typeof max === "undefined" ? defMax : max;
      if (max < min) {
        max += min;
      }
      if (hasPrecision) {
        return getRandom(min, max);
      }
      return getRandomInteger(min, max);
    }
    function by(type) {
      switch (type) {
        case "seconds":
          return number(0, 60) * 60;
        case "minutes":
          return number(15, 50) * 612;
        case "hours":
          return number(12, 72) * 36123;
        case "days":
          return number(7, 30) * 86412345;
        case "weeks":
          return number(4, 52) * 604812345;
        case "months":
          return number(2, 13) * 2592012345;
        case "years":
          return number(1, 20) * 31104012345;
        default:
          break;
      }
    }
    function date(step) {
      if (step) {
        return by(step);
      }
      const now = new Date();
      const days = number(-1e3, env.MOST_NEAR_DATETIME);
      now.setTime(now.getTime() - days);
      return now;
    }
    var random_default = {
      pick,
      date,
      shuffle,
      number,
      randexp: _randexp
    };
    module2.exports = random_default;
  }
});

// src/lib/core/utils.js
var require_utils = __commonJS({
  "src/lib/core/utils.js"(exports, module2) {
    var optionAPI = require_option();
    var env = require_constants();
    var random = require_random();
    function getLocalRef(obj, path, refs) {
      if (refs && refs[path])
        return clone(refs[path]);
      const keyElements = path.replace("#/", "/").split("/");
      let schema = obj.$ref && refs ? refs[obj.$ref] : obj;
      if (refs && path.includes("#/") && refs[keyElements[0]]) {
        schema = refs[keyElements.shift()];
      }
      if (!keyElements[0])
        keyElements.shift();
      while (schema && keyElements.length > 0) {
        const prop = keyElements.shift();
        if (!schema[prop]) {
          throw new Error(`Prop not found: ${prop} (${path})`);
        }
        schema = schema[prop];
      }
      return schema;
    }
    function hasProperties(obj, ...properties) {
      return properties.filter((key) => {
        return typeof obj[key] !== "undefined";
      }).length > 0;
    }
    function clampDate(value) {
      if (value.includes(" ")) {
        return new Date(value).toISOString().substr(0, 10);
      }
      let [year, month, day] = value.split("T")[0].split("-");
      month = Math.max(1, Math.min(12, month));
      day = Math.max(1, Math.min(31, day));
      return `${year}-${month}-${day}`;
    }
    function typecast(type, schema, callback) {
      const params = {};
      switch (type || schema.type) {
        case "integer":
        case "number":
          if (typeof schema.minimum !== "undefined") {
            params.minimum = schema.minimum;
          }
          if (typeof schema.maximum !== "undefined") {
            params.maximum = schema.maximum;
          }
          if (schema.enum) {
            let min = Math.max(params.minimum || 0, 0);
            let max = Math.min(params.maximum || Infinity, Infinity);
            if (schema.exclusiveMinimum && min === schema.minimum) {
              min += schema.multipleOf || 1;
            }
            if (schema.exclusiveMaximum && max === schema.maximum) {
              max -= schema.multipleOf || 1;
            }
            if (min || max !== Infinity) {
              schema.enum = schema.enum.filter((x) => {
                if (x >= min && x <= max) {
                  return true;
                }
                return false;
              });
            }
          }
          break;
        case "string": {
          params.minLength = optionAPI("minLength") || 0;
          params.maxLength = optionAPI("maxLength") || Number.MAX_SAFE_INTEGER;
          if (typeof schema.minLength !== "undefined") {
            params.minLength = Math.max(params.minLength, schema.minLength);
          }
          if (typeof schema.maxLength !== "undefined") {
            params.maxLength = Math.min(params.maxLength, schema.maxLength);
          }
          break;
        }
        default:
          break;
      }
      let value = callback(params);
      if (value === null || value === void 0) {
        return null;
      }
      switch (type || schema.type) {
        case "number":
          value = parseFloat(value);
          break;
        case "integer":
          value = parseInt(value, 10);
          break;
        case "boolean":
          value = !!value;
          break;
        case "string": {
          value = String(value);
          const min = Math.max(params.minLength || 0, 0);
          const max = Math.min(params.maxLength || Infinity, Infinity);
          let prev;
          let noChangeCount = 0;
          while (value.length < min) {
            prev = value;
            if (!schema.pattern) {
              value += `${random.pick([" ", "/", "_", "-", "+", "=", "@", "^"])}${value}`;
            } else {
              value += random.randexp(schema.pattern);
            }
            if (value === prev) {
              noChangeCount += 1;
              if (noChangeCount === 3) {
                break;
              }
            } else {
              noChangeCount = 0;
            }
          }
          if (value.length > max) {
            value = value.substr(0, max);
          }
          switch (schema.format) {
            case "date-time":
            case "datetime":
              value = new Date(clampDate(value)).toISOString().replace(/([0-9])0+Z$/, "$1Z");
              break;
            case "full-date":
            case "date":
              value = new Date(clampDate(value)).toISOString().substr(0, 10);
              break;
            case "time":
              value = new Date(`1969-01-01 ${value}`).toISOString().substr(11);
              break;
            default:
              break;
          }
          break;
        }
        default:
          break;
      }
      return value;
    }
    function merge(a, b) {
      Object.keys(b).forEach((key) => {
        if (typeof b[key] !== "object" || b[key] === null) {
          a[key] = b[key];
        } else if (Array.isArray(b[key])) {
          a[key] = a[key] || [];
          b[key].forEach((value) => {
            if (Array.isArray(a[key]) && a[key].indexOf(value) === -1) {
              a[key].push(value);
            }
          });
        } else if (typeof a[key] !== "object" || a[key] === null || Array.isArray(a[key])) {
          a[key] = merge({}, b[key]);
        } else {
          a[key] = merge(a[key], b[key]);
        }
      });
      return a;
    }
    function clone(obj, cache = new Map()) {
      if (!obj || typeof obj !== "object") {
        return obj;
      }
      if (cache.has(obj)) {
        return cache.get(obj);
      }
      if (Array.isArray(obj)) {
        const arr = [];
        cache.set(obj, arr);
        arr.push(...obj.map((x) => clone(x, cache)));
        return arr;
      }
      const clonedObj = {};
      cache.set(obj, clonedObj);
      return Object.keys(obj).reduce((prev, cur) => {
        prev[cur] = clone(obj[cur], cache);
        return prev;
      }, clonedObj);
    }
    function short(schema) {
      const s = JSON.stringify(schema);
      const l = JSON.stringify(schema, null, 2);
      return s.length > 400 ? `${l.substr(0, 400)}...` : l;
    }
    function anyValue() {
      return random.pick([
        false,
        true,
        null,
        -1,
        NaN,
        Math.PI,
        Infinity,
        void 0,
        [],
        {},
        Math.random(),
        Math.random().toString(36).substr(2)
      ]);
    }
    function notValue(schema, parent) {
      const copy = merge({}, parent);
      if (typeof schema.minimum !== "undefined") {
        copy.maximum = schema.minimum;
        copy.exclusiveMaximum = true;
      }
      if (typeof schema.maximum !== "undefined") {
        copy.minimum = schema.maximum > copy.maximum ? 0 : schema.maximum;
        copy.exclusiveMinimum = true;
      }
      if (typeof schema.minLength !== "undefined") {
        copy.maxLength = schema.minLength;
      }
      if (typeof schema.maxLength !== "undefined") {
        copy.minLength = schema.maxLength > copy.maxLength ? 0 : schema.maxLength;
      }
      if (schema.type) {
        copy.type = random.pick(env.SCALAR_TYPES.filter((x) => {
          const types = Array.isArray(schema.type) ? schema.type : [schema.type];
          return types.every((type) => {
            if (x === "number" || x === "integer") {
              return type !== "number" && type !== "integer";
            }
            return x !== type;
          });
        }));
      } else if (schema.enum) {
        let value;
        do {
          value = anyValue();
        } while (schema.enum.indexOf(value) !== -1);
        copy.enum = [value];
      }
      if (schema.required && copy.properties) {
        schema.required.forEach((prop) => {
          delete copy.properties[prop];
        });
      }
      return copy;
    }
    function validateValueForSchema(value, schema) {
      const schemaHasMin = schema.minimum !== void 0;
      const schemaHasMax = schema.maximum !== void 0;
      return (schemaHasMin || schemaHasMax) && (!schemaHasMin || value >= schema.minimum) && (!schemaHasMax || value <= schema.maximum);
    }
    function validate(value, schemas) {
      return !schemas.every((schema) => validateValueForSchema(value, schema));
    }
    function validateValueForOneOf(value, oneOf) {
      const validCount = oneOf.reduce((count, schema) => count + (validateValueForSchema(value, schema) ? 1 : 0), 0);
      return validCount === 1;
    }
    function isKey(prop) {
      return ["enum", "const", "default", "examples", "required", "definitions", "items", "properties"].includes(prop);
    }
    function omitProps(obj, props) {
      return Object.keys(obj).filter((key) => !props.includes(key)).reduce((copy, k) => {
        if (Array.isArray(obj[k])) {
          copy[k] = obj[k].slice();
        } else {
          copy[k] = obj[k] instanceof Object ? merge({}, obj[k]) : obj[k];
        }
        return copy;
      }, {});
    }
    function template(value, schema) {
      if (Array.isArray(value)) {
        return value.map((x) => template(x, schema));
      }
      if (typeof value === "string") {
        value = value.replace(/#\{([\w.-]+)\}/g, (_, $1) => schema[$1]);
      }
      return value;
    }
    function isEmpty(value) {
      return Object.prototype.toString.call(value) === "[object Object]" && !Object.keys(value).length;
    }
    function shouldClean(key, schema) {
      const isRequired = Array.isArray(schema.required) && schema.required.includes(key);
      const wasCleaned = typeof schema.thunk === "function" || schema.additionalProperties && typeof schema.additionalProperties.thunk === "function";
      return !isRequired && !wasCleaned;
    }
    function clean(obj, schema, isArray = false) {
      if (!obj || typeof obj !== "object") {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map((value) => clean(value, schema, true)).filter((value) => typeof value !== "undefined");
      }
      Object.keys(obj).forEach((k) => {
        if (isEmpty(obj[k])) {
          if (shouldClean(k, schema)) {
            delete obj[k];
          }
        } else {
          const value = clean(obj[k], schema);
          if (!isEmpty(value)) {
            obj[k] = value;
          }
        }
        if (typeof obj[k] === "undefined") {
          delete obj[k];
        }
      });
      if (!Object.keys(obj).length && isArray) {
        return void 0;
      }
      return obj;
    }
    var utils_default = {
      hasProperties,
      getLocalRef,
      omitProps,
      typecast,
      merge,
      clone,
      short,
      notValue,
      anyValue,
      validate,
      validateValueForSchema,
      validateValueForOneOf,
      isKey,
      template,
      shouldClean,
      clean,
      isEmpty,
      clampDate
    };
    module2.exports = utils_default;
  }
});

// src/lib/class/Container.js
var require_Container = __commonJS({
  "src/lib/class/Container.js"(exports, module2) {
    var import_utils = __toModule(require_utils());
    function proxy(gen) {
      return (value, schema, property, rootSchema) => {
        let fn = value;
        let args = [];
        if (typeof value === "object") {
          fn = Object.keys(value)[0];
          if (Array.isArray(value[fn])) {
            args = value[fn];
          } else {
            args.push(value[fn]);
          }
        }
        const props = fn.split(".");
        let ctx = gen();
        while (props.length > 1) {
          ctx = ctx[props.shift()];
        }
        value = typeof ctx === "object" ? ctx[props[0]] : ctx;
        if (typeof value === "function") {
          value = value.apply(ctx, args.map((x) => import_utils.default.template(x, rootSchema)));
        }
        if (Object.prototype.toString.call(value) === "[object Object]") {
          Object.keys(value).forEach((key) => {
            if (typeof value[key] === "function") {
              throw new Error(`Cannot resolve value for '${property}: ${fn}', given: ${value}`);
            }
          });
        }
        return value;
      };
    }
    var Container = class {
      constructor() {
        this.registry = {};
        this.support = {};
      }
      reset(name) {
        if (!name) {
          this.registry = {};
          this.support = {};
        } else {
          delete this.registry[name];
          delete this.support[name];
        }
      }
      extend(name, callback) {
        this.registry[name] = callback(this.registry[name]);
        if (!this.support[name]) {
          this.support[name] = proxy(() => this.registry[name]);
        }
      }
      define(name, callback) {
        this.support[name] = callback;
      }
      get(name) {
        if (typeof this.registry[name] === "undefined") {
          throw new ReferenceError(`'${name}' dependency doesn't exist.`);
        }
        return this.registry[name];
      }
      wrap(schema) {
        if (!("generate" in schema)) {
          const keys = Object.keys(schema);
          const context = {};
          let length = keys.length;
          while (length--) {
            const fn = keys[length].replace(/^x-/, "");
            const gen = this.support[fn];
            if (typeof gen === "function") {
              Object.defineProperty(schema, "generate", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: (rootSchema, key) => gen.call(context, schema[keys[length]], schema, keys[length], rootSchema, key.slice())
              });
              break;
            }
          }
        }
        return schema;
      }
    };
    var Container_default = Container;
    module2.exports = Container_default;
  }
});

// src/lib/api/format.js
var require_format = __commonJS({
  "src/lib/api/format.js"(exports, module2) {
    var Registry = require_Registry();
    var registry = new Registry();
    function formatAPI(nameOrFormatMap, callback) {
      if (typeof nameOrFormatMap === "undefined") {
        return registry.list();
      }
      if (typeof nameOrFormatMap === "string") {
        if (typeof callback === "function") {
          registry.register(nameOrFormatMap, callback);
        } else if (callback === null || callback === false) {
          registry.unregister(nameOrFormatMap);
        } else {
          return registry.get(nameOrFormatMap);
        }
      } else {
        registry.registerMany(nameOrFormatMap);
      }
    }
    var format_default = formatAPI;
    module2.exports = format_default;
  }
});

// src/lib/core/error.js
var require_error = __commonJS({
  "src/lib/core/error.js"(exports, module2) {
    var ParseError = class extends Error {
      constructor(message, path) {
        super();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "ParseError";
        this.message = message;
        this.path = path;
      }
    };
    var error_default = ParseError;
    module2.exports = error_default;
  }
});

// src/lib/core/infer.js
var require_infer = __commonJS({
  "src/lib/core/infer.js"(exports, module2) {
    var inferredProperties = {
      array: [
        "additionalItems",
        "items",
        "maxItems",
        "minItems",
        "uniqueItems"
      ],
      integer: [
        "exclusiveMaximum",
        "exclusiveMinimum",
        "maximum",
        "minimum",
        "multipleOf"
      ],
      object: [
        "additionalProperties",
        "dependencies",
        "maxProperties",
        "minProperties",
        "patternProperties",
        "properties",
        "required"
      ],
      string: [
        "maxLength",
        "minLength",
        "pattern",
        "format"
      ]
    };
    inferredProperties.number = inferredProperties.integer;
    var subschemaProperties = [
      "additionalItems",
      "items",
      "additionalProperties",
      "dependencies",
      "patternProperties",
      "properties"
    ];
    function matchesType(obj, lastElementInPath, inferredTypeProperties) {
      return Object.keys(obj).filter((prop) => {
        const isSubschema = subschemaProperties.indexOf(lastElementInPath) > -1;
        const inferredPropertyFound = inferredTypeProperties.indexOf(prop) > -1;
        if (inferredPropertyFound && !isSubschema) {
          return true;
        }
        return false;
      }).length > 0;
    }
    function inferType(obj, schemaPath) {
      const keys = Object.keys(inferredProperties);
      for (let i = 0; i < keys.length; i += 1) {
        const typeName = keys[i];
        const lastElementInPath = schemaPath[schemaPath.length - 1];
        if (matchesType(obj, lastElementInPath, inferredProperties[typeName])) {
          return typeName;
        }
      }
    }
    var infer_default = inferType;
    module2.exports = infer_default;
  }
});

// src/lib/generators/boolean.js
var require_boolean = __commonJS({
  "src/lib/generators/boolean.js"(exports, module2) {
    var optionAPI = require_option();
    function booleanGenerator() {
      return optionAPI("random")() > 0.5;
    }
    var boolean_default = booleanGenerator;
    module2.exports = boolean_default;
  }
});

// src/lib/types/boolean.js
var require_boolean2 = __commonJS({
  "src/lib/types/boolean.js"(exports, module2) {
    var booleanGenerator = require_boolean();
    var booleanType = booleanGenerator;
    var boolean_default = booleanType;
    module2.exports = boolean_default;
  }
});

// src/lib/generators/null.js
var require_null = __commonJS({
  "src/lib/generators/null.js"(exports, module2) {
    function nullGenerator() {
      return null;
    }
    var null_default = nullGenerator;
    module2.exports = null_default;
  }
});

// src/lib/types/null.js
var require_null2 = __commonJS({
  "src/lib/types/null.js"(exports, module2) {
    var nullGenerator = require_null();
    var nullType = nullGenerator;
    var null_default = nullType;
    module2.exports = null_default;
  }
});

// src/lib/types/array.js
var require_array = __commonJS({
  "src/lib/types/array.js"(exports, module2) {
    var random = require_random();
    var utils = require_utils();
    var ParseError = require_error();
    var optionAPI = require_option();
    function unique(path, items, value, sample, resolve, traverseCallback) {
      const tmp = [];
      const seen = [];
      function walk(obj) {
        const json = JSON.stringify(obj.value);
        if (seen.indexOf(json) === -1) {
          seen.push(json);
          tmp.push(obj);
          return true;
        }
        return false;
      }
      items.forEach(walk);
      let limit = 100;
      while (tmp.length !== items.length) {
        if (!walk(traverseCallback(value.items || sample, path, resolve))) {
          limit -= 1;
        }
        if (!limit) {
          break;
        }
      }
      return tmp;
    }
    function arrayType(value, path, resolve, traverseCallback) {
      const items = [];
      if (!(value.items || value.additionalItems)) {
        if (utils.hasProperties(value, "minItems", "maxItems", "uniqueItems")) {
          throw new ParseError(`missing items for ${utils.short(value)}`, path);
        }
        return items;
      }
      if (Array.isArray(value.items)) {
        return value.items.map((item, key) => {
          const itemSubpath = path.concat(["items", key]);
          return traverseCallback(item, itemSubpath, resolve);
        });
      }
      let minItems = value.minItems;
      let maxItems = value.maxItems;
      const defaultMinItems = optionAPI("minItems");
      const defaultMaxItems = optionAPI("maxItems");
      if (defaultMinItems) {
        minItems = typeof minItems === "undefined" ? defaultMinItems : Math.min(defaultMinItems, minItems);
      }
      if (defaultMaxItems) {
        maxItems = typeof maxItems === "undefined" ? defaultMaxItems : Math.min(defaultMaxItems, maxItems);
        if (maxItems && maxItems > defaultMaxItems) {
          maxItems = defaultMaxItems;
        }
        if (minItems && minItems > defaultMaxItems) {
          minItems = maxItems;
        }
      }
      const optionalsProbability = optionAPI("alwaysFakeOptionals") === true ? 1 : optionAPI("optionalsProbability");
      const fixedProbabilities = optionAPI("alwaysFakeOptionals") || optionAPI("fixedProbabilities") || false;
      let length = random.number(minItems, maxItems, 1, 5);
      if (optionalsProbability !== null) {
        length = Math.max(fixedProbabilities ? Math.round((maxItems || length) * optionalsProbability) : Math.abs(random.number(minItems, maxItems) * optionalsProbability), minItems || 0);
      }
      const sample = typeof value.additionalItems === "object" ? value.additionalItems : {};
      for (let current = items.length; current < length; current += 1) {
        const itemSubpath = path.concat(["items", current]);
        const element = traverseCallback(value.items || sample, itemSubpath, resolve);
        items.push(element);
      }
      if (value.contains && length > 0) {
        const idx = random.number(0, length - 1);
        items[idx] = traverseCallback(value.contains, path.concat(["items", idx]), resolve);
      }
      if (value.uniqueItems) {
        return unique(path.concat(["items"]), items, value, sample, resolve, traverseCallback);
      }
      return items;
    }
    var array_default = arrayType;
    module2.exports = array_default;
  }
});

// src/lib/types/number.js
var require_number = __commonJS({
  "src/lib/types/number.js"(exports, module2) {
    var random = require_random();
    var env = require_constants();
    function numberType(value) {
      let min = typeof value.minimum === "undefined" ? env.MIN_INTEGER : value.minimum;
      let max = typeof value.maximum === "undefined" ? env.MAX_INTEGER : value.maximum;
      const multipleOf = value.multipleOf;
      if (multipleOf) {
        max = Math.floor(max / multipleOf) * multipleOf;
        min = Math.ceil(min / multipleOf) * multipleOf;
      }
      if (value.exclusiveMinimum && min === value.minimum) {
        min += multipleOf || 1;
      }
      if (value.exclusiveMaximum && max === value.maximum) {
        max -= multipleOf || 1;
      }
      if (min > max) {
        return NaN;
      }
      if (multipleOf) {
        if (String(multipleOf).indexOf(".") === -1) {
          let base = random.number(Math.floor(min / multipleOf), Math.floor(max / multipleOf)) * multipleOf;
          while (base < min) {
            base += value.multipleOf;
          }
          return base;
        }
        const boundary = (max - min) / multipleOf;
        let num;
        let fix;
        do {
          num = random.number(0, boundary) * multipleOf;
          fix = num / multipleOf % 1;
        } while (fix !== 0);
        return min + num;
      }
      return random.number(min, max, void 0, void 0, true);
    }
    var number_default = numberType;
    module2.exports = number_default;
  }
});

// src/lib/types/integer.js
var require_integer = __commonJS({
  "src/lib/types/integer.js"(exports, module2) {
    var number = require_number();
    function integerType(value) {
      return number(__spreadValues({ multipleOf: 1 }, value));
    }
    var integer_default = integerType;
    module2.exports = integer_default;
  }
});

// src/lib/generators/words.js
var require_words = __commonJS({
  "src/lib/generators/words.js"(exports, module2) {
    var random = require_random();
    var LIPSUM_WORDS = `Lorem ipsum dolor sit amet consectetur adipisicing elit sed do eiusmod tempor incididunt ut labore
et dolore magna aliqua Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
commodo consequat Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
pariatur Excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est
laborum`.split(/\W/);
    function wordsGenerator(length) {
      const words = random.shuffle(LIPSUM_WORDS);
      return words.slice(0, length);
    }
    var words_default = wordsGenerator;
    module2.exports = words_default;
  }
});

// src/lib/types/object.js
var require_object = __commonJS({
  "src/lib/types/object.js"(exports, module2) {
    var constants = require_constants();
    var random = require_random();
    var words = require_words();
    var utils = require_utils();
    var optionAPI = require_option();
    var anyType = { type: constants.ALLOWED_TYPES };
    function objectType(value, path, resolve, traverseCallback) {
      const props = {};
      const properties = value.properties || {};
      const patternProperties = value.patternProperties || {};
      const requiredProperties = typeof value.required === "boolean" ? [] : (value.required || []).slice();
      const allowsAdditional = value.additionalProperties !== false;
      const propertyKeys = Object.keys(properties);
      const patternPropertyKeys = Object.keys(patternProperties);
      const optionalProperties = propertyKeys.concat(patternPropertyKeys).reduce((_response, _key) => {
        if (requiredProperties.indexOf(_key) === -1)
          _response.push(_key);
        return _response;
      }, []);
      const allProperties = requiredProperties.concat(optionalProperties);
      const additionalProperties = allowsAdditional ? value.additionalProperties === true ? anyType : value.additionalProperties : value.additionalProperties;
      if (!allowsAdditional && propertyKeys.length === 0 && patternPropertyKeys.length === 0 && utils.hasProperties(value, "minProperties", "maxProperties", "dependencies", "required")) {
        return null;
      }
      if (optionAPI("requiredOnly") === true) {
        requiredProperties.forEach((key) => {
          if (properties[key]) {
            props[key] = properties[key];
          }
        });
        return traverseCallback(props, path.concat(["properties"]), resolve, value);
      }
      const optionalsProbability = optionAPI("alwaysFakeOptionals") === true ? 1 : optionAPI("optionalsProbability");
      const fixedProbabilities = optionAPI("alwaysFakeOptionals") || optionAPI("fixedProbabilities") || false;
      const ignoreProperties = optionAPI("ignoreProperties") || [];
      const reuseProps = optionAPI("reuseProperties");
      const fillProps = optionAPI("fillProperties");
      const max = value.maxProperties || allProperties.length + (allowsAdditional ? random.number(1, 5) : 0);
      let min = Math.max(value.minProperties || 0, requiredProperties.length);
      let neededExtras = Math.max(0, allProperties.length - min);
      if (allProperties.length === 1 && !requiredProperties.length) {
        min = Math.max(random.number(fillProps ? 1 : 0, max), min);
      }
      if (optionalsProbability !== null) {
        if (fixedProbabilities === true) {
          neededExtras = Math.round(min - requiredProperties.length + optionalsProbability * (allProperties.length - min));
        } else {
          neededExtras = random.number(min - requiredProperties.length, optionalsProbability * (allProperties.length - min));
        }
      }
      const extraPropertiesRandomOrder = random.shuffle(optionalProperties).slice(0, neededExtras);
      const extraProperties = optionalProperties.filter((_item) => {
        return extraPropertiesRandomOrder.indexOf(_item) !== -1;
      });
      const _limit = optionalsProbability !== null || requiredProperties.length === max ? max : random.number(0, max);
      const _props = requiredProperties.concat(random.shuffle(extraProperties).slice(0, _limit)).slice(0, max);
      const _defns = [];
      if (value.dependencies) {
        Object.keys(value.dependencies).forEach((prop) => {
          const _required = value.dependencies[prop];
          if (_props.indexOf(prop) !== -1) {
            if (Array.isArray(_required)) {
              _required.forEach((sub) => {
                if (_props.indexOf(sub) === -1) {
                  _props.push(sub);
                }
              });
            } else {
              _defns.push(_required);
            }
          }
        });
        if (_defns.length) {
          delete value.dependencies;
          return traverseCallback({
            allOf: _defns.concat(value)
          }, path.concat(["properties"]), resolve, value);
        }
      }
      const skipped = [];
      const missing = [];
      _props.forEach((key) => {
        for (let i = 0; i < ignoreProperties.length; i += 1) {
          if (ignoreProperties[i] instanceof RegExp && ignoreProperties[i].test(key) || typeof ignoreProperties[i] === "string" && ignoreProperties[i] === key || typeof ignoreProperties[i] === "function" && ignoreProperties[i](properties[key], key)) {
            skipped.push(key);
            return;
          }
        }
        if (additionalProperties === false) {
          if (requiredProperties.indexOf(key) !== -1) {
            props[key] = properties[key];
          }
        }
        if (properties[key]) {
          props[key] = properties[key];
        }
        let found;
        patternPropertyKeys.forEach((_key) => {
          if (key.match(new RegExp(_key))) {
            found = true;
            if (props[key]) {
              utils.merge(props[key], patternProperties[_key]);
            } else {
              props[random.randexp(key)] = patternProperties[_key];
            }
          }
        });
        if (!found) {
          const subschema = patternProperties[key] || additionalProperties;
          if (subschema && additionalProperties !== false) {
            props[patternProperties[key] ? random.randexp(key) : key] = properties[key] || subschema;
          } else {
            missing.push(key);
          }
        }
      });
      let current = Object.keys(props).length + (fillProps ? 0 : skipped.length);
      const hash = (suffix) => random.randexp(`_?[_a-f\\d]{1,3}${suffix ? "\\$?" : ""}`);
      function get(from) {
        let one;
        do {
          if (!from.length)
            break;
          one = from.shift();
        } while (props[one]);
        return one;
      }
      let minProps = min;
      if (allowsAdditional && !requiredProperties.length) {
        minProps = Math.max(optionalsProbability === null || additionalProperties ? random.number(fillProps ? 1 : 0, max) : 0, min);
      }
      while (fillProps) {
        if (!(patternPropertyKeys.length || allowsAdditional)) {
          break;
        }
        if (current >= minProps) {
          break;
        }
        if (allowsAdditional) {
          if (reuseProps && propertyKeys.length - current > minProps) {
            let count = 0;
            let key;
            do {
              count += 1;
              if (count > 1e3) {
                break;
              }
              key = get(requiredProperties) || random.pick(propertyKeys);
            } while (typeof props[key] !== "undefined");
            if (typeof props[key] === "undefined") {
              props[key] = properties[key];
              current += 1;
            }
          } else if (patternPropertyKeys.length && !additionalProperties) {
            const prop = random.pick(patternPropertyKeys);
            const word = random.randexp(prop);
            if (!props[word]) {
              props[word] = patternProperties[prop];
              current += 1;
            }
          } else {
            const word = get(requiredProperties) || words(1) + hash();
            if (!props[word]) {
              props[word] = additionalProperties || anyType;
              current += 1;
            }
          }
        }
        for (let i = 0; current < min && i < patternPropertyKeys.length; i += 1) {
          const _key = patternPropertyKeys[i];
          const word = random.randexp(_key);
          if (!props[word]) {
            props[word] = patternProperties[_key];
            current += 1;
          }
        }
      }
      if (requiredProperties.length === 0 && (!allowsAdditional || optionalsProbability === false)) {
        const maximum = random.number(min, max);
        for (; current < maximum; ) {
          const word = get(propertyKeys);
          if (word) {
            props[word] = properties[word];
          }
          current += 1;
        }
      }
      return traverseCallback(props, path.concat(["properties"]), resolve, value);
    }
    var object_default = objectType;
    module2.exports = object_default;
  }
});

// src/lib/generators/thunk.js
var require_thunk = __commonJS({
  "src/lib/generators/thunk.js"(exports, module2) {
    var words = require_words();
    var random = require_random();
    function produce() {
      const length = random.number(1, 5);
      return words(length).join(" ");
    }
    function thunkGenerator(min = 0, max = 140) {
      const _min = Math.max(0, min);
      const _max = random.number(_min, max);
      let result = produce();
      while (result.length < _min) {
        result += produce();
      }
      if (result.length > _max) {
        result = result.substr(0, _max);
      }
      return result;
    }
    var thunk_default = thunkGenerator;
    module2.exports = thunk_default;
  }
});

// src/lib/generators/ipv4.js
var require_ipv4 = __commonJS({
  "src/lib/generators/ipv4.js"(exports, module2) {
    var random = require_random();
    function ipv4Generator() {
      return [0, 0, 0, 0].map(() => {
        return random.number(0, 255);
      }).join(".");
    }
    var ipv4_default = ipv4Generator;
    module2.exports = ipv4_default;
  }
});

// src/lib/generators/dateTime.js
var require_dateTime = __commonJS({
  "src/lib/generators/dateTime.js"(exports, module2) {
    var random = require_random();
    function dateTimeGenerator() {
      return random.date().toISOString();
    }
    var dateTime_default = dateTimeGenerator;
    module2.exports = dateTime_default;
  }
});

// src/lib/generators/date.js
var require_date = __commonJS({
  "src/lib/generators/date.js"(exports, module2) {
    var dateTimeGenerator = require_dateTime();
    function dateGenerator() {
      return dateTimeGenerator().slice(0, 10);
    }
    var date_default = dateGenerator;
    module2.exports = date_default;
  }
});

// src/lib/generators/time.js
var require_time = __commonJS({
  "src/lib/generators/time.js"(exports, module2) {
    var dateTimeGenerator = require_dateTime();
    function timeGenerator() {
      return dateTimeGenerator().slice(11);
    }
    var time_default = timeGenerator;
    module2.exports = time_default;
  }
});

// src/lib/generators/coreFormat.js
var require_coreFormat = __commonJS({
  "src/lib/generators/coreFormat.js"(exports, module2) {
    var random = require_random();
    var FRAGMENT = "[a-zA-Z][a-zA-Z0-9+-.]*";
    var URI_PATTERN = `https?://{hostname}(?:${FRAGMENT})+`;
    var PARAM_PATTERN = "(?:\\?([a-z]{1,7}(=\\w{1,5})?&){0,3})?";
    var regexps = {
      email: "[a-zA-Z\\d][a-zA-Z\\d-]{1,13}[a-zA-Z\\d]@{hostname}",
      hostname: "[a-zA-Z]{1,33}\\.[a-z]{2,4}",
      ipv6: "[a-f\\d]{4}(:[a-f\\d]{4}){7}",
      uri: URI_PATTERN,
      slug: "[a-zA-Z\\d_-]+",
      "uri-reference": `${URI_PATTERN}${PARAM_PATTERN}`,
      "uri-template": URI_PATTERN.replace("(?:", "(?:/\\{[a-z][:a-zA-Z0-9-]*\\}|"),
      "json-pointer": `(/(?:${FRAGMENT.replace("]*", "/]*")}|~[01]))+`,
      uuid: "^[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$"
    };
    regexps.iri = regexps["uri-reference"];
    regexps["iri-reference"] = regexps["uri-reference"];
    regexps["idn-email"] = regexps.email;
    regexps["idn-hostname"] = regexps.hostname;
    var ALLOWED_FORMATS = new RegExp(`\\{(${Object.keys(regexps).join("|")})\\}`);
    function coreFormatGenerator(coreFormat) {
      return random.randexp(regexps[coreFormat]).replace(ALLOWED_FORMATS, (match, key) => {
        return random.randexp(regexps[key]);
      });
    }
    var coreFormat_default = coreFormatGenerator;
    module2.exports = coreFormat_default;
  }
});

// src/lib/types/string.js
var require_string = __commonJS({
  "src/lib/types/string.js"(exports, module2) {
    var thunk = require_thunk();
    var ipv4 = require_ipv4();
    var dateTime = require_dateTime();
    var date = require_date();
    var time = require_time();
    var coreFormat = require_coreFormat();
    var optionAPI = require_option();
    var format = require_format();
    var random = require_random();
    var utils = require_utils();
    function generateFormat(value, invalid) {
      const callback = format(value.format);
      if (typeof callback === "function") {
        return callback(value);
      }
      switch (value.format) {
        case "date-time":
        case "datetime":
          return dateTime();
        case "date":
          return date();
        case "time":
          return time();
        case "ipv4":
          return ipv4();
        case "regex":
          return ".+?";
        case "email":
        case "hostname":
        case "ipv6":
        case "uri":
        case "uri-reference":
        case "iri":
        case "iri-reference":
        case "idn-email":
        case "idn-hostname":
        case "json-pointer":
        case "slug":
        case "uri-template":
        case "uuid":
          return coreFormat(value.format);
        default:
          if (typeof callback === "undefined") {
            if (optionAPI("failOnInvalidFormat")) {
              throw new Error(`unknown registry key ${utils.short(value.format)}`);
            } else {
              return invalid();
            }
          }
          throw new Error(`unsupported format '${value.format}'`);
      }
    }
    function stringType(value) {
      const output = utils.typecast("string", value, (opts) => {
        if (value.format) {
          return generateFormat(value, () => thunk(opts.minLength, opts.maxLength));
        }
        if (value.pattern) {
          return random.randexp(value.pattern);
        }
        return thunk(opts.minLength, opts.maxLength);
      });
      return output;
    }
    var string_default = stringType;
    module2.exports = string_default;
  }
});

// src/lib/types/index.js
var require_types2 = __commonJS({
  "src/lib/types/index.js"(exports, module2) {
    var _boolean = require_boolean2();
    var _null = require_null2();
    var _array = require_array();
    var _integer = require_integer();
    var _number = require_number();
    var _object = require_object();
    var _string = require_string();
    var typeMap = {
      boolean: _boolean,
      null: _null,
      array: _array,
      integer: _integer,
      number: _number,
      object: _object,
      string: _string
    };
    var types_default = typeMap;
    module2.exports = types_default;
  }
});

// src/lib/core/traverse.js
var require_traverse = __commonJS({
  "src/lib/core/traverse.js"(exports, module2) {
    var utils = require_utils();
    var random = require_random();
    var ParseError = require_error();
    var inferType = require_infer();
    var types = require_types2();
    var optionAPI = require_option();
    function getMeta({ $comment: comment, title, description }) {
      return Object.entries({ comment, title, description }).filter(([, value]) => value).reduce((memo, [k, v]) => {
        memo[k] = v;
        return memo;
      }, {});
    }
    function traverse(schema, path, resolve, rootSchema) {
      schema = resolve(schema, null, path);
      if (schema && (schema.oneOf || schema.anyOf || schema.allOf)) {
        schema = resolve(schema, null, path);
      }
      if (!schema) {
        return;
      }
      const context = __spreadProps(__spreadValues({}, getMeta(schema)), {
        schemaPath: path
      });
      if (path[path.length - 1] !== "properties") {
        if (optionAPI("useExamplesValue") && Array.isArray(schema.examples)) {
          const fixedExamples = schema.examples.concat("default" in schema ? [schema.default] : []);
          return { value: utils.typecast(null, schema, () => random.pick(fixedExamples)), context };
        }
        if (optionAPI("useDefaultValue") && "default" in schema) {
          if (schema.default !== "" || !optionAPI("replaceEmptyByRandomValue")) {
            return { value: schema.default, context };
          }
        }
        if ("template" in schema) {
          return { value: utils.template(schema.template, rootSchema), context };
        }
        if ("const" in schema) {
          return { value: schema.const, context };
        }
      }
      if (schema.not && typeof schema.not === "object") {
        schema = utils.notValue(schema.not, utils.omitProps(schema, ["not"]));
        if (schema.type && schema.type === "object") {
          const { value, context: innerContext } = traverse(schema, path.concat(["not"]), resolve, rootSchema);
          return { value: utils.clean(value, schema, false), context: __spreadProps(__spreadValues({}, context), { items: innerContext }) };
        }
      }
      if (typeof schema.thunk === "function") {
        const { value, context: innerContext } = traverse(schema.thunk(rootSchema), path, resolve);
        return { value, context: __spreadProps(__spreadValues({}, context), { items: innerContext }) };
      }
      if (typeof schema.generate === "function") {
        const retval = utils.typecast(null, schema, () => schema.generate(rootSchema, path));
        const type2 = retval === null ? "null" : typeof retval;
        if (type2 === schema.type || Array.isArray(schema.type) && schema.type.includes(type2) || type2 === "number" && schema.type === "integer" || Array.isArray(retval) && schema.type === "array") {
          return { value: retval, context };
        }
      }
      if (typeof schema.pattern === "string") {
        return { value: utils.typecast("string", schema, () => random.randexp(schema.pattern)), context };
      }
      if (Array.isArray(schema.enum)) {
        return { value: utils.typecast(null, schema, () => random.pick(schema.enum)), context };
      }
      if (schema.jsonPath) {
        return { value: schema, context };
      }
      let type = schema.type;
      if (Array.isArray(type)) {
        type = random.pick(type);
      } else if (typeof type === "undefined") {
        type = inferType(schema, path) || type;
        if (type) {
          schema.type = type;
        }
      }
      if (typeof type === "string") {
        if (!types[type]) {
          if (optionAPI("failOnInvalidTypes")) {
            throw new ParseError(`unknown primitive ${utils.short(type)}`, path.concat(["type"]));
          } else {
            const value = optionAPI("defaultInvalidTypeProduct");
            if (typeof value === "string" && types[value]) {
              return { value: types[value](schema, path, resolve, traverse), context };
            }
            return { value, context };
          }
        } else {
          try {
            const innerResult = types[type](schema, path, resolve, traverse);
            if (type === "array") {
              return {
                value: innerResult.map(({ value }) => value),
                context: __spreadProps(__spreadValues({}, context), {
                  items: innerResult.map(Array.isArray(schema.items) ? ({ context: c }) => c : ({ context: c }) => __spreadProps(__spreadValues({}, c), {
                    schemaPath: c.schemaPath.slice(0, -1)
                  }))
                })
              };
            }
            if (type === "object") {
              return { value: innerResult.value, context: __spreadProps(__spreadValues({}, context), { items: innerResult.context }) };
            }
            return { value: innerResult, context };
          } catch (e) {
            if (typeof e.path === "undefined") {
              throw new ParseError(e.stack, path);
            }
            throw e;
          }
        }
      }
      let valueCopy = {};
      let contextCopy = __spreadValues({}, context);
      if (Array.isArray(schema)) {
        valueCopy = [];
      }
      const pruneProperties = optionAPI("pruneProperties") || [];
      Object.keys(schema).forEach((prop) => {
        if (pruneProperties.includes(prop))
          return;
        if (typeof schema[prop] === "object" && prop !== "definitions") {
          const { value, context: innerContext } = traverse(schema[prop], path.concat([prop]), resolve, valueCopy);
          valueCopy[prop] = utils.clean(value, schema[prop], false);
          contextCopy[prop] = innerContext;
        } else {
          valueCopy[prop] = schema[prop];
        }
      });
      return { value: valueCopy, context: contextCopy };
    }
    var traverse_default = traverse;
    module2.exports = traverse_default;
  }
});

// src/lib/core/buildResolveSchema.js
var require_buildResolveSchema = __commonJS({
  "src/lib/core/buildResolveSchema.js"(exports, module2) {
    var optionAPI = require_option();
    var random = require_random();
    var utils = require_utils();
    var buildResolveSchema = ({
      refs,
      schema,
      container,
      synchronous,
      refDepthMax,
      refDepthMin
    }) => {
      const recursiveUtil = {};
      const seenRefs = {};
      let depth = 0;
      let lastRef;
      let lastPath;
      recursiveUtil.resolveSchema = (sub, index, rootPath) => {
        if (sub === null || sub === void 0) {
          return null;
        }
        if (typeof sub.generate === "function") {
          return sub;
        }
        const _id = sub.$id || sub.id;
        if (typeof _id === "string") {
          delete sub.id;
          delete sub.$id;
          delete sub.$schema;
        }
        if (typeof sub.$ref === "string") {
          const maxDepth = Math.max(refDepthMin, refDepthMax) - 1;
          if (sub.$ref === "#" || seenRefs[sub.$ref] < 0 || lastRef === sub.$ref && ++depth > maxDepth) {
            if (sub.$ref !== "#" && lastPath && lastPath.length === rootPath.length) {
              return utils.getLocalRef(schema, sub.$ref, synchronous && refs);
            }
            delete sub.$ref;
            return sub;
          }
          if (typeof seenRefs[sub.$ref] === "undefined") {
            seenRefs[sub.$ref] = random.number(refDepthMin, refDepthMax) - 1;
          }
          lastPath = rootPath;
          lastRef = sub.$ref;
          let ref;
          if (sub.$ref.indexOf("#/") === -1) {
            ref = refs[sub.$ref] || null;
          } else {
            ref = utils.getLocalRef(schema, sub.$ref, synchronous && refs) || null;
          }
          let fixed;
          if (typeof ref !== "undefined") {
            if (!ref && optionAPI("ignoreMissingRefs") !== true) {
              throw new Error(`Reference not found: ${sub.$ref}`);
            }
            seenRefs[sub.$ref] -= 1;
            utils.merge(sub, ref || {});
            fixed = synchronous && ref && ref.$ref;
          }
          if (!fixed)
            delete sub.$ref;
          return sub;
        }
        if (Array.isArray(sub.allOf)) {
          const schemas = sub.allOf;
          delete sub.allOf;
          schemas.forEach((subSchema) => {
            const _sub = recursiveUtil.resolveSchema(subSchema, null, rootPath);
            utils.merge(sub, typeof _sub.thunk === "function" ? _sub.thunk(sub) : _sub);
            if (Array.isArray(sub.allOf)) {
              recursiveUtil.resolveSchema(sub, index, rootPath);
            }
          });
        }
        if (Array.isArray(sub.oneOf || sub.anyOf)) {
          const mix = sub.oneOf || sub.anyOf;
          if (sub.enum && sub.oneOf) {
            sub.enum = sub.enum.filter((x) => utils.validate(x, mix));
          }
          return {
            thunk(rootSchema) {
              const copy = utils.omitProps(sub, ["anyOf", "oneOf"]);
              const fixed = random.pick(mix);
              utils.merge(copy, fixed);
              mix.forEach((omit) => {
                if (omit.required && omit !== fixed) {
                  omit.required.forEach((key) => {
                    const includesKey = copy.required && copy.required.includes(key);
                    if (copy.properties && !includesKey) {
                      delete copy.properties[key];
                    }
                    if (rootSchema && rootSchema.properties) {
                      delete rootSchema.properties[key];
                    }
                  });
                }
              });
              return copy;
            }
          };
        }
        Object.keys(sub).forEach((prop) => {
          if ((Array.isArray(sub[prop]) || typeof sub[prop] === "object") && !utils.isKey(prop)) {
            sub[prop] = recursiveUtil.resolveSchema(sub[prop], prop, rootPath.concat(prop));
          }
        });
        if (rootPath) {
          const lastProp = rootPath[rootPath.length - 1];
          if (lastProp === "properties" || lastProp === "items") {
            return sub;
          }
        }
        return container.wrap(sub);
      };
      return recursiveUtil;
    };
    var buildResolveSchema_default = buildResolveSchema;
    module2.exports = buildResolveSchema_default;
  }
});

// src/lib/core/run.js
var require_run = __commonJS({
  "src/lib/core/run.js"(exports, module2) {
    var { getDependencies } = require_vendor();
    var optionAPI = require_option();
    var traverse = require_traverse();
    var random = require_random();
    var utils = require_utils();
    var buildResolveSchema = require_buildResolveSchema();
    function pick(data) {
      return Array.isArray(data) ? random.pick(data) : data;
    }
    function cycle(data, reverse) {
      if (!Array.isArray(data)) {
        return data;
      }
      const value = reverse ? data.pop() : data.shift();
      if (reverse) {
        data.unshift(value);
      } else {
        data.push(value);
      }
      return value;
    }
    function resolve(obj, data, values, property) {
      if (!obj || typeof obj !== "object") {
        return obj;
      }
      if (!values) {
        values = {};
      }
      if (!data) {
        data = obj;
      }
      if (Array.isArray(obj)) {
        return obj.map((x) => resolve(x, data, values, property));
      }
      if (obj.jsonPath) {
        const { JSONPath: JSONPath2 } = getDependencies();
        const params = typeof obj.jsonPath !== "object" ? { path: obj.jsonPath } : obj.jsonPath;
        params.group = obj.group || params.group || property;
        params.cycle = obj.cycle || params.cycle || false;
        params.reverse = obj.reverse || params.reverse || false;
        params.count = obj.count || params.count || 1;
        const key = `${params.group}__${params.path}`;
        if (!values[key]) {
          if (params.count > 1) {
            values[key] = JSONPath2(params.path, data).slice(0, params.count);
          } else {
            values[key] = JSONPath2(params.path, data);
          }
        }
        if (params.cycle || params.reverse) {
          return cycle(values[key], params.reverse);
        }
        return pick(values[key]);
      }
      Object.keys(obj).forEach((k) => {
        obj[k] = resolve(obj[k], data, values, k);
      });
      return obj;
    }
    function run(refs, schema, container, synchronous) {
      if (Object.prototype.toString.call(schema) !== "[object Object]") {
        throw new Error(`Invalid input, expecting object but given ${typeof schema}`);
      }
      const refDepthMin = optionAPI("refDepthMin") || 0;
      const refDepthMax = optionAPI("refDepthMax") || 3;
      try {
        const { resolveSchema } = buildResolveSchema({
          refs,
          schema,
          container,
          synchronous,
          refDepthMin,
          refDepthMax
        });
        const result = traverse(utils.clone(schema), [], resolveSchema);
        if (optionAPI("resolveJsonPath")) {
          return {
            value: resolve(result.value),
            context: result.context
          };
        }
        return result;
      } catch (e) {
        if (e.path) {
          throw new Error(`${e.message} in /${e.path.join("/")}`);
        } else {
          throw e;
        }
      }
    }
    var run_default = run;
    module2.exports = run_default;
  }
});

// src/lib/renderers/js.js
var require_js = __commonJS({
  "src/lib/renderers/js.js"(exports, module2) {
    function renderJS(res) {
      return res.value;
    }
    var js_default = renderJS;
    module2.exports = js_default;
  }
});

// node_modules/yaml/dist/PlainValue-ec8e588e.js
var require_PlainValue_ec8e588e = __commonJS({
  "node_modules/yaml/dist/PlainValue-ec8e588e.js"(exports) {
    "use strict";
    var Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    var Type = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    var defaultTagPrefix = "tag:yaml.org,2002:";
    var defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    function findLineStarts(src) {
      const ls = [0];
      let offset = src.indexOf("\n");
      while (offset !== -1) {
        offset += 1;
        ls.push(offset);
        offset = src.indexOf("\n", offset);
      }
      return ls;
    }
    function getSrcInfo(cst) {
      let lineStarts, src;
      if (typeof cst === "string") {
        lineStarts = findLineStarts(cst);
        src = cst;
      } else {
        if (Array.isArray(cst))
          cst = cst[0];
        if (cst && cst.context) {
          if (!cst.lineStarts)
            cst.lineStarts = findLineStarts(cst.context.src);
          lineStarts = cst.lineStarts;
          src = cst.context.src;
        }
      }
      return {
        lineStarts,
        src
      };
    }
    function getLinePos(offset, cst) {
      if (typeof offset !== "number" || offset < 0)
        return null;
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !src || offset > src.length)
        return null;
      for (let i = 0; i < lineStarts.length; ++i) {
        const start = lineStarts[i];
        if (offset < start) {
          return {
            line: i,
            col: offset - lineStarts[i - 1] + 1
          };
        }
        if (offset === start)
          return {
            line: i + 1,
            col: 1
          };
      }
      const line = lineStarts.length;
      return {
        line,
        col: offset - lineStarts[line - 1] + 1
      };
    }
    function getLine(line, cst) {
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !(line >= 1) || line > lineStarts.length)
        return null;
      const start = lineStarts[line - 1];
      let end = lineStarts[line];
      while (end && end > start && src[end - 1] === "\n")
        --end;
      return src.slice(start, end);
    }
    function getPrettyContext({
      start,
      end
    }, cst, maxWidth = 80) {
      let src = getLine(start.line, cst);
      if (!src)
        return null;
      let {
        col
      } = start;
      if (src.length > maxWidth) {
        if (col <= maxWidth - 10) {
          src = src.substr(0, maxWidth - 1) + "\u2026";
        } else {
          const halfWidth = Math.round(maxWidth / 2);
          if (src.length > col + halfWidth)
            src = src.substr(0, col + halfWidth - 1) + "\u2026";
          col -= src.length - maxWidth;
          src = "\u2026" + src.substr(1 - maxWidth);
        }
      }
      let errLen = 1;
      let errEnd = "";
      if (end) {
        if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
          errLen = end.col - start.col;
        } else {
          errLen = Math.min(src.length + 1, maxWidth) - col;
          errEnd = "\u2026";
        }
      }
      const offset = col > 1 ? " ".repeat(col - 1) : "";
      const err = "^".repeat(errLen);
      return `${src}
${offset}${err}${errEnd}`;
    }
    var Range = class {
      static copy(orig) {
        return new Range(orig.start, orig.end);
      }
      constructor(start, end) {
        this.start = start;
        this.end = end || start;
      }
      isEmpty() {
        return typeof this.start !== "number" || !this.end || this.end <= this.start;
      }
      setOrigRange(cr, offset) {
        const {
          start,
          end
        } = this;
        if (cr.length === 0 || end <= cr[0]) {
          this.origStart = start;
          this.origEnd = end;
          return offset;
        }
        let i = offset;
        while (i < cr.length) {
          if (cr[i] > start)
            break;
          else
            ++i;
        }
        this.origStart = start + i;
        const nextOffset = i;
        while (i < cr.length) {
          if (cr[i] >= end)
            break;
          else
            ++i;
        }
        this.origEnd = end + i;
        return nextOffset;
      }
    };
    var Node = class {
      static addStringTerminator(src, offset, str) {
        if (str[str.length - 1] === "\n")
          return str;
        const next = Node.endOfWhiteSpace(src, offset);
        return next >= src.length || src[next] === "\n" ? str + "\n" : str;
      }
      static atDocumentBoundary(src, offset, sep) {
        const ch0 = src[offset];
        if (!ch0)
          return true;
        const prev = src[offset - 1];
        if (prev && prev !== "\n")
          return false;
        if (sep) {
          if (ch0 !== sep)
            return false;
        } else {
          if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
            return false;
        }
        const ch1 = src[offset + 1];
        const ch2 = src[offset + 2];
        if (ch1 !== ch0 || ch2 !== ch0)
          return false;
        const ch3 = src[offset + 3];
        return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
      }
      static endOfIdentifier(src, offset) {
        let ch = src[offset];
        const isVerbatim = ch === "<";
        const notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
        while (ch && notOk.indexOf(ch) === -1)
          ch = src[offset += 1];
        if (isVerbatim && ch === ">")
          offset += 1;
        return offset;
      }
      static endOfIndent(src, offset) {
        let ch = src[offset];
        while (ch === " ")
          ch = src[offset += 1];
        return offset;
      }
      static endOfLine(src, offset) {
        let ch = src[offset];
        while (ch && ch !== "\n")
          ch = src[offset += 1];
        return offset;
      }
      static endOfWhiteSpace(src, offset) {
        let ch = src[offset];
        while (ch === "	" || ch === " ")
          ch = src[offset += 1];
        return offset;
      }
      static startOfLine(src, offset) {
        let ch = src[offset - 1];
        if (ch === "\n")
          return offset;
        while (ch && ch !== "\n")
          ch = src[offset -= 1];
        return offset + 1;
      }
      static endOfBlockIndent(src, indent, lineStart) {
        const inEnd = Node.endOfIndent(src, lineStart);
        if (inEnd > lineStart + indent) {
          return inEnd;
        } else {
          const wsEnd = Node.endOfWhiteSpace(src, inEnd);
          const ch = src[wsEnd];
          if (!ch || ch === "\n")
            return wsEnd;
        }
        return null;
      }
      static atBlank(src, offset, endAsBlank) {
        const ch = src[offset];
        return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
      }
      static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
        if (!ch || indentDiff < 0)
          return false;
        if (indentDiff > 0)
          return true;
        return indicatorAsIndent && ch === "-";
      }
      static normalizeOffset(src, offset) {
        const ch = src[offset];
        return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : Node.endOfWhiteSpace(src, offset);
      }
      static foldNewline(src, offset, indent) {
        let inCount = 0;
        let error = false;
        let fold = "";
        let ch = src[offset + 1];
        while (ch === " " || ch === "	" || ch === "\n") {
          switch (ch) {
            case "\n":
              inCount = 0;
              offset += 1;
              fold += "\n";
              break;
            case "	":
              if (inCount <= indent)
                error = true;
              offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
              break;
            case " ":
              inCount += 1;
              offset += 1;
              break;
          }
          ch = src[offset + 1];
        }
        if (!fold)
          fold = " ";
        if (ch && inCount <= indent)
          error = true;
        return {
          fold,
          offset,
          error
        };
      }
      constructor(type, props, context) {
        Object.defineProperty(this, "context", {
          value: context || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type;
        this.value = null;
      }
      getPropValue(idx, key, skipKey) {
        if (!this.context)
          return null;
        const {
          src
        } = this.context;
        const prop = this.props[idx];
        return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
      }
      get anchor() {
        for (let i = 0; i < this.props.length; ++i) {
          const anchor = this.getPropValue(i, Char.ANCHOR, true);
          if (anchor != null)
            return anchor;
        }
        return null;
      }
      get comment() {
        const comments = [];
        for (let i = 0; i < this.props.length; ++i) {
          const comment = this.getPropValue(i, Char.COMMENT, true);
          if (comment != null)
            comments.push(comment);
        }
        return comments.length > 0 ? comments.join("\n") : null;
      }
      commentHasRequiredWhitespace(start) {
        const {
          src
        } = this.context;
        if (this.header && start === this.header.end)
          return false;
        if (!this.valueRange)
          return false;
        const {
          end
        } = this.valueRange;
        return start !== end || Node.atBlank(src, end - 1);
      }
      get hasComment() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] === Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get hasProps() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] !== Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get includesTrailingLines() {
        return false;
      }
      get jsonLike() {
        const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
        return jsonLikeTypes.indexOf(this.type) !== -1;
      }
      get rangeAsLinePos() {
        if (!this.range || !this.context)
          return void 0;
        const start = getLinePos(this.range.start, this.context.root);
        if (!start)
          return void 0;
        const end = getLinePos(this.range.end, this.context.root);
        return {
          start,
          end
        };
      }
      get rawValue() {
        if (!this.valueRange || !this.context)
          return null;
        const {
          start,
          end
        } = this.valueRange;
        return this.context.src.slice(start, end);
      }
      get tag() {
        for (let i = 0; i < this.props.length; ++i) {
          const tag = this.getPropValue(i, Char.TAG, false);
          if (tag != null) {
            if (tag[1] === "<") {
              return {
                verbatim: tag.slice(2, -1)
              };
            } else {
              const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
              return {
                handle,
                suffix
              };
            }
          }
        }
        return null;
      }
      get valueRangeContainsNewline() {
        if (!this.valueRange || !this.context)
          return false;
        const {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        for (let i = start; i < end; ++i) {
          if (src[i] === "\n")
            return true;
        }
        return false;
      }
      parseComment(start) {
        const {
          src
        } = this.context;
        if (src[start] === Char.COMMENT) {
          const end = Node.endOfLine(src, start + 1);
          const commentRange = new Range(start, end);
          this.props.push(commentRange);
          return end;
        }
        return start;
      }
      setOrigRanges(cr, offset) {
        if (this.range)
          offset = this.range.setOrigRange(cr, offset);
        if (this.valueRange)
          this.valueRange.setOrigRange(cr, offset);
        this.props.forEach((prop) => prop.setOrigRange(cr, offset));
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          range,
          value
        } = this;
        if (value != null)
          return value;
        const str = src.slice(range.start, range.end);
        return Node.addStringTerminator(src, range.end, str);
      }
    };
    var YAMLError = class extends Error {
      constructor(name, source, message) {
        if (!message || !(source instanceof Node))
          throw new Error(`Invalid arguments for new ${name}`);
        super();
        this.name = name;
        this.message = message;
        this.source = source;
      }
      makePretty() {
        if (!this.source)
          return;
        this.nodeType = this.source.type;
        const cst = this.source.context && this.source.context.root;
        if (typeof this.offset === "number") {
          this.range = new Range(this.offset, this.offset + 1);
          const start = cst && getLinePos(this.offset, cst);
          if (start) {
            const end = {
              line: start.line,
              col: start.col + 1
            };
            this.linePos = {
              start,
              end
            };
          }
          delete this.offset;
        } else {
          this.range = this.source.range;
          this.linePos = this.source.rangeAsLinePos;
        }
        if (this.linePos) {
          const {
            line,
            col
          } = this.linePos.start;
          this.message += ` at line ${line}, column ${col}`;
          const ctx = cst && getPrettyContext(this.linePos, cst);
          if (ctx)
            this.message += `:

${ctx}
`;
        }
        delete this.source;
      }
    };
    var YAMLReferenceError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLReferenceError", source, message);
      }
    };
    var YAMLSemanticError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSemanticError", source, message);
      }
    };
    var YAMLSyntaxError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSyntaxError", source, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(source, message) {
        super("YAMLWarning", source, message);
      }
    };
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var PlainValue = class extends Node {
      static endOfLine(src, start, inFlow) {
        let ch = src[start];
        let offset = start;
        while (ch && ch !== "\n") {
          if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ","))
            break;
          const next = src[offset + 1];
          if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ","))
            break;
          if ((ch === " " || ch === "	") && next === "#")
            break;
          offset += 1;
          ch = next;
        }
        return offset;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        let ch = src[end - 1];
        while (start < end && (ch === "\n" || ch === "	" || ch === " "))
          ch = src[--end - 1];
        let str = "";
        for (let i = start; i < end; ++i) {
          const ch2 = src[i];
          if (ch2 === "\n") {
            const {
              fold,
              offset
            } = Node.foldNewline(src, i, -1);
            str += fold;
            i = offset;
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (i < end && (next === " " || next === "	")) {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n")
              str += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
          } else {
            str += ch2;
          }
        }
        const ch0 = src[start];
        switch (ch0) {
          case "	": {
            const msg = "Plain value cannot start with a tab character";
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str
            };
          }
          case "@":
          case "`": {
            const msg = `Plain value cannot start with reserved character ${ch0}`;
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str
            };
          }
          default:
            return str;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          inFlow,
          src
        } = this.context;
        let offset = start;
        let valueEnd = start;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          if (Node.atDocumentBoundary(src, offset + 1))
            break;
          const end = Node.endOfBlockIndent(src, indent, offset + 1);
          if (end === null || src[end] === "#")
            break;
          if (src[end] === "\n") {
            offset = end;
          } else {
            valueEnd = PlainValue.endOfLine(src, end, inFlow);
            offset = valueEnd;
          }
        }
        if (this.valueRange.isEmpty())
          this.valueRange.start = start;
        this.valueRange.end = valueEnd;
        return valueEnd;
      }
      parse(context, start) {
        this.context = context;
        const {
          inFlow,
          src
        } = context;
        let offset = start;
        const ch = src[offset];
        if (ch && ch !== "#" && ch !== "\n") {
          offset = PlainValue.endOfLine(src, start, inFlow);
        }
        this.valueRange = new Range(start, offset);
        offset = Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        if (!this.hasComment || this.valueRange.isEmpty()) {
          offset = this.parseBlockValue(offset);
        }
        return offset;
      }
    };
    exports.Char = Char;
    exports.Node = Node;
    exports.PlainValue = PlainValue;
    exports.Range = Range;
    exports.Type = Type;
    exports.YAMLError = YAMLError;
    exports.YAMLReferenceError = YAMLReferenceError;
    exports.YAMLSemanticError = YAMLSemanticError;
    exports.YAMLSyntaxError = YAMLSyntaxError;
    exports.YAMLWarning = YAMLWarning;
    exports._defineProperty = _defineProperty;
    exports.defaultTagPrefix = defaultTagPrefix;
    exports.defaultTags = defaultTags;
  }
});

// node_modules/yaml/dist/resolveSeq-d03cb037.js
var require_resolveSeq_d03cb037 = __commonJS({
  "node_modules/yaml/dist/resolveSeq-d03cb037.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    function addCommentBefore(str, indent, comment) {
      if (!comment)
        return str;
      const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
      return `#${cc}
${indent}${str}`;
    }
    function addComment(str, indent, comment) {
      return !comment ? str : comment.indexOf("\n") === -1 ? `${str} #${comment}` : `${str}
` + comment.replace(/^/gm, `${indent || ""}#`);
    }
    var Node = class {
    };
    function toJSON(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJSON(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
        if (anchor)
          ctx.onCreate = (res2) => {
            anchor.res = res2;
            delete ctx.onCreate;
          };
        const res = value.toJSON(arg, ctx);
        if (anchor && ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if ((!ctx || !ctx.keep) && typeof value === "bigint")
        return Number(value);
      return value;
    }
    var Scalar = class extends Node {
      constructor(value) {
        super();
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    function collectionFromPath(schema, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          const o = {};
          Object.defineProperty(o, k, {
            value: v,
            writable: true,
            enumerable: true,
            configurable: true
          });
          v = o;
        }
      }
      return schema.createNode(v, false);
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && path[Symbol.iterator]().next().done;
    var Collection = class extends Node {
      constructor(schema) {
        super();
        PlainValue._defineProperty(this, "items", []);
        this.schema = schema;
      }
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (node instanceof Collection)
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      deleteIn([key, ...rest]) {
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (node instanceof Collection)
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      getIn([key, ...rest], keepScalar) {
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && node instanceof Scalar ? node.value : node;
        else
          return node instanceof Collection ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues() {
        return this.items.every((node) => {
          if (!node || node.type !== "PAIR")
            return false;
          const n = node.value;
          return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      hasIn([key, ...rest]) {
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return node instanceof Collection ? node.hasIn(rest) : false;
      }
      setIn([key, ...rest], value) {
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (node instanceof Collection)
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      toJSON() {
        return null;
      }
      toString(ctx, {
        blockItem,
        flowChars,
        isMap,
        itemIndent
      }, onComment, onChompKeep) {
        const {
          indent,
          indentStep,
          stringify
        } = ctx;
        const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
        if (inFlow)
          itemIndent += indentStep;
        const allNullValues = isMap && this.hasAllNullValues();
        ctx = Object.assign({}, ctx, {
          allNullValues,
          indent: itemIndent,
          inFlow,
          type: null
        });
        let chompKeep = false;
        let hasItemWithNewLine = false;
        const nodes = this.items.reduce((nodes2, item, i) => {
          let comment;
          if (item) {
            if (!chompKeep && item.spaceBefore)
              nodes2.push({
                type: "comment",
                str: ""
              });
            if (item.commentBefore)
              item.commentBefore.match(/^.*$/gm).forEach((line) => {
                nodes2.push({
                  type: "comment",
                  str: `#${line}`
                });
              });
            if (item.comment)
              comment = item.comment;
            if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
              hasItemWithNewLine = true;
          }
          chompKeep = false;
          let str2 = stringify(item, ctx, () => comment = null, () => chompKeep = true);
          if (inFlow && !hasItemWithNewLine && str2.includes("\n"))
            hasItemWithNewLine = true;
          if (inFlow && i < this.items.length - 1)
            str2 += ",";
          str2 = addComment(str2, itemIndent, comment);
          if (chompKeep && (comment || inFlow))
            chompKeep = false;
          nodes2.push({
            type: "item",
            str: str2
          });
          return nodes2;
        }, []);
        let str;
        if (nodes.length === 0) {
          str = flowChars.start + flowChars.end;
        } else if (inFlow) {
          const {
            start,
            end
          } = flowChars;
          const strings = nodes.map((n) => n.str);
          if (hasItemWithNewLine || strings.reduce((sum, str2) => sum + str2.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {
            str = start;
            for (const s of strings) {
              str += s ? `
${indentStep}${indent}${s}` : "\n";
            }
            str += `
${indent}${end}`;
          } else {
            str = `${start} ${strings.join(" ")} ${end}`;
          }
        } else {
          const strings = nodes.map(blockItem);
          str = strings.shift();
          for (const s of strings)
            str += s ? `
${indent}${s}` : "\n";
        }
        if (this.comment) {
          str += "\n" + this.comment.replace(/^/gm, `${indent}#`);
          if (onComment)
            onComment();
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
    };
    PlainValue._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);
    function asItemIndex(key) {
      let idx = key instanceof Scalar ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    var YAMLSeq = class extends Collection {
      add(value) {
        this.items.push(value);
      }
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && it instanceof Scalar ? it.value : it;
      }
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx && ctx.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJSON(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return super.toString(ctx, {
          blockItem: (n) => n.type === "comment" ? n.str : `- ${n.str}`,
          flowChars: {
            start: "[",
            end: "]"
          },
          isMap: false,
          itemIndent: (ctx.indent || "") + "  "
        }, onComment, onChompKeep);
      }
    };
    var stringifyKey = (key, jsKey, ctx) => {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (key instanceof Node && ctx && ctx.doc)
        return key.toString({
          anchors: Object.create(null),
          doc: ctx.doc,
          indent: "",
          indentStep: ctx.indentStep,
          inFlow: true,
          inStringifyKey: true,
          stringify: ctx.stringify
        });
      return JSON.stringify(jsKey);
    };
    var Pair = class extends Node {
      constructor(key, value = null) {
        super();
        this.key = key;
        this.value = value;
        this.type = Pair.Type.PAIR;
      }
      get commentBefore() {
        return this.key instanceof Node ? this.key.commentBefore : void 0;
      }
      set commentBefore(cb) {
        if (this.key == null)
          this.key = new Scalar(null);
        if (this.key instanceof Node)
          this.key.commentBefore = cb;
        else {
          const msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
          throw new Error(msg);
        }
      }
      addToJSMap(ctx, map) {
        const key = toJSON(this.key, "", ctx);
        if (map instanceof Map) {
          const value = toJSON(this.value, key, ctx);
          map.set(key, value);
        } else if (map instanceof Set) {
          map.add(key);
        } else {
          const stringKey = stringifyKey(this.key, key, ctx);
          const value = toJSON(this.value, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map[stringKey] = value;
        }
        return map;
      }
      toJSON(_, ctx) {
        const pair = ctx && ctx.mapAsMap ? new Map() : {};
        return this.addToJSMap(ctx, pair);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx || !ctx.doc)
          return JSON.stringify(this);
        const {
          indent: indentSize,
          indentSeq,
          simpleKeys
        } = ctx.doc.options;
        let {
          key,
          value
        } = this;
        let keyComment = key instanceof Node && key.comment;
        if (simpleKeys) {
          if (keyComment) {
            throw new Error("With simple keys, key nodes cannot have comments");
          }
          if (key instanceof Collection) {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
          }
        }
        let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === "object"));
        const {
          doc,
          indent,
          indentStep,
          stringify
        } = ctx;
        ctx = Object.assign({}, ctx, {
          implicitKey: !explicitKey,
          indent: indent + indentStep
        });
        let chompKeep = false;
        let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);
        str = addComment(str, ctx.indent, keyComment);
        if (!explicitKey && str.length > 1024) {
          if (simpleKeys)
            throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
          explicitKey = true;
        }
        if (ctx.allNullValues && !simpleKeys) {
          if (this.comment) {
            str = addComment(str, ctx.indent, this.comment);
            if (onComment)
              onComment();
          } else if (chompKeep && !keyComment && onChompKeep)
            onChompKeep();
          return ctx.inFlow && !explicitKey ? str : `? ${str}`;
        }
        str = explicitKey ? `? ${str}
${indent}:` : `${str}:`;
        if (this.comment) {
          str = addComment(str, ctx.indent, this.comment);
          if (onComment)
            onComment();
        }
        let vcb = "";
        let valueComment = null;
        if (value instanceof Node) {
          if (value.spaceBefore)
            vcb = "\n";
          if (value.commentBefore) {
            const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
            vcb += `
${cs}`;
          }
          valueComment = value.comment;
        } else if (value && typeof value === "object") {
          value = doc.schema.createNode(value, true);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !this.comment && value instanceof Scalar)
          ctx.indentAtStart = str.length + 1;
        chompKeep = false;
        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
          ctx.indent = ctx.indent.substr(2);
        }
        const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
        let ws = " ";
        if (vcb || this.comment) {
          ws = `${vcb}
${ctx.indent}`;
        } else if (!explicitKey && value instanceof Collection) {
          const flow = valueStr[0] === "[" || valueStr[0] === "{";
          if (!flow || valueStr.includes("\n"))
            ws = `
${ctx.indent}`;
        } else if (valueStr[0] === "\n")
          ws = "";
        if (chompKeep && !valueComment && onChompKeep)
          onChompKeep();
        return addComment(str + ws + valueStr, ctx.indent, valueComment);
      }
    };
    PlainValue._defineProperty(Pair, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    var getAliasCount = (node, anchors) => {
      if (node instanceof Alias) {
        const anchor = anchors.get(node.source);
        return anchor.count * anchor.aliasCount;
      } else if (node instanceof Collection) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(item, anchors);
          if (c > count)
            count = c;
        }
        return count;
      } else if (node instanceof Pair) {
        const kc = getAliasCount(node.key, anchors);
        const vc = getAliasCount(node.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    var Alias = class extends Node {
      static stringify({
        range,
        source
      }, {
        anchors,
        doc,
        implicitKey,
        inStringifyKey
      }) {
        let anchor = Object.keys(anchors).find((a) => anchors[a] === source);
        if (!anchor && inStringifyKey)
          anchor = doc.anchors.getName(source) || doc.anchors.newName();
        if (anchor)
          return `*${anchor}${implicitKey ? " " : ""}`;
        const msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
        throw new Error(`${msg} [${range}]`);
      }
      constructor(source) {
        super();
        this.source = source;
        this.type = PlainValue.Type.ALIAS;
      }
      set tag(t) {
        throw new Error("Alias nodes cannot have tags");
      }
      toJSON(arg, ctx) {
        if (!ctx)
          return toJSON(this.source, arg, ctx);
        const {
          anchors,
          maxAliasCount
        } = ctx;
        const anchor = anchors.get(this.source);
        if (!anchor || anchor.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          if (this.cstNode)
            throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
          else
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          anchor.count += 1;
          if (anchor.aliasCount === 0)
            anchor.aliasCount = getAliasCount(this.source, anchors);
          if (anchor.count * anchor.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            if (this.cstNode)
              throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
            else
              throw new ReferenceError(msg);
          }
        }
        return anchor.res;
      }
      toString(ctx) {
        return Alias.stringify(this, ctx);
      }
    };
    PlainValue._defineProperty(Alias, "default", true);
    function findPair(items, key) {
      const k = key instanceof Scalar ? key.value : key;
      for (const it of items) {
        if (it instanceof Pair) {
          if (it.key === key || it.key === k)
            return it;
          if (it.key && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection {
      add(pair, overwrite) {
        if (!pair)
          pair = new Pair(pair);
        else if (!(pair instanceof Pair))
          pair = new Pair(pair.key || pair, pair.value);
        const prev = findPair(this.items, pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (overwrite)
            prev.value = pair.value;
          else
            throw new Error(`Key ${pair.key} already set`);
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(pair, item) < 0);
          if (i === -1)
            this.items.push(pair);
          else
            this.items.splice(i, 0, pair);
        } else {
          this.items.push(pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it && it.value;
        return !keepScalar && node instanceof Scalar ? node.value : node;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair(key, value), true);
      }
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
        if (ctx && ctx.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          item.addToJSMap(ctx, map);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!(item instanceof Pair))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        return super.toString(ctx, {
          blockItem: (n) => n.str,
          flowChars: {
            start: "{",
            end: "}"
          },
          isMap: true,
          itemIndent: ctx.indent || ""
        }, onComment, onChompKeep);
      }
    };
    var MERGE_KEY = "<<";
    var Merge = class extends Pair {
      constructor(pair) {
        if (pair instanceof Pair) {
          let seq = pair.value;
          if (!(seq instanceof YAMLSeq)) {
            seq = new YAMLSeq();
            seq.items.push(pair.value);
            seq.range = pair.value.range;
          }
          super(pair.key, seq);
          this.range = pair.range;
        } else {
          super(new Scalar(MERGE_KEY), new YAMLSeq());
        }
        this.type = Pair.Type.MERGE_PAIR;
      }
      addToJSMap(ctx, map) {
        for (const {
          source
        } of this.value.items) {
          if (!(source instanceof YAMLMap))
            throw new Error("Merge sources must be maps");
          const srcMap = source.toJSON(null, ctx, Map);
          for (const [key, value] of srcMap) {
            if (map instanceof Map) {
              if (!map.has(key))
                map.set(key, value);
            } else if (map instanceof Set) {
              map.add(key);
            } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
              Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
        return map;
      }
      toString(ctx, onComment) {
        const seq = this.value;
        if (seq.items.length > 1)
          return super.toString(ctx, onComment);
        this.value = seq.items[0];
        const str = super.toString(ctx, onComment);
        this.value = seq;
        return str;
      }
    };
    var binaryOptions = {
      defaultType: PlainValue.Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    var boolOptions = {
      trueStr: "true",
      falseStr: "false"
    };
    var intOptions = {
      asBigInt: false
    };
    var nullOptions = {
      nullStr: "null"
    };
    var strOptions = {
      defaultType: PlainValue.Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    function resolveScalar(str, tags, scalarFallback) {
      for (const {
        format,
        test,
        resolve
      } of tags) {
        if (test) {
          const match = str.match(test);
          if (match) {
            let res = resolve.apply(null, match);
            if (!(res instanceof Scalar))
              res = new Scalar(res);
            if (format)
              res.format = format;
            return res;
          }
        }
      }
      if (scalarFallback)
        str = scalarFallback(str);
      return new Scalar(str);
    }
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    var consumeMoreIndentedLines = (text, i) => {
      let ch = text[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i += 1];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    };
    function foldFlowLines(text, indent, mode, {
      indentAtStart,
      lineWidth = 80,
      minContentWidth = 20,
      onFold,
      onOverflow
    }) {
      if (!lineWidth || lineWidth < 0)
        return text;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i);
          end = i + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    var getFoldOptions = ({
      indentAtStart
    }) => indentAtStart ? Object.assign({
      indentAtStart
    }, strOptions.fold) : strOptions.fold;
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const {
        implicitKey
      } = ctx;
      const {
        jsonEncoding,
        minMultiLineLength
      } = strOptions.doubleQuoted;
      const json = JSON.stringify(value);
      if (jsonEncoding)
        return json;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.implicitKey) {
        if (/\n/.test(value))
          return doubleQuotedString(value, ctx);
      } else {
        if (/[ \t]\n|\n[ \t]/.test(value))
          return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({
      comment,
      type,
      value
    }, ctx, onComment, onChompKeep) {
      if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const indentSize = indent ? "2" : "1";
      const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
      let header = literal ? "|" : ">";
      if (!value)
        return header + "\n";
      let wsStart = "";
      let wsEnd = "";
      value = value.replace(/[\n\t ]*$/, (ws) => {
        const n = ws.indexOf("\n");
        if (n === -1) {
          header += "-";
        } else if (value === ws || n !== ws.length - 1) {
          header += "+";
          if (onChompKeep)
            onChompKeep();
        }
        wsEnd = ws.replace(/\n$/, "");
        return "";
      }).replace(/^[\n ]*/, (ws) => {
        if (ws.indexOf(" ") !== -1)
          header += indentSize;
        const m = ws.match(/ +$/);
        if (m) {
          wsStart = ws.slice(0, -m[0].length);
          return m[0];
        } else {
          wsStart = ws;
          return "";
        }
      });
      if (wsEnd)
        wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      if (wsStart)
        wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
      if (comment) {
        header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
        if (onComment)
          onComment();
      }
      if (!value)
        return `${header}${indentSize}
${indent}${wsEnd}`;
      if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${wsStart}${value}${wsEnd}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const {
        comment,
        type,
        value
      } = item;
      const {
        actualString,
        implicitKey,
        indent,
        inFlow
      } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const {
          tags
        } = ctx.doc.schema;
        const resolved = resolveScalar(str, tags, tags.scalarFallback).value;
        if (typeof resolved !== "string")
          return doubleQuotedString(value, ctx);
      }
      const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
      if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
        if (onComment)
          onComment();
        return addCommentBefore(body, indent, comment);
      }
      return body;
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const {
        defaultType
      } = strOptions;
      const {
        implicitKey,
        inFlow
      } = ctx;
      let {
        type,
        value
      } = item;
      if (typeof value !== "string") {
        value = String(value);
        item = Object.assign({}, item, {
          value
        });
      }
      const _stringify = (_type) => {
        switch (_type) {
          case PlainValue.Type.BLOCK_FOLDED:
          case PlainValue.Type.BLOCK_LITERAL:
            return blockString(item, ctx, onComment, onChompKeep);
          case PlainValue.Type.QUOTE_DOUBLE:
            return doubleQuotedString(value, ctx);
          case PlainValue.Type.QUOTE_SINGLE:
            return singleQuotedString(value, ctx);
          case PlainValue.Type.PLAIN:
            return plainString(item, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
        type = PlainValue.Type.QUOTE_DOUBLE;
      } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {
        type = PlainValue.Type.QUOTE_DOUBLE;
      }
      let res = _stringify(type);
      if (res === null) {
        res = _stringify(defaultType);
        if (res === null)
          throw new Error(`Unsupported default string type ${defaultType}`);
      }
      return res;
    }
    function stringifyNumber({
      format,
      minFractionDigits,
      tag,
      value
    }) {
      if (typeof value === "bigint")
        return String(value);
      if (!isFinite(value))
        return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    function checkFlowCollectionEnd(errors, cst) {
      let char, name;
      switch (cst.type) {
        case PlainValue.Type.FLOW_MAP:
          char = "}";
          name = "flow map";
          break;
        case PlainValue.Type.FLOW_SEQ:
          char = "]";
          name = "flow sequence";
          break;
        default:
          errors.push(new PlainValue.YAMLSemanticError(cst, "Not a flow collection!?"));
          return;
      }
      let lastItem;
      for (let i = cst.items.length - 1; i >= 0; --i) {
        const item = cst.items[i];
        if (!item || item.type !== PlainValue.Type.COMMENT) {
          lastItem = item;
          break;
        }
      }
      if (lastItem && lastItem.char !== char) {
        const msg = `Expected ${name} to end with ${char}`;
        let err;
        if (typeof lastItem.offset === "number") {
          err = new PlainValue.YAMLSemanticError(cst, msg);
          err.offset = lastItem.offset + 1;
        } else {
          err = new PlainValue.YAMLSemanticError(lastItem, msg);
          if (lastItem.range && lastItem.range.end)
            err.offset = lastItem.range.end - lastItem.range.start;
        }
        errors.push(err);
      }
    }
    function checkFlowCommentSpace(errors, comment) {
      const prev = comment.context.src[comment.range.start - 1];
      if (prev !== "\n" && prev !== "	" && prev !== " ") {
        const msg = "Comments must be separated from other tokens by white space characters";
        errors.push(new PlainValue.YAMLSemanticError(comment, msg));
      }
    }
    function getLongKeyError(source, key) {
      const sk = String(key);
      const k = sk.substr(0, 8) + "..." + sk.substr(-8);
      return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
    }
    function resolveComments(collection, comments) {
      for (const {
        afterKey,
        before,
        comment
      } of comments) {
        let item = collection.items[before];
        if (!item) {
          if (comment !== void 0) {
            if (collection.comment)
              collection.comment += "\n" + comment;
            else
              collection.comment = comment;
          }
        } else {
          if (afterKey && item.value)
            item = item.value;
          if (comment === void 0) {
            if (afterKey || !item.commentBefore)
              item.spaceBefore = true;
          } else {
            if (item.commentBefore)
              item.commentBefore += "\n" + comment;
            else
              item.commentBefore = comment;
          }
        }
      }
    }
    function resolveString(doc, node) {
      const res = node.strValue;
      if (!res)
        return "";
      if (typeof res === "string")
        return res;
      res.errors.forEach((error) => {
        if (!error.source)
          error.source = node;
        doc.errors.push(error);
      });
      return res.str;
    }
    function resolveTagHandle(doc, node) {
      const {
        handle,
        suffix
      } = node.tag;
      let prefix = doc.tagPrefixes.find((p) => p.handle === handle);
      if (!prefix) {
        const dtp = doc.getDefaults().tagPrefixes;
        if (dtp)
          prefix = dtp.find((p) => p.handle === handle);
        if (!prefix)
          throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);
      }
      if (!suffix)
        throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);
      if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
        if (suffix[0] === "^") {
          doc.warnings.push(new PlainValue.YAMLWarning(node, "YAML 1.0 ^ tag expansion is not supported"));
          return suffix;
        }
        if (/[:/]/.test(suffix)) {
          const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
          return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
        }
      }
      return prefix.prefix + decodeURIComponent(suffix);
    }
    function resolveTagName(doc, node) {
      const {
        tag,
        type
      } = node;
      let nonSpecific = false;
      if (tag) {
        const {
          handle,
          suffix,
          verbatim
        } = tag;
        if (verbatim) {
          if (verbatim !== "!" && verbatim !== "!!")
            return verbatim;
          const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
          doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
        } else if (handle === "!" && !suffix) {
          nonSpecific = true;
        } else {
          try {
            return resolveTagHandle(doc, node);
          } catch (error) {
            doc.errors.push(error);
          }
        }
      }
      switch (type) {
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
        case PlainValue.Type.QUOTE_DOUBLE:
        case PlainValue.Type.QUOTE_SINGLE:
          return PlainValue.defaultTags.STR;
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        case PlainValue.Type.PLAIN:
          return nonSpecific ? PlainValue.defaultTags.STR : null;
        default:
          return null;
      }
    }
    function resolveByTagName(doc, node, tagName) {
      const {
        tags
      } = doc.schema;
      const matchWithTest = [];
      for (const tag of tags) {
        if (tag.tag === tagName) {
          if (tag.test)
            matchWithTest.push(tag);
          else {
            const res = tag.resolve(doc, node);
            return res instanceof Collection ? res : new Scalar(res);
          }
        }
      }
      const str = resolveString(doc, node);
      if (typeof str === "string" && matchWithTest.length > 0)
        return resolveScalar(str, matchWithTest, tags.scalarFallback);
      return null;
    }
    function getFallbackTagName({
      type
    }) {
      switch (type) {
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        default:
          return PlainValue.defaultTags.STR;
      }
    }
    function resolveTag(doc, node, tagName) {
      try {
        const res = resolveByTagName(doc, node, tagName);
        if (res) {
          if (tagName && node.tag)
            res.tag = tagName;
          return res;
        }
      } catch (error) {
        if (!error.source)
          error.source = node;
        doc.errors.push(error);
        return null;
      }
      try {
        const fallback = getFallbackTagName(node);
        if (!fallback)
          throw new Error(`The tag ${tagName} is unavailable`);
        const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
        doc.warnings.push(new PlainValue.YAMLWarning(node, msg));
        const res = resolveByTagName(doc, node, fallback);
        res.tag = tagName;
        return res;
      } catch (error) {
        const refError = new PlainValue.YAMLReferenceError(node, error.message);
        refError.stack = error.stack;
        doc.errors.push(refError);
        return null;
      }
    }
    var isCollectionItem = (node) => {
      if (!node)
        return false;
      const {
        type
      } = node;
      return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;
    };
    function resolveNodeProps(errors, node) {
      const comments = {
        before: [],
        after: []
      };
      let hasAnchor = false;
      let hasTag = false;
      const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
      for (const {
        start,
        end
      } of props) {
        switch (node.context.src[start]) {
          case PlainValue.Char.COMMENT: {
            if (!node.commentHasRequiredWhitespace(start)) {
              const msg = "Comments must be separated from other tokens by white space characters";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            const {
              header,
              valueRange
            } = node;
            const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
            cc.push(node.context.src.slice(start + 1, end));
            break;
          }
          case PlainValue.Char.ANCHOR:
            if (hasAnchor) {
              const msg = "A node can have at most one anchor";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            hasAnchor = true;
            break;
          case PlainValue.Char.TAG:
            if (hasTag) {
              const msg = "A node can have at most one tag";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            hasTag = true;
            break;
        }
      }
      return {
        comments,
        hasAnchor,
        hasTag
      };
    }
    function resolveNodeValue(doc, node) {
      const {
        anchors,
        errors,
        schema
      } = doc;
      if (node.type === PlainValue.Type.ALIAS) {
        const name = node.rawValue;
        const src = anchors.getNode(name);
        if (!src) {
          const msg = `Aliased anchor not found: ${name}`;
          errors.push(new PlainValue.YAMLReferenceError(node, msg));
          return null;
        }
        const res = new Alias(src);
        anchors._cstAliases.push(res);
        return res;
      }
      const tagName = resolveTagName(doc, node);
      if (tagName)
        return resolveTag(doc, node, tagName);
      if (node.type !== PlainValue.Type.PLAIN) {
        const msg = `Failed to resolve ${node.type} node here`;
        errors.push(new PlainValue.YAMLSyntaxError(node, msg));
        return null;
      }
      try {
        const str = resolveString(doc, node);
        return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
      } catch (error) {
        if (!error.source)
          error.source = node;
        errors.push(error);
        return null;
      }
    }
    function resolveNode(doc, node) {
      if (!node)
        return null;
      if (node.error)
        doc.errors.push(node.error);
      const {
        comments,
        hasAnchor,
        hasTag
      } = resolveNodeProps(doc.errors, node);
      if (hasAnchor) {
        const {
          anchors
        } = doc;
        const name = node.anchor;
        const prev = anchors.getNode(name);
        if (prev)
          anchors.map[anchors.newName(name)] = prev;
        anchors.map[name] = node;
      }
      if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
        const msg = "An alias node must not specify any properties";
        doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
      }
      const res = resolveNodeValue(doc, node);
      if (res) {
        res.range = [node.range.start, node.range.end];
        if (doc.options.keepCstNodes)
          res.cstNode = node;
        if (doc.options.keepNodeTypes)
          res.type = node.type;
        const cb = comments.before.join("\n");
        if (cb) {
          res.commentBefore = res.commentBefore ? `${res.commentBefore}
${cb}` : cb;
        }
        const ca = comments.after.join("\n");
        if (ca)
          res.comment = res.comment ? `${res.comment}
${ca}` : ca;
      }
      return node.resolved = res;
    }
    function resolveMap(doc, cst) {
      if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
        const msg = `A ${cst.type} node cannot be resolved as a mapping`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
      const map = new YAMLMap();
      map.items = items;
      resolveComments(map, comments);
      let hasCollectionKey = false;
      for (let i = 0; i < items.length; ++i) {
        const {
          key: iKey
        } = items[i];
        if (iKey instanceof Collection)
          hasCollectionKey = true;
        if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
          items[i] = new Merge(items[i]);
          const sources = items[i].value.items;
          let error = null;
          sources.some((node) => {
            if (node instanceof Alias) {
              const {
                type
              } = node.source;
              if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP)
                return false;
              return error = "Merge nodes aliases can only point to maps";
            }
            return error = "Merge nodes can only have Alias nodes as values";
          });
          if (error)
            doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
        } else {
          for (let j = i + 1; j < items.length; ++j) {
            const {
              key: jKey
            } = items[j];
            if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
              const msg = `Map keys must be unique; "${iKey}" is repeated`;
              doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
              break;
            }
          }
        }
      }
      if (hasCollectionKey && !doc.options.mapAsMap) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = map;
      return map;
    }
    var valueHasPairComment = ({
      context: {
        lineStart,
        node,
        src
      },
      props
    }) => {
      if (props.length === 0)
        return false;
      const {
        start
      } = props[0];
      if (node && start > node.valueRange.start)
        return false;
      if (src[start] !== PlainValue.Char.COMMENT)
        return false;
      for (let i = lineStart; i < start; ++i)
        if (src[i] === "\n")
          return false;
      return true;
    };
    function resolvePairComment(item, pair) {
      if (!valueHasPairComment(item))
        return;
      const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
      let found = false;
      const cb = pair.value.commentBefore;
      if (cb && cb.startsWith(comment)) {
        pair.value.commentBefore = cb.substr(comment.length + 1);
        found = true;
      } else {
        const cc = pair.value.comment;
        if (!item.node && cc && cc.startsWith(comment)) {
          pair.value.comment = cc.substr(comment.length + 1);
          found = true;
        }
      }
      if (found)
        pair.comment = comment;
    }
    function resolveBlockMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let keyStart = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              afterKey: !!key,
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              afterKey: !!key,
              before: items.length,
              comment: item.comment
            });
            break;
          case PlainValue.Type.MAP_KEY:
            if (key !== void 0)
              items.push(new Pair(key));
            if (item.error)
              doc.errors.push(item.error);
            key = resolveNode(doc, item.node);
            keyStart = null;
            break;
          case PlainValue.Type.MAP_VALUE:
            {
              if (key === void 0)
                key = null;
              if (item.error)
                doc.errors.push(item.error);
              if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
                const msg = "Nested mappings are not allowed in compact mappings";
                doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
              }
              let valueNode = item.node;
              if (!valueNode && item.props.length > 0) {
                valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
                valueNode.context = {
                  parent: item,
                  src: item.context.src
                };
                const pos = item.range.start + 1;
                valueNode.range = {
                  start: pos,
                  end: pos
                };
                valueNode.valueRange = {
                  start: pos,
                  end: pos
                };
                if (typeof item.range.origStart === "number") {
                  const origPos = item.range.origStart + 1;
                  valueNode.range.origStart = valueNode.range.origEnd = origPos;
                  valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                }
              }
              const pair = new Pair(key, resolveNode(doc, valueNode));
              resolvePairComment(item, pair);
              items.push(pair);
              if (key && typeof keyStart === "number") {
                if (item.range.start > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key));
              }
              key = void 0;
              keyStart = null;
            }
            break;
          default:
            if (key !== void 0)
              items.push(new Pair(key));
            key = resolveNode(doc, item);
            keyStart = item.range.start;
            if (item.error)
              doc.errors.push(item.error);
            next:
              for (let j = i + 1; ; ++j) {
                const nextItem = cst.items[j];
                switch (nextItem && nextItem.type) {
                  case PlainValue.Type.BLANK_LINE:
                  case PlainValue.Type.COMMENT:
                    continue next;
                  case PlainValue.Type.MAP_VALUE:
                    break next;
                  default: {
                    const msg = "Implicit map keys need to be followed by map values";
                    doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                    break next;
                  }
                }
              }
            if (item.valueRangeContainsNewline) {
              const msg = "Implicit map keys need to be on a single line";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
        }
      }
      if (key !== void 0)
        items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    function resolveFlowMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let explicitKey = false;
      let next = "{";
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char === "?" && key === void 0 && !explicitKey) {
            explicitKey = true;
            next = ":";
            continue;
          }
          if (char === ":") {
            if (key === void 0)
              key = null;
            if (next === ":") {
              next = ",";
              continue;
            }
          } else {
            if (explicitKey) {
              if (key === void 0 && char !== ",")
                key = null;
              explicitKey = false;
            }
            if (key !== void 0) {
              items.push(new Pair(key));
              key = void 0;
              if (char === ",") {
                next = ":";
                continue;
              }
            }
          }
          if (char === "}") {
            if (i === cst.items.length - 1)
              continue;
          } else if (char === next) {
            next = ":";
            continue;
          }
          const msg = `Flow map contains an unexpected ${char}`;
          const err = new PlainValue.YAMLSyntaxError(cst, msg);
          err.offset = offset;
          doc.errors.push(err);
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            afterKey: !!key,
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            afterKey: !!key,
            before: items.length,
            comment: item.comment
          });
        } else if (key === void 0) {
          if (next === ",")
            doc.errors.push(new PlainValue.YAMLSemanticError(item, "Separator , missing in flow map"));
          key = resolveNode(doc, item);
        } else {
          if (next !== ",")
            doc.errors.push(new PlainValue.YAMLSemanticError(item, "Indicator : missing in flow map entry"));
          items.push(new Pair(key, resolveNode(doc, item)));
          key = void 0;
          explicitKey = false;
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0)
        items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    function resolveSeq(doc, cst) {
      if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
        const msg = `A ${cst.type} node cannot be resolved as a sequence`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
      const seq = new YAMLSeq();
      seq.items = items;
      resolveComments(seq, comments);
      if (!doc.options.mapAsMap && items.some((it) => it instanceof Pair && it.key instanceof Collection)) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = seq;
      return seq;
    }
    function resolveBlockSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              comment: item.comment,
              before: items.length
            });
            break;
          case PlainValue.Type.SEQ_ITEM:
            if (item.error)
              doc.errors.push(item.error);
            items.push(resolveNode(doc, item.node));
            if (item.hasProps) {
              const msg = "Sequence items cannot have tags or anchors before the - indicator";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
            break;
          default:
            if (item.error)
              doc.errors.push(item.error);
            doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
        }
      }
      return {
        comments,
        items
      };
    }
    function resolveFlowSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      let explicitKey = false;
      let key = void 0;
      let keyStart = null;
      let next = "[";
      let prevItem = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char !== ":" && (explicitKey || key !== void 0)) {
            if (explicitKey && key === void 0)
              key = next ? items.pop() : null;
            items.push(new Pair(key));
            explicitKey = false;
            key = void 0;
            keyStart = null;
          }
          if (char === next) {
            next = null;
          } else if (!next && char === "?") {
            explicitKey = true;
          } else if (next !== "[" && char === ":" && key === void 0) {
            if (next === ",") {
              key = items.pop();
              if (key instanceof Pair) {
                const msg = "Chaining flow sequence pairs is invalid";
                const err = new PlainValue.YAMLSemanticError(cst, msg);
                err.offset = offset;
                doc.errors.push(err);
              }
              if (!explicitKey && typeof keyStart === "number") {
                const keyEnd = item.range ? item.range.start : item.offset;
                if (keyEnd > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key));
                const {
                  src
                } = prevItem.context;
                for (let i2 = keyStart; i2 < keyEnd; ++i2)
                  if (src[i2] === "\n") {
                    const msg = "Implicit keys of flow sequence pairs need to be on a single line";
                    doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
                    break;
                  }
              }
            } else {
              key = null;
            }
            keyStart = null;
            explicitKey = false;
            next = null;
          } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
            const msg = `Flow sequence contains an unexpected ${char}`;
            const err = new PlainValue.YAMLSyntaxError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            comment: item.comment,
            before: items.length
          });
        } else {
          if (next) {
            const msg = `Expected a ${next} in flow sequence`;
            doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
          }
          const value = resolveNode(doc, item);
          if (key === void 0) {
            items.push(value);
            prevItem = item;
          } else {
            items.push(new Pair(key, value));
            key = void 0;
          }
          keyStart = item.range.start;
          next = ",";
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0)
        items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    exports.Alias = Alias;
    exports.Collection = Collection;
    exports.Merge = Merge;
    exports.Node = Node;
    exports.Pair = Pair;
    exports.Scalar = Scalar;
    exports.YAMLMap = YAMLMap;
    exports.YAMLSeq = YAMLSeq;
    exports.addComment = addComment;
    exports.binaryOptions = binaryOptions;
    exports.boolOptions = boolOptions;
    exports.findPair = findPair;
    exports.intOptions = intOptions;
    exports.isEmptyPath = isEmptyPath;
    exports.nullOptions = nullOptions;
    exports.resolveMap = resolveMap;
    exports.resolveNode = resolveNode;
    exports.resolveSeq = resolveSeq;
    exports.resolveString = resolveString;
    exports.strOptions = strOptions;
    exports.stringifyNumber = stringifyNumber;
    exports.stringifyString = stringifyString;
    exports.toJSON = toJSON;
  }
});

// node_modules/yaml/dist/warnings-1000a372.js
var require_warnings_1000a372 = __commonJS({
  "node_modules/yaml/dist/warnings-1000a372.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      resolve: (doc, node) => {
        const src = resolveSeq.resolveString(doc, node);
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          const msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));
          return null;
        }
      },
      options: resolveSeq.binaryOptions,
      stringify: ({
        comment,
        type,
        value
      }, ctx, onComment, onChompKeep) => {
        let src;
        if (typeof Buffer === "function") {
          src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < value.length; ++i)
            s += String.fromCharCode(value[i]);
          src = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = resolveSeq.binaryOptions.defaultType;
        if (type === PlainValue.Type.QUOTE_DOUBLE) {
          value = src;
        } else {
          const {
            lineWidth
          } = resolveSeq.binaryOptions;
          const n = Math.ceil(src.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = src.substr(o, lineWidth);
          }
          value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return resolveSeq.stringifyString({
          comment,
          type,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    function parsePairs(doc, cst) {
      const seq = resolveSeq.resolveSeq(doc, cst);
      for (let i = 0; i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (item instanceof resolveSeq.Pair)
          continue;
        else if (item instanceof resolveSeq.YAMLMap) {
          if (item.items.length > 1) {
            const msg = "Each pair must have its own sequence indicator";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          }
          const pair = item.items[0] || new resolveSeq.Pair();
          if (item.commentBefore)
            pair.commentBefore = pair.commentBefore ? `${item.commentBefore}
${pair.commentBefore}` : item.commentBefore;
          if (item.comment)
            pair.comment = pair.comment ? `${item.comment}
${pair.comment}` : item.comment;
          item = pair;
        }
        seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
      }
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const pairs2 = new resolveSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      for (const it of iterable) {
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else
            throw new TypeError(`Expected { key: value } tuple: ${it}`);
        } else {
          key = it;
        }
        const pair = schema.createPair(key, value, ctx);
        pairs2.items.push(pair);
      }
      return pairs2;
    }
    var pairs = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    var YAMLOMap = class extends resolveSeq.YAMLSeq {
      constructor() {
        super();
        PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));
        PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));
        PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));
        PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));
        PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));
        this.tag = YAMLOMap.tag;
      }
      toJSON(_, ctx) {
        const map = new Map();
        if (ctx && ctx.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (pair instanceof resolveSeq.Pair) {
            key = resolveSeq.toJSON(pair.key, "", ctx);
            value = resolveSeq.toJSON(pair.value, key, ctx);
          } else {
            key = resolveSeq.toJSON(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
    };
    PlainValue._defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    function parseOMap(doc, cst) {
      const pairs2 = parsePairs(doc, cst);
      const seenKeys = [];
      for (const {
        key
      } of pairs2.items) {
        if (key instanceof resolveSeq.Scalar) {
          if (seenKeys.includes(key.value)) {
            const msg = "Ordered maps must not include duplicate keys";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs2);
    }
    function createOMap(schema, iterable, ctx) {
      const pairs2 = createPairs(schema, iterable, ctx);
      const omap2 = new YAMLOMap();
      omap2.items = pairs2.items;
      return omap2;
    }
    var omap = {
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    var YAMLSet = class extends resolveSeq.YAMLMap {
      constructor() {
        super();
        this.tag = YAMLSet.tag;
      }
      add(key) {
        const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
        const prev = resolveSeq.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      get(key, keepPair) {
        const pair = resolveSeq.findPair(this.items, key);
        return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = resolveSeq.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new resolveSeq.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues())
          return super.toString(ctx, onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
    };
    PlainValue._defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    function parseSet(doc, cst) {
      const map = resolveSeq.resolveMap(doc, cst);
      if (!map.hasAllNullValues())
        throw new PlainValue.YAMLSemanticError(cst, "Set items must all have null values");
      return Object.assign(new YAMLSet(), map);
    }
    function createSet(schema, iterable, ctx) {
      const set2 = new YAMLSet();
      for (const value of iterable)
        set2.items.push(schema.createPair(value, null, ctx));
      return set2;
    }
    var set = {
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    var parseSexagesimal = (sign, parts) => {
      const n = parts.split(":").reduce((n2, p) => n2 * 60 + Number(p), 0);
      return sign === "-" ? -n : n;
    };
    var stringifySexagesimal = ({
      value
    }) => {
      if (isNaN(value) || !isFinite(value))
        return resolveSeq.stringifyNumber(value);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value = Math.abs(value);
      }
      const parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
    };
    var intTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
        if (millisec)
          millisec = (millisec + "00").substr(1, 3);
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({
        value
      }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    function shouldWarn(deprecation) {
      const env = typeof process !== "undefined" && process.env || {};
      if (deprecation) {
        if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
          return !YAML_SILENCE_DEPRECATION_WARNINGS;
        return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
      }
      if (typeof YAML_SILENCE_WARNINGS !== "undefined")
        return !YAML_SILENCE_WARNINGS;
      return !env.YAML_SILENCE_WARNINGS;
    }
    function warn(warning, type) {
      if (shouldWarn(false)) {
        const emit = typeof process !== "undefined" && process.emitWarning;
        if (emit)
          emit(warning, type);
        else {
          console.warn(type ? `${type}: ${warning}` : warning);
        }
      }
    }
    function warnFileDeprecation(filename) {
      if (shouldWarn(true)) {
        const path = filename.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
        warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, "DeprecationWarning");
      }
    }
    var warned = {};
    function warnOptionDeprecation(name, alternative) {
      if (!warned[name] && shouldWarn(true)) {
        warned[name] = true;
        let msg = `The option '${name}' will be removed in a future release`;
        msg += alternative ? `, use '${alternative}' instead.` : ".";
        warn(msg, "DeprecationWarning");
      }
    }
    exports.binary = binary;
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.omap = omap;
    exports.pairs = pairs;
    exports.set = set;
    exports.timestamp = timestamp;
    exports.warn = warn;
    exports.warnFileDeprecation = warnFileDeprecation;
    exports.warnOptionDeprecation = warnOptionDeprecation;
  }
});

// node_modules/yaml/dist/Schema-88e323a7.js
var require_Schema_88e323a7 = __commonJS({
  "node_modules/yaml/dist/Schema-88e323a7.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var warnings = require_warnings_1000a372();
    function createMap(schema, obj, ctx) {
      const map2 = new resolveSeq.YAMLMap(schema);
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          map2.items.push(schema.createPair(key, value, ctx));
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          map2.items.push(schema.createPair(key, obj[key], ctx));
      }
      if (typeof schema.sortMapEntries === "function") {
        map2.items.sort(schema.sortMapEntries);
      }
      return map2;
    }
    var map = {
      createNode: createMap,
      default: true,
      nodeClass: resolveSeq.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveSeq.resolveMap
    };
    function createSeq(schema, obj, ctx) {
      const seq2 = new resolveSeq.YAMLSeq(schema);
      if (obj && obj[Symbol.iterator]) {
        for (const it of obj) {
          const v = schema.createNode(it, ctx.wrapScalars, null, ctx);
          seq2.items.push(v);
        }
      }
      return seq2;
    }
    var seq = {
      createNode: createSeq,
      default: true,
      nodeClass: resolveSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq.resolveSeq
    };
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: resolveSeq.strOptions
    };
    var failsafe = [map, seq, string];
    var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
    function intStringify$1(node, radix, prefix) {
      const {
        value
      } = node;
      if (intIdentify$2(value) && value >= 0)
        return prefix + value.toString(radix);
      return resolveSeq.stringifyNumber(node);
    }
    var nullObj = {
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    };
    var boolObj = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => str[0] === "t" || str[0] === "T",
      options: resolveSeq.boolOptions,
      stringify: ({
        value
      }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
    };
    var octObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: (str, oct) => intResolve$1(str, oct, 8),
      options: resolveSeq.intOptions,
      stringify: (node) => intStringify$1(node, 8, "0o")
    };
    var intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str) => intResolve$1(str, str, 10),
      options: resolveSeq.intOptions,
      stringify: resolveSeq.stringifyNumber
    };
    var hexObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: (str, hex) => intResolve$1(str, hex, 16),
      options: resolveSeq.intOptions,
      stringify: (node) => intStringify$1(node, 16, "0x")
    };
    var nanObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    };
    var expObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify: ({
        value
      }) => Number(value).toExponential()
    };
    var floatObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve(str, frac1, frac2) {
        const frac = frac1 || frac2;
        const node = new resolveSeq.Scalar(parseFloat(str));
        if (frac && frac[frac.length - 1] === "0")
          node.minFractionDigits = frac.length;
        return node;
      },
      stringify: resolveSeq.stringifyNumber
    };
    var core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    var intIdentify$1 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var stringifyJSON = ({
      value
    }) => JSON.stringify(value);
    var json = [map, seq, {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify: stringifyJSON
    }, {
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str) => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({
        value
      }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }];
    json.scalarFallback = (str) => {
      throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    };
    var boolStringify = ({
      value
    }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(sign, src, radix) {
      let str = src.replace(/_/g, "");
      if (resolveSeq.intOptions.asBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const {
        value
      } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return resolveSeq.stringifyNumber(node);
    }
    var yaml11 = failsafe.concat([{
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => true,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => false,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: (str, sign, bin) => intResolve(sign, bin, 2),
      stringify: (node) => intStringify(node, 2, "0b")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: (str, sign, oct) => intResolve(sign, oct, 8),
      stringify: (node) => intStringify(node, 8, "0")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: (str, sign, abs) => intResolve(sign, abs, 10),
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: (str, sign, hex) => intResolve(sign, hex, 16),
      stringify: (node) => intStringify(node, 16, "0x")
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify: ({
        value
      }) => Number(value).toExponential()
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve(str, frac) {
        const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, "")));
        if (frac) {
          const f = frac.replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: resolveSeq.stringifyNumber
    }], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);
    var schemas = {
      core,
      failsafe,
      json,
      yaml11
    };
    var tags = {
      binary: warnings.binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime: warnings.floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime: warnings.intTime,
      map,
      null: nullObj,
      omap: warnings.omap,
      pairs: warnings.pairs,
      seq,
      set: warnings.set,
      timestamp: warnings.timestamp
    };
    function findTagObject(value, tagName, tags2) {
      if (tagName) {
        const match = tags2.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) || match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags2.find((t) => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (value instanceof resolveSeq.Node)
        return value;
      const {
        defaultPrefix,
        onTagObj,
        prevObjects,
        schema,
        wrapScalars
      } = ctx;
      if (tagName && tagName.startsWith("!!"))
        tagName = defaultPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (typeof value.toJSON === "function")
          value = value.toJSON();
        if (!value || typeof value !== "object")
          return wrapScalars ? new resolveSeq.Scalar(value) : value;
        tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const obj = {
        value: void 0,
        node: void 0
      };
      if (value && typeof value === "object" && prevObjects) {
        const prev = prevObjects.get(value);
        if (prev) {
          const alias = new resolveSeq.Alias(prev);
          ctx.aliasNodes.push(alias);
          return alias;
        }
        obj.value = value;
        prevObjects.set(value, obj);
      }
      obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
      if (tagName && obj.node instanceof resolveSeq.Node)
        obj.node.tag = tagName;
      return obj.node;
    }
    function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
      let tags2 = schemas2[schemaId.replace(/\W/g, "")];
      if (!tags2) {
        const keys = Object.keys(schemas2).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags2 = tags2.concat(tag);
      } else if (typeof customTags === "function") {
        tags2 = customTags(tags2.slice());
      }
      for (let i = 0; i < tags2.length; ++i) {
        const tag = tags2[i];
        if (typeof tag === "string") {
          const tagObj = knownTags[tag];
          if (!tagObj) {
            const keys = Object.keys(knownTags).map((key) => JSON.stringify(key)).join(", ");
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
          }
          tags2[i] = tagObj;
        }
      }
      return tags2;
    }
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class {
      constructor({
        customTags,
        merge,
        schema,
        sortMapEntries,
        tags: deprecatedCustomTags
      }) {
        this.merge = !!merge;
        this.name = schema;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags)
          warnings.warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
      }
      createNode(value, wrapScalars, tagName, ctx) {
        const baseCtx = {
          defaultPrefix: Schema.defaultPrefix,
          schema: this,
          wrapScalars
        };
        const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
        return createNode(value, tagName, createCtx);
      }
      createPair(key, value, ctx) {
        if (!ctx)
          ctx = {
            wrapScalars: true
          };
        const k = this.createNode(key, ctx.wrapScalars, null, ctx);
        const v = this.createNode(value, ctx.wrapScalars, null, ctx);
        return new resolveSeq.Pair(k, v);
      }
    };
    PlainValue._defineProperty(Schema, "defaultPrefix", PlainValue.defaultTagPrefix);
    PlainValue._defineProperty(Schema, "defaultTags", PlainValue.defaultTags);
    exports.Schema = Schema;
  }
});

// node_modules/yaml/dist/types.js
var require_types3 = __commonJS({
  "node_modules/yaml/dist/types.js"(exports) {
    "use strict";
    var resolveSeq = require_resolveSeq_d03cb037();
    var Schema = require_Schema_88e323a7();
    require_PlainValue_ec8e588e();
    require_warnings_1000a372();
    exports.Alias = resolveSeq.Alias;
    exports.Collection = resolveSeq.Collection;
    exports.Merge = resolveSeq.Merge;
    exports.Node = resolveSeq.Node;
    exports.Pair = resolveSeq.Pair;
    exports.Scalar = resolveSeq.Scalar;
    exports.YAMLMap = resolveSeq.YAMLMap;
    exports.YAMLSeq = resolveSeq.YAMLSeq;
    exports.binaryOptions = resolveSeq.binaryOptions;
    exports.boolOptions = resolveSeq.boolOptions;
    exports.intOptions = resolveSeq.intOptions;
    exports.nullOptions = resolveSeq.nullOptions;
    exports.strOptions = resolveSeq.strOptions;
    exports.Schema = Schema.Schema;
  }
});

// node_modules/yaml/types.js
var require_types4 = __commonJS({
  "node_modules/yaml/types.js"(exports) {
    var types = require_types3();
    exports.binaryOptions = types.binaryOptions;
    exports.boolOptions = types.boolOptions;
    exports.intOptions = types.intOptions;
    exports.nullOptions = types.nullOptions;
    exports.strOptions = types.strOptions;
    exports.Schema = types.Schema;
    exports.Alias = types.Alias;
    exports.Collection = types.Collection;
    exports.Merge = types.Merge;
    exports.Node = types.Node;
    exports.Pair = types.Pair;
    exports.Scalar = types.Scalar;
    exports.YAMLMap = types.YAMLMap;
    exports.YAMLSeq = types.YAMLSeq;
  }
});

// src/lib/renderers/yaml.js
var require_yaml = __commonJS({
  "src/lib/renderers/yaml.js"(exports, module2) {
    var yaml = require_yaml();
    var { YAMLMap, YAMLSeq } = require_types4();
    var optionAPI = require_option();
    function getIn(obj, path) {
      return path.reduce((v, k) => k in v ? v[k] : {}, obj);
    }
    function addComments(context, path, commentNode, iterNode = commentNode) {
      const { title, description, comment } = getIn(context, path);
      const lines = [];
      if (optionAPI("renderTitle") && title) {
        lines.push(` ${title}`, "");
      }
      if (optionAPI("renderDescription") && description) {
        lines.push(` ${description}`);
      }
      if (optionAPI("renderComment") && comment) {
        lines.push(` ${comment}`);
      }
      commentNode.commentBefore = lines.join("\n");
      if (iterNode instanceof YAMLMap) {
        iterNode.items.forEach((n) => {
          addComments(context, [...path, "items", n.key.value], n.key, n.value);
        });
      } else if (iterNode instanceof YAMLSeq) {
        iterNode.items.forEach((n, i) => {
          addComments(context, [...path, "items", i], n);
        });
      }
    }
    function renderYAML({ value, context }) {
      const nodes = yaml.createNode(value);
      addComments(context, [], nodes);
      const doc = new yaml.Document();
      doc.contents = nodes;
      return doc.toString();
    }
    var yaml_default = renderYAML;
    module2.exports = yaml_default;
  }
});

// src/lib/renderers/index.js
var require_renderers = __commonJS({
  "src/lib/renderers/index.js"(exports, module2) {
    var renderJS = require_js();
    var renderYAML = require_yaml();
    Object.assign(module2.exports, { renderJS, renderYAML });
  }
});

// src/lib/index.js
var require_lib3 = __commonJS({
  "src/lib/index.js"(exports, module2) {
    var { getDependencies } = require_vendor();
    var Container = require_Container();
    var format = require_format();
    var option = require_option();
    var env = require_constants();
    var random = require_random();
    var utils = require_utils();
    var run = require_run();
    var { renderJS, renderYAML } = require_renderers();
    var container = new Container();
    function setupKeywords() {
      container.define("autoIncrement", function autoIncrement(value, schema) {
        if (!this.offset) {
          const min = schema.minimum || 1;
          const max = min + env.MAX_NUMBER;
          const offset = value.initialOffset || schema.initialOffset;
          this.offset = offset || random.number(min, max);
        }
        if (value === true) {
          return this.offset++;
        }
        return schema;
      });
      container.define("sequentialDate", function sequentialDate(value, schema) {
        if (!this.now) {
          this.now = random.date();
        }
        if (value) {
          schema = this.now.toISOString();
          value = value === true ? "days" : value;
          if (["seconds", "minutes", "hours", "days", "weeks", "months", "years"].indexOf(value) === -1) {
            throw new Error(`Unsupported increment by ${utils.short(value)}`);
          }
          this.now.setTime(this.now.getTime() + random.date(value));
        }
        return schema;
      });
    }
    function getRefs(refs, schema) {
      let $refs = {};
      if (Array.isArray(refs)) {
        refs.forEach((_schema) => {
          $refs[_schema.$id || _schema.id] = _schema;
        });
      } else {
        $refs = refs || {};
      }
      function walk(obj) {
        if (!obj || typeof obj !== "object")
          return;
        if (Array.isArray(obj))
          return obj.forEach(walk);
        const _id = obj.$id || obj.id;
        if (typeof _id === "string" && !$refs[_id]) {
          $refs[_id] = obj;
        }
        Object.keys(obj).forEach((key) => {
          walk(obj[key]);
        });
      }
      walk(refs);
      walk(schema);
      return $refs;
    }
    var jsf = (schema, refs, cwd) => {
      console.log("[json-schema-faker] calling JsonSchemaFaker() is deprecated, call either .generate() or .resolve()");
      if (cwd) {
        console.log("[json-schema-faker] references are only supported by calling .resolve()");
      }
      return jsf.generate(schema, refs);
    };
    jsf.generateWithContext = (schema, refs) => {
      const $refs = getRefs(refs, schema);
      return run($refs, schema, container, true);
    };
    jsf.generate = (schema, refs) => renderJS(jsf.generateWithContext(schema, refs));
    jsf.generateYAML = (schema, refs) => renderYAML(jsf.generateWithContext(schema, refs));
    jsf.resolveWithContext = (schema, refs, cwd) => {
      if (typeof refs === "string") {
        cwd = refs;
        refs = {};
      }
      cwd = cwd || (typeof process !== "undefined" ? process.cwd() : "");
      cwd = `${cwd.replace(/\/+$/, "")}/`;
      const $refs = getRefs(refs, schema);
      const fixedRefs = {
        order: 1,
        canRead(file) {
          const key = file.url.replace("/:", ":");
          return $refs[key] || $refs[key.split("/").pop()];
        },
        read(file, callback) {
          try {
            callback(null, this.canRead(file));
          } catch (e) {
            callback(e);
          }
        }
      };
      const { $RefParser: $RefParser2 } = getDependencies();
      return $RefParser2.bundle(cwd, schema, {
        resolve: {
          file: { order: 100 },
          http: { order: 200 },
          fixedRefs
        },
        dereference: {
          circular: "ignore"
        }
      }).then((sub) => run($refs, sub, container)).catch((e) => {
        throw new Error(`Error while resolving schema (${e.message})`);
      });
    };
    jsf.resolve = (schema, refs, cwd) => jsf.resolveWithContext(schema, refs, cwd).then(renderJS);
    jsf.resolveYAML = (schema, refs, cwd) => jsf.resolveWithContext(schema, refs, cwd).then(renderYAML);
    setupKeywords();
    jsf.format = format;
    jsf.option = option;
    jsf.random = random;
    jsf.extend = (name, cb) => {
      container.extend(name, cb);
      return jsf;
    };
    jsf.define = (name, cb) => {
      container.define(name, cb);
      return jsf;
    };
    jsf.reset = (name) => {
      container.reset(name);
      setupKeywords();
      return jsf;
    };
    jsf.locate = (name) => {
      return container.get(name);
    };
    if (typeof VERSION !== "undefined") {
      jsf.VERSION = VERSION;
    }
    var lib_default = jsf;
    module2.exports = lib_default;
  }
});

// src/main.cjs.js
__export(exports, {
  default: () => import_lib.default
});
var import_json_schema_ref_parser = __toModule(require("json-schema-ref-parser"));
var import_jsonpath_plus = __toModule(require("jsonpath-plus"));
var import_vendor = __toModule(require_vendor());
var import_lib = __toModule(require_lib3());
(0, import_vendor.setDependencies)({ $RefParser: import_json_schema_ref_parser.default, JSONPath: import_jsonpath_plus.JSONPath });
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3ZlbmRvci5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY2xhc3MvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NsYXNzL1JlZ2lzdHJ5LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9hcGkvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2FwaS9kZWZhdWx0cy5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY2xhc3MvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NsYXNzL09wdGlvblJlZ2lzdHJ5LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9hcGkvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2FwaS9vcHRpb24uanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvY29uc3RhbnRzLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL3JldC9saWIvdHlwZXMuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMvcmV0L2xpYi9zZXRzLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL3JldC9saWIvdXRpbC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL25vZGVfbW9kdWxlcy9yZXQvbGliL3Bvc2l0aW9ucy5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL25vZGVfbW9kdWxlcy9yZXQvbGliL2luZGV4LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL2RyYW5nZS9saWIvaW5kZXguanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMvcmFuZGV4cC9saWIvcmFuZGV4cC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9yYW5kb20uanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvdXRpbHMuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NsYXNzL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9jbGFzcy9Db250YWluZXIuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2FwaS9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvYXBpL2Zvcm1hdC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9lcnJvci5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9pbmZlci5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9ib29sZWFuLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvYm9vbGVhbi5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9udWxsLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvbnVsbC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3R5cGVzL2FycmF5LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvbnVtYmVyLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvaW50ZWdlci5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy93b3Jkcy5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3R5cGVzL29iamVjdC5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy90aHVuay5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9pcHY0LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9nZW5lcmF0b3JzL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9nZW5lcmF0b3JzL2RhdGVUaW1lLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9nZW5lcmF0b3JzL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9nZW5lcmF0b3JzL2RhdGUuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2dlbmVyYXRvcnMvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2dlbmVyYXRvcnMvdGltZS5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvZ2VuZXJhdG9ycy9jb3JlRm9ybWF0LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvc3RyaW5nLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi90eXBlcy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvdHlwZXMvaW5kZXguanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvdHJhdmVyc2UuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL2NvcmUvYnVpbGRSZXNvbHZlU2NoZW1hLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9jb3JlL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9jb3JlL3J1bi5qcyIsIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvcmVuZGVyZXJzL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9yZW5kZXJlcnMvanMuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMveWFtbC9kaXN0L1BsYWluVmFsdWUtZWM4ZTU4OGUuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3Jlc29sdmVTZXEtZDAzY2IwMzcuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3dhcm5pbmdzLTEwMDBhMzcyLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9TY2hlbWEtODhlMzIzYTcuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3R5cGVzLmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvbm9kZV9tb2R1bGVzL3lhbWwvdHlwZXMuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3JlbmRlcmVycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvcmVuZGVyZXJzL3lhbWwuanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbGliL3JlbmRlcmVycy9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvcmVuZGVyZXJzL2luZGV4LmpzIiwiL1VzZXJzL2FsdmFyby9Xb3Jrc3BhY2UvanNvbi1zY2hlbWEtZmFrZXIvc3JjL2xpYi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvaW5kZXguanMiLCIvVXNlcnMvYWx2YXJvL1dvcmtzcGFjZS9qc29uLXNjaGVtYS1mYWtlci9zcmMvbWFpbi5janMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgREVQRU5ERU5DSUVTID0ge307XG5cbmV4cG9ydCBjb25zdCBnZXREZXBlbmRlbmNpZXMgPSAoKSA9PiB7XG4gIHJldHVybiBERVBFTkRFTkNJRVM7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0RGVwZW5kZW5jaWVzID0gdmFsdWUgPT4ge1xuICBPYmplY3QuYXNzaWduKERFUEVOREVOQ0lFUywgdmFsdWUpO1xufTtcbiIsIi8qKlxuICogVGhpcyBjbGFzcyBkZWZpbmVzIGEgcmVnaXN0cnkgZm9yIGN1c3RvbSBmb3JtYXRzIHVzZWQgd2l0aGluIEpTRi5cbiAqL1xuY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBlbXB0eSBieSBkZWZhdWx0XG4gICAgdGhpcy5kYXRhID0ge307XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgY3VzdG9tIGZvcm1hdChzKVxuICAgKiBAcGFyYW0gbmFtZVxuICAgKi9cbiAgdW5yZWdpc3RlcihuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGF0YVtuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGN1c3RvbSBmb3JtYXRcbiAgICovXG4gIHJlZ2lzdGVyKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5kYXRhW25hbWVdID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgbWFueSBmb3JtYXRzIGF0IG9uZSBzaG90XG4gICAqL1xuICByZWdpc3Rlck1hbnkoZm9ybWF0cykge1xuICAgIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICB0aGlzLmRhdGFbbmFtZV0gPSBmb3JtYXRzW25hbWVdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZWxlbWVudCBieSByZWdpc3RyeSBrZXlcbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5kYXRhW25hbWVdO1xuXG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aG9sZSByZWdpc3RyeSBjb250ZW50XG4gICAqL1xuICBsaXN0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVnaXN0cnk7XG4iLCJjb25zdCBkZWZhdWx0cyA9IHt9O1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0cztcblxuZGVmYXVsdHMuZGVmYXVsdEludmFsaWRUeXBlUHJvZHVjdCA9IHVuZGVmaW5lZDtcbmRlZmF1bHRzLmRlZmF1bHRSYW5kRXhwTWF4ID0gMTA7XG5cbmRlZmF1bHRzLnBydW5lUHJvcGVydGllcyA9IFtdO1xuZGVmYXVsdHMuaWdub3JlUHJvcGVydGllcyA9IFtdO1xuZGVmYXVsdHMuaWdub3JlTWlzc2luZ1JlZnMgPSBmYWxzZTtcbmRlZmF1bHRzLmZhaWxPbkludmFsaWRUeXBlcyA9IHRydWU7XG5kZWZhdWx0cy5mYWlsT25JbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcblxuZGVmYXVsdHMuYWx3YXlzRmFrZU9wdGlvbmFscyA9IGZhbHNlO1xuZGVmYXVsdHMub3B0aW9uYWxzUHJvYmFiaWxpdHkgPSBudWxsO1xuZGVmYXVsdHMuZml4ZWRQcm9iYWJpbGl0aWVzID0gZmFsc2U7XG5kZWZhdWx0cy51c2VFeGFtcGxlc1ZhbHVlID0gZmFsc2U7XG5kZWZhdWx0cy51c2VEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbmRlZmF1bHRzLnJlcXVpcmVkT25seSA9IGZhbHNlO1xuXG5kZWZhdWx0cy5taW5JdGVtcyA9IDA7XG5kZWZhdWx0cy5tYXhJdGVtcyA9IG51bGw7XG5kZWZhdWx0cy5taW5MZW5ndGggPSAwO1xuZGVmYXVsdHMubWF4TGVuZ3RoID0gbnVsbDtcblxuZGVmYXVsdHMucmVzb2x2ZUpzb25QYXRoID0gZmFsc2U7XG5kZWZhdWx0cy5yZXVzZVByb3BlcnRpZXMgPSBmYWxzZTtcbmRlZmF1bHRzLmZpbGxQcm9wZXJ0aWVzID0gdHJ1ZTtcbmRlZmF1bHRzLnJlcGxhY2VFbXB0eUJ5UmFuZG9tVmFsdWUgPSBmYWxzZTtcblxuZGVmYXVsdHMucmFuZG9tID0gTWF0aC5yYW5kb207XG5cbmRlZmF1bHRzLnJlbmRlclRpdGxlID0gdHJ1ZTtcbmRlZmF1bHRzLnJlbmRlckRlc2NyaXB0aW9uID0gdHJ1ZTtcbmRlZmF1bHRzLnJlbmRlckNvbW1lbnQgPSBmYWxzZTtcbiIsImltcG9ydCBSZWdpc3RyeSBmcm9tICcuL1JlZ2lzdHJ5JztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9hcGkvZGVmYXVsdHMnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZGVmaW5lcyBhIHJlZ2lzdHJ5IGZvciBjdXN0b20gc2V0dGluZ3MgdXNlZCB3aXRoaW4gSlNGLlxuICovXG5jbGFzcyBPcHRpb25SZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRhdGEgPSB7IC4uLmRlZmF1bHRzIH07XG4gICAgdGhpcy5fZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgfVxuXG4gIGdldCBkZWZhdWx0cygpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLl9kZWZhdWx0cyB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9wdGlvblJlZ2lzdHJ5O1xuIiwiaW1wb3J0IE9wdGlvblJlZ2lzdHJ5IGZyb20gJy4uL2NsYXNzL09wdGlvblJlZ2lzdHJ5JztcblxuLy8gaW5zdGFudGlhdGVcbmNvbnN0IHJlZ2lzdHJ5ID0gbmV3IE9wdGlvblJlZ2lzdHJ5KCk7XG5cbi8qKlxuICogQ3VzdG9tIG9wdGlvbiBBUElcbiAqXG4gKiBAcGFyYW0gbmFtZU9yT3B0aW9uTWFwXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBvcHRpb25BUEkobmFtZU9yT3B0aW9uTWFwLCBvcHRpb25hbFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yT3B0aW9uTWFwID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uYWxWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiByZWdpc3RyeS5yZWdpc3RlcihuYW1lT3JPcHRpb25NYXAsIG9wdGlvbmFsVmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpc3RyeS5nZXQobmFtZU9yT3B0aW9uTWFwKTtcbiAgfVxuXG4gIHJldHVybiByZWdpc3RyeS5yZWdpc3Rlck1hbnkobmFtZU9yT3B0aW9uTWFwKTtcbn1cblxub3B0aW9uQVBJLmdldERlZmF1bHRzID0gKCkgPT4gcmVnaXN0cnkuZGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IG9wdGlvbkFQSTtcbiIsImNvbnN0IEFMTE9XRURfVFlQRVMgPSBbJ2ludGVnZXInLCAnbnVtYmVyJywgJ3N0cmluZycsICdib29sZWFuJ107XG5jb25zdCBTQ0FMQVJfVFlQRVMgPSBBTExPV0VEX1RZUEVTLmNvbmNhdChbJ251bGwnXSk7XG5jb25zdCBBTExfVFlQRVMgPSBbJ2FycmF5JywgJ29iamVjdCddLmNvbmNhdChTQ0FMQVJfVFlQRVMpO1xuXG5jb25zdCBNT1NUX05FQVJfREFURVRJTUUgPSAyNTI0NjA4MDAwMDAwO1xuXG5jb25zdCBNSU5fSU5URUdFUiA9IC0xMDAwMDAwMDA7XG5jb25zdCBNQVhfSU5URUdFUiA9IDEwMDAwMDAwMDtcblxuY29uc3QgTUlOX05VTUJFUiA9IC0xMDA7XG5jb25zdCBNQVhfTlVNQkVSID0gMTAwO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFMTE9XRURfVFlQRVMsXG4gIFNDQUxBUl9UWVBFUyxcbiAgQUxMX1RZUEVTLFxuICBNSU5fTlVNQkVSLFxuICBNQVhfTlVNQkVSLFxuICBNSU5fSU5URUdFUixcbiAgTUFYX0lOVEVHRVIsXG4gIE1PU1RfTkVBUl9EQVRFVElNRSxcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUk9PVCAgICAgICA6IDAsXG4gIEdST1VQICAgICAgOiAxLFxuICBQT1NJVElPTiAgIDogMixcbiAgU0VUICAgICAgICA6IDMsXG4gIFJBTkdFICAgICAgOiA0LFxuICBSRVBFVElUSU9OIDogNSxcbiAgUkVGRVJFTkNFICA6IDYsXG4gIENIQVIgICAgICAgOiA3LFxufTtcbiIsImNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5jb25zdCBJTlRTID0gKCkgPT4gW3sgdHlwZTogdHlwZXMuUkFOR0UgLCBmcm9tOiA0OCwgdG86IDU3IH1dO1xuXG5jb25zdCBXT1JEUyA9ICgpID0+IHtcbiAgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA5NSB9LFxuICAgIHsgdHlwZTogdHlwZXMuUkFOR0UsIGZyb206IDk3LCB0bzogMTIyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5SQU5HRSwgZnJvbTogNjUsIHRvOiA5MCB9XG4gIF0uY29uY2F0KElOVFMoKSk7XG59O1xuXG5jb25zdCBXSElURVNQQUNFID0gKCkgPT4ge1xuICByZXR1cm4gW1xuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDkgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDExIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMyB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDMyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTYwIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogNTc2MCB9LFxuICAgIHsgdHlwZTogdHlwZXMuUkFOR0UsIGZyb206IDgxOTIsIHRvOiA4MjAyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIzMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMzMgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjM5IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODI4NyB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDEyMjg4IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogNjUyNzkgfVxuICBdO1xufTtcblxuY29uc3QgTk9UQU5ZQ0hBUiA9ICgpID0+IHtcbiAgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDEzIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIzMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMzMgfSxcbiAgXTtcbn07XG5cbi8vIFByZWRlZmluZWQgY2xhc3Mgb2JqZWN0cy5cbmV4cG9ydHMud29yZHMgPSAoKSA9PiAoeyB0eXBlOiB0eXBlcy5TRVQsIHNldDogV09SRFMoKSwgbm90OiBmYWxzZSB9KTtcbmV4cG9ydHMubm90V29yZHMgPSAoKSA9PiAoeyB0eXBlOiB0eXBlcy5TRVQsIHNldDogV09SRFMoKSwgbm90OiB0cnVlIH0pO1xuZXhwb3J0cy5pbnRzID0gKCkgPT4gKHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IElOVFMoKSwgbm90OiBmYWxzZSB9KTtcbmV4cG9ydHMubm90SW50cyA9ICgpID0+ICh7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBJTlRTKCksIG5vdDogdHJ1ZSB9KTtcbmV4cG9ydHMud2hpdGVzcGFjZSA9ICgpID0+ICh7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBXSElURVNQQUNFKCksIG5vdDogZmFsc2UgfSk7XG5leHBvcnRzLm5vdFdoaXRlc3BhY2UgPSAoKSA9PiAoeyB0eXBlOiB0eXBlcy5TRVQsIHNldDogV0hJVEVTUEFDRSgpLCBub3Q6IHRydWUgfSk7XG5leHBvcnRzLmFueUNoYXIgPSAoKSA9PiAoeyB0eXBlOiB0eXBlcy5TRVQsIHNldDogTk9UQU5ZQ0hBUigpLCBub3Q6IHRydWUgfSk7XG4iLCJjb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHNldHMgID0gcmVxdWlyZSgnLi9zZXRzJyk7XG5cblxuY29uc3QgQ1RSTCA9ICdAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eID8nO1xuY29uc3QgU0xTSCA9IHsgJzAnOiAwLCAndCc6IDksICduJzogMTAsICd2JzogMTEsICdmJzogMTIsICdyJzogMTMgfTtcblxuLyoqXG4gKiBGaW5kcyBjaGFyYWN0ZXIgcmVwcmVzZW50YXRpb25zIGluIHN0ciBhbmQgY29udmVydCBhbGwgdG9cbiAqIHRoZWlyIHJlc3BlY3RpdmUgY2hhcmFjdGVyc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5zdHJUb0NoYXJzID0gZnVuY3Rpb24oc3RyKSB7XG4gIC8qIGpzaGludCBtYXhsZW46IGZhbHNlICovXG4gIHZhciBjaGFyc19yZWdleCA9IC8oXFxbXFxcXGJcXF0pfChcXFxcKT9cXFxcKD86dShbQS1GMC05XXs0fSl8eChbQS1GMC05XXsyfSl8KDA/WzAtN117Mn0pfGMoW0BBLVpbXFxcXFxcXV4/XSl8KFswdG52ZnJdKSkvZztcbiAgc3RyID0gc3RyLnJlcGxhY2UoY2hhcnNfcmVnZXgsIGZ1bmN0aW9uKHMsIGIsIGxicywgYTE2LCBiMTYsIGM4LCBkY3RybCwgZXNsc2gpIHtcbiAgICBpZiAobGJzKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IGIgPyA4IDpcbiAgICAgIGExNiAgID8gcGFyc2VJbnQoYTE2LCAxNikgOlxuICAgICAgYjE2ICAgPyBwYXJzZUludChiMTYsIDE2KSA6XG4gICAgICBjOCAgICA/IHBhcnNlSW50KGM4LCAgIDgpIDpcbiAgICAgIGRjdHJsID8gQ1RSTC5pbmRleE9mKGRjdHJsKSA6XG4gICAgICBTTFNIW2VzbHNoXTtcblxuICAgIHZhciBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcblxuICAgIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJhY3RlcnMuXG4gICAgaWYgKC9bW1xcXXt9XiQufD8qKygpXS8udGVzdChjKSkge1xuICAgICAgYyA9ICdcXFxcJyArIGM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG4gIH0pO1xuXG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8qKlxuICogdHVybnMgY2xhc3MgaW50byB0b2tlbnNcbiAqIHJlYWRzIHN0ciB1bnRpbCBpdCBlbmNvdW50ZXJzIGEgXSBub3QgcHJlY2VlZGVkIGJ5IGEgXFxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVnZXhwU3RyXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPE9iamVjdD4sIE51bWJlcj59XG4gKi9cbmV4cG9ydHMudG9rZW5pemVDbGFzcyA9IChzdHIsIHJlZ2V4cFN0cikgPT4ge1xuICAvKiBqc2hpbnQgbWF4bGVuOiBmYWxzZSAqL1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByZWdleHAgPSAvXFxcXCg/Oih3KXwoZCl8KHMpfChXKXwoRCl8KFMpKXwoKD86KD86XFxcXCkoLil8KFteXFxdXFxcXF0pKS0oPzpcXFxcKT8oW15cXF1dKSl8KFxcXSl8KD86XFxcXCk/KFteXSkvZztcbiAgdmFyIHJzLCBjO1xuXG5cbiAgd2hpbGUgKChycyA9IHJlZ2V4cC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICBpZiAocnNbMV0pIHtcbiAgICAgIHRva2Vucy5wdXNoKHNldHMud29yZHMoKSk7XG5cbiAgICB9IGVsc2UgaWYgKHJzWzJdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLmludHMoKSk7XG5cbiAgICB9IGVsc2UgaWYgKHJzWzNdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLndoaXRlc3BhY2UoKSk7XG5cbiAgICB9IGVsc2UgaWYgKHJzWzRdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLm5vdFdvcmRzKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1s1XSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy5ub3RJbnRzKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1s2XSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy5ub3RXaGl0ZXNwYWNlKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1s3XSkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlcy5SQU5HRSxcbiAgICAgICAgZnJvbTogKHJzWzhdIHx8IHJzWzldKS5jaGFyQ29kZUF0KDApLFxuICAgICAgICB0bzogcnNbMTBdLmNoYXJDb2RlQXQoMCksXG4gICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAoKGMgPSByc1sxMl0pKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGVzLkNIQVIsXG4gICAgICAgIHZhbHVlOiBjLmNoYXJDb2RlQXQoMCksXG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3Rva2VucywgcmVnZXhwLmxhc3RJbmRleF07XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5lcnJvcihyZWdleHBTdHIsICdVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzJyk7XG59O1xuXG5cbi8qKlxuICogU2hvcnRjdXQgdG8gdGhyb3cgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWdleHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2dcbiAqL1xuZXhwb3J0cy5lcnJvciA9IChyZWdleHAsIG1zZykgPT4ge1xuICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvJyArIHJlZ2V4cCArICcvOiAnICsgbXNnKTtcbn07XG4iLCJjb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmV4cG9ydHMud29yZEJvdW5kYXJ5ID0gKCkgPT4gKHsgdHlwZTogdHlwZXMuUE9TSVRJT04sIHZhbHVlOiAnYicgfSk7XG5leHBvcnRzLm5vbldvcmRCb3VuZGFyeSA9ICgpID0+ICh7IHR5cGU6IHR5cGVzLlBPU0lUSU9OLCB2YWx1ZTogJ0InIH0pO1xuZXhwb3J0cy5iZWdpbiA9ICgpID0+ICh7IHR5cGU6IHR5cGVzLlBPU0lUSU9OLCB2YWx1ZTogJ14nIH0pO1xuZXhwb3J0cy5lbmQgPSAoKSA9PiAoeyB0eXBlOiB0eXBlcy5QT1NJVElPTiwgdmFsdWU6ICckJyB9KTtcbiIsImNvbnN0IHV0aWwgICAgICA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgdHlwZXMgICAgID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3Qgc2V0cyAgICAgID0gcmVxdWlyZSgnLi9zZXRzJyk7XG5jb25zdCBwb3NpdGlvbnMgPSByZXF1aXJlKCcuL3Bvc2l0aW9ucycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKHJlZ2V4cFN0cikgPT4ge1xuICB2YXIgaSA9IDAsIGwsIGMsXG4gICAgc3RhcnQgPSB7IHR5cGU6IHR5cGVzLlJPT1QsIHN0YWNrOiBbXX0sXG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIGxhc3QgY2xhdXNlL2dyb3VwIGFuZCBzdGFjay5cbiAgICBsYXN0R3JvdXAgPSBzdGFydCxcbiAgICBsYXN0ID0gc3RhcnQuc3RhY2ssXG4gICAgZ3JvdXBTdGFjayA9IFtdO1xuXG5cbiAgdmFyIHJlcGVhdEVyciA9IChpKSA9PiB7XG4gICAgdXRpbC5lcnJvcihyZWdleHBTdHIsIGBOb3RoaW5nIHRvIHJlcGVhdCBhdCBjb2x1bW4gJHtpIC0gMX1gKTtcbiAgfTtcblxuICAvLyBEZWNvZGUgYSBmZXcgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICB2YXIgc3RyID0gdXRpbC5zdHJUb0NoYXJzKHJlZ2V4cFN0cik7XG4gIGwgPSBzdHIubGVuZ3RoO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBpbiBzdHJpbmcuXG4gIHdoaWxlIChpIDwgbCkge1xuICAgIGMgPSBzdHJbaSsrXTtcblxuICAgIHN3aXRjaCAoYykge1xuICAgICAgLy8gSGFuZGxlIGVzY2FwZWQgY2hhcmFjdGVycywgaW5jbHVlcyBhIGZldyBzZXRzLlxuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIGMgPSBzdHJbaSsrXTtcblxuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChwb3NpdGlvbnMud29yZEJvdW5kYXJ5KCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChwb3NpdGlvbnMubm9uV29yZEJvdW5kYXJ5KCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLndvcmRzKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLm5vdFdvcmRzKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLmludHMoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHNldHMubm90SW50cygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy53aGl0ZXNwYWNlKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLm5vdFdoaXRlc3BhY2UoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjIGlzIGludGVnZXIuXG4gICAgICAgICAgICAvLyBJbiB3aGljaCBjYXNlIGl0J3MgYSByZWZlcmVuY2UuXG4gICAgICAgICAgICBpZiAoL1xcZC8udGVzdChjKSkge1xuICAgICAgICAgICAgICBsYXN0LnB1c2goeyB0eXBlOiB0eXBlcy5SRUZFUkVOQ0UsIHZhbHVlOiBwYXJzZUludChjLCAxMCkgfSk7XG5cbiAgICAgICAgICAgIC8vIEVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdC5wdXNoKHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IGMuY2hhckNvZGVBdCgwKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIFBvc2l0aW9uYWxzLlxuICAgICAgY2FzZSAnXic6XG4gICAgICAgIGxhc3QucHVzaChwb3NpdGlvbnMuYmVnaW4oKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICckJzpcbiAgICAgICAgbGFzdC5wdXNoKHBvc2l0aW9ucy5lbmQoKSk7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIEhhbmRsZSBjdXN0b20gc2V0cy5cbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNsYXNzIGlzICdhbnRpJyBpLmUuIFteYWJjXS5cbiAgICAgICAgdmFyIG5vdDtcbiAgICAgICAgaWYgKHN0cltpXSA9PT0gJ14nKSB7XG4gICAgICAgICAgbm90ID0gdHJ1ZTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYWxsIHRoZSBjaGFyYWN0ZXJzIGluIGNsYXNzLlxuICAgICAgICB2YXIgY2xhc3NUb2tlbnMgPSB1dGlsLnRva2VuaXplQ2xhc3Moc3RyLnNsaWNlKGkpLCByZWdleHBTdHIpO1xuXG4gICAgICAgIC8vIEluY3JlYXNlIGluZGV4IGJ5IGxlbmd0aCBvZiBjbGFzcy5cbiAgICAgICAgaSArPSBjbGFzc1Rva2Vuc1sxXTtcbiAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5TRVQsXG4gICAgICAgICAgc2V0OiBjbGFzc1Rva2Vuc1swXSxcbiAgICAgICAgICBub3QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIENsYXNzIG9mIGFueSBjaGFyYWN0ZXIgZXhjZXB0IFxcbi5cbiAgICAgIGNhc2UgJy4nOlxuICAgICAgICBsYXN0LnB1c2goc2V0cy5hbnlDaGFyKCkpO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBQdXNoIGdyb3VwIG9udG8gc3RhY2suXG4gICAgICBjYXNlICcoJzpcbiAgICAgICAgLy8gQ3JlYXRlIGdyb3VwLlxuICAgICAgICB2YXIgZ3JvdXAgPSB7XG4gICAgICAgICAgdHlwZTogdHlwZXMuR1JPVVAsXG4gICAgICAgICAgc3RhY2s6IFtdLFxuICAgICAgICAgIHJlbWVtYmVyOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIGMgPSBzdHJbaV07XG5cbiAgICAgICAgLy8gSWYgaWYgdGhpcyBpcyBhIHNwZWNpYWwga2luZCBvZiBncm91cC5cbiAgICAgICAgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgIGMgPSBzdHJbaSArIDFdO1xuICAgICAgICAgIGkgKz0gMjtcblxuICAgICAgICAgIC8vIE1hdGNoIGlmIGZvbGxvd2VkIGJ5LlxuICAgICAgICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIGdyb3VwLmZvbGxvd2VkQnkgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gTWF0Y2ggaWYgbm90IGZvbGxvd2VkIGJ5LlxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICBncm91cC5ub3RGb2xsb3dlZEJ5ID0gdHJ1ZTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJzonKSB7XG4gICAgICAgICAgICB1dGlsLmVycm9yKHJlZ2V4cFN0cixcbiAgICAgICAgICAgICAgYEludmFsaWQgZ3JvdXAsIGNoYXJhY3RlciAnJHtjfSdgICtcbiAgICAgICAgICAgICAgYCBhZnRlciAnPycgYXQgY29sdW1uICR7aSAtIDF9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3JvdXAucmVtZW1iZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydCBzdWJncm91cCBpbnRvIGN1cnJlbnQgZ3JvdXAgc3RhY2suXG4gICAgICAgIGxhc3QucHVzaChncm91cCk7XG5cbiAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGN1cnJlbnQgZ3JvdXAgZm9yIHdoZW4gdGhlIGdyb3VwIGNsb3Nlcy5cbiAgICAgICAgZ3JvdXBTdGFjay5wdXNoKGxhc3RHcm91cCk7XG5cbiAgICAgICAgLy8gTWFrZSB0aGlzIG5ldyBncm91cCB0aGUgY3VycmVudCBncm91cC5cbiAgICAgICAgbGFzdEdyb3VwID0gZ3JvdXA7XG4gICAgICAgIGxhc3QgPSBncm91cC5zdGFjaztcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gUG9wIGdyb3VwIG91dCBvZiBzdGFjay5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICBpZiAoZ3JvdXBTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB1dGlsLmVycm9yKHJlZ2V4cFN0ciwgYFVubWF0Y2hlZCApIGF0IGNvbHVtbiAke2kgLSAxfWApO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RHcm91cCA9IGdyb3VwU3RhY2sucG9wKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBncm91cCBoYXMgYSBQSVBFLlxuICAgICAgICAvLyBUbyBnZXQgYmFjayB0aGUgY29ycmVjdCBsYXN0IHN0YWNrLlxuICAgICAgICBsYXN0ID0gbGFzdEdyb3VwLm9wdGlvbnMgP1xuICAgICAgICAgIGxhc3RHcm91cC5vcHRpb25zW2xhc3RHcm91cC5vcHRpb25zLmxlbmd0aCAtIDFdIDogbGFzdEdyb3VwLnN0YWNrO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBVc2UgcGlwZSBjaGFyYWN0ZXIgdG8gZ2l2ZSBtb3JlIGNob2ljZXMuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgLy8gQ3JlYXRlIGFycmF5IHdoZXJlIG9wdGlvbnMgYXJlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IFBJUEVcbiAgICAgICAgLy8gaW4gdGhpcyBjbGF1c2UuXG4gICAgICAgIGlmICghbGFzdEdyb3VwLm9wdGlvbnMpIHtcbiAgICAgICAgICBsYXN0R3JvdXAub3B0aW9ucyA9IFtsYXN0R3JvdXAuc3RhY2tdO1xuICAgICAgICAgIGRlbGV0ZSBsYXN0R3JvdXAuc3RhY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgc3RhY2sgYW5kIGFkZCB0byBvcHRpb25zIGZvciByZXN0IG9mIGNsYXVzZS5cbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIGxhc3RHcm91cC5vcHRpb25zLnB1c2goc3RhY2spO1xuICAgICAgICBsYXN0ID0gc3RhY2s7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIFJlcGV0aXRpb24uXG4gICAgICAvLyBGb3IgZXZlcnkgcmVwZXRpdGlvbiwgcmVtb3ZlIGxhc3QgZWxlbWVudCBmcm9tIGxhc3Qgc3RhY2tcbiAgICAgIC8vIHRoZW4gaW5zZXJ0IGJhY2sgYSBSQU5HRSBvYmplY3QuXG4gICAgICAvLyBUaGlzIGRlc2lnbiBpcyBjaG9zZW4gYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtb3JlIHRoYW5cbiAgICAgIC8vIG9uZSByZXBldGl0aW9uIHN5bWJvbHMgaW4gYSByZWdleCBpLmUuIGBhPyt7MiwzfWAuXG4gICAgICBjYXNlICd7JzpcbiAgICAgICAgdmFyIHJzID0gL14oXFxkKykoLChcXGQrKT8pP1xcfS8uZXhlYyhzdHIuc2xpY2UoaSkpLCBtaW4sIG1heDtcbiAgICAgICAgaWYgKHJzICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXBlYXRFcnIoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1pbiA9IHBhcnNlSW50KHJzWzFdLCAxMCk7XG4gICAgICAgICAgbWF4ID0gcnNbMl0gPyByc1szXSA/IHBhcnNlSW50KHJzWzNdLCAxMCkgOiBJbmZpbml0eSA6IG1pbjtcbiAgICAgICAgICBpICs9IHJzWzBdLmxlbmd0aDtcblxuICAgICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlcy5SRVBFVElUSU9OLFxuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgdmFsdWU6IGxhc3QucG9wKCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVzLkNIQVIsXG4gICAgICAgICAgICB2YWx1ZTogMTIzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc/JzpcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVwZWF0RXJyKGkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZXMuUkVQRVRJVElPTixcbiAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgIHZhbHVlOiBsYXN0LnBvcCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgICBpZiAobGFzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXBlYXRFcnIoaSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5SRVBFVElUSU9OLFxuICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICBtYXg6IEluZmluaXR5LFxuICAgICAgICAgIHZhbHVlOiBsYXN0LnBvcCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyonOlxuICAgICAgICBpZiAobGFzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXBlYXRFcnIoaSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5SRVBFVElUSU9OLFxuICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICBtYXg6IEluZmluaXR5LFxuICAgICAgICAgIHZhbHVlOiBsYXN0LnBvcCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gRGVmYXVsdCBpcyBhIGNoYXJhY3RlciB0aGF0IGlzIG5vdCBgXFxbXSgpe30/KypeJGAuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGVzLkNIQVIsXG4gICAgICAgICAgdmFsdWU6IGMuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxuICAvLyBDaGVjayBpZiBhbnkgZ3JvdXBzIGhhdmUgbm90IGJlZW4gY2xvc2VkLlxuICBpZiAoZ3JvdXBTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICB1dGlsLmVycm9yKHJlZ2V4cFN0ciwgJ1VudGVybWluYXRlZCBncm91cCcpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0O1xufTtcblxubW9kdWxlLmV4cG9ydHMudHlwZXMgPSB0eXBlcztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludCBpbmRlbnQ6IDQgKi9cblxuXG4vLyBQcml2YXRlIGhlbHBlciBjbGFzc1xuY2xhc3MgU3ViUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvdywgaGlnaCkge1xuICAgICAgICB0aGlzLmxvdyA9IGxvdztcbiAgICAgICAgdGhpcy5oaWdoID0gaGlnaDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxICsgaGlnaCAtIGxvdztcbiAgICB9XG5cbiAgICBvdmVybGFwcyhyYW5nZSkge1xuICAgICAgICByZXR1cm4gISh0aGlzLmhpZ2ggPCByYW5nZS5sb3cgfHwgdGhpcy5sb3cgPiByYW5nZS5oaWdoKTtcbiAgICB9XG5cbiAgICB0b3VjaGVzKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMuaGlnaCArIDEgPCByYW5nZS5sb3cgfHwgdGhpcy5sb3cgLSAxID4gcmFuZ2UuaGlnaCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBpbmNsdXNpdmUgY29tYmluYXRpb24gb2YgU3ViUmFuZ2VzIGFzIGEgU3ViUmFuZ2UuXG4gICAgYWRkKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViUmFuZ2UoXG4gICAgICAgICAgICBNYXRoLm1pbih0aGlzLmxvdywgcmFuZ2UubG93KSxcbiAgICAgICAgICAgIE1hdGgubWF4KHRoaXMuaGlnaCwgcmFuZ2UuaGlnaClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHN1YnRyYWN0aW9uIG9mIFN1YlJhbmdlcyBhcyBhbiBhcnJheSBvZiBTdWJSYW5nZXMuXG4gICAgLy8gKFRoZXJlJ3MgYSBjYXNlIHdoZXJlIHN1YnRyYWN0aW9uIGRpdmlkZXMgaXQgaW4gMilcbiAgICBzdWJ0cmFjdChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UubG93IDw9IHRoaXMubG93ICYmIHJhbmdlLmhpZ2ggPj0gdGhpcy5oaWdoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UubG93ID4gdGhpcy5sb3cgJiYgcmFuZ2UuaGlnaCA8IHRoaXMuaGlnaCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuZXcgU3ViUmFuZ2UodGhpcy5sb3csIHJhbmdlLmxvdyAtIDEpLFxuICAgICAgICAgICAgICAgIG5ldyBTdWJSYW5nZShyYW5nZS5oaWdoICsgMSwgdGhpcy5oaWdoKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5sb3cgPD0gdGhpcy5sb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFN1YlJhbmdlKHJhbmdlLmhpZ2ggKyAxLCB0aGlzLmhpZ2gpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFN1YlJhbmdlKHRoaXMubG93LCByYW5nZS5sb3cgLSAxKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG93ID09IHRoaXMuaGlnaCA/XG4gICAgICAgICAgICB0aGlzLmxvdy50b1N0cmluZygpIDogdGhpcy5sb3cgKyAnLScgKyB0aGlzLmhpZ2g7XG4gICAgfVxufVxuXG5cbmNsYXNzIERSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoYSwgYikge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHRoaXMuYWRkKGEsIGIpO1xuICAgIH1cblxuICAgIF91cGRhdGVfbGVuZ3RoKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMucmFuZ2VzLnJlZHVjZSgocHJldmlvdXMsIHJhbmdlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyByYW5nZS5sZW5ndGg7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGFkZChhLCBiKSB7XG4gICAgICAgIHZhciBfYWRkID0gKHN1YnJhbmdlKSA9PiB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmFuZ2VzLmxlbmd0aCAmJiAhc3VicmFuZ2UudG91Y2hlcyh0aGlzLnJhbmdlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3UmFuZ2VzID0gdGhpcy5yYW5nZXMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmFuZ2VzLmxlbmd0aCAmJiBzdWJyYW5nZS50b3VjaGVzKHRoaXMucmFuZ2VzW2ldKSkge1xuICAgICAgICAgICAgICAgIHN1YnJhbmdlID0gc3VicmFuZ2UuYWRkKHRoaXMucmFuZ2VzW2ldKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdSYW5nZXMucHVzaChzdWJyYW5nZSk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlcyA9IG5ld1Jhbmdlcy5jb25jYXQodGhpcy5yYW5nZXMuc2xpY2UoaSkpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlX2xlbmd0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBEUmFuZ2UpIHtcbiAgICAgICAgICAgIGEucmFuZ2VzLmZvckVhY2goX2FkZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYiA9PSBudWxsKSBiID0gYTtcbiAgICAgICAgICAgIF9hZGQobmV3IFN1YlJhbmdlKGEsIGIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWJ0cmFjdChhLCBiKSB7XG4gICAgICAgIHZhciBfc3VidHJhY3QgPSAoc3VicmFuZ2UpID0+IHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy5yYW5nZXMubGVuZ3RoICYmICFzdWJyYW5nZS5vdmVybGFwcyh0aGlzLnJhbmdlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3UmFuZ2VzID0gdGhpcy5yYW5nZXMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmFuZ2VzLmxlbmd0aCAmJiBzdWJyYW5nZS5vdmVybGFwcyh0aGlzLnJhbmdlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICBuZXdSYW5nZXMgPSBuZXdSYW5nZXMuY29uY2F0KHRoaXMucmFuZ2VzW2ldLnN1YnRyYWN0KHN1YnJhbmdlKSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yYW5nZXMgPSBuZXdSYW5nZXMuY29uY2F0KHRoaXMucmFuZ2VzLnNsaWNlKGkpKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZV9sZW5ndGgoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIERSYW5nZSkge1xuICAgICAgICAgICAgYS5yYW5nZXMuZm9yRWFjaChfc3VidHJhY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGIgPT0gbnVsbCkgYiA9IGE7XG4gICAgICAgICAgICBfc3VidHJhY3QobmV3IFN1YlJhbmdlKGEsIGIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnRlcnNlY3QoYSwgYikge1xuICAgICAgICB2YXIgbmV3UmFuZ2VzID0gW107XG4gICAgICAgIHZhciBfaW50ZXJzZWN0ID0gKHN1YnJhbmdlKSA9PiB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmFuZ2VzLmxlbmd0aCAmJiAhc3VicmFuZ2Uub3ZlcmxhcHModGhpcy5yYW5nZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJhbmdlcy5sZW5ndGggJiYgc3VicmFuZ2Uub3ZlcmxhcHModGhpcy5yYW5nZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvdyA9IE1hdGgubWF4KHRoaXMucmFuZ2VzW2ldLmxvdywgc3VicmFuZ2UubG93KTtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaCA9IE1hdGgubWluKHRoaXMucmFuZ2VzW2ldLmhpZ2gsIHN1YnJhbmdlLmhpZ2gpO1xuICAgICAgICAgICAgICAgIG5ld1Jhbmdlcy5wdXNoKG5ldyBTdWJSYW5nZShsb3csIGhpZ2gpKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBEUmFuZ2UpIHtcbiAgICAgICAgICAgIGEucmFuZ2VzLmZvckVhY2goX2ludGVyc2VjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYiA9PSBudWxsKSBiID0gYTtcbiAgICAgICAgICAgIF9pbnRlcnNlY3QobmV3IFN1YlJhbmdlKGEsIGIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhbmdlcyA9IG5ld1JhbmdlcztcbiAgICAgICAgdGhpcy5fdXBkYXRlX2xlbmd0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbmRleChpbmRleCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yYW5nZXMubGVuZ3RoICYmIHRoaXMucmFuZ2VzW2ldLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICAgICAgaW5kZXggLT0gdGhpcy5yYW5nZXNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1tpXS5sb3cgKyBpbmRleDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdbICcgKyB0aGlzLnJhbmdlcy5qb2luKCcsICcpICsgJyBdJztcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEUmFuZ2UodGhpcyk7XG4gICAgfVxuXG4gICAgbnVtYmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLnJlZHVjZSgocmVzdWx0LCBzdWJyYW5nZSkgPT4ge1xuICAgICAgICAgICAgdmFyIGkgPSBzdWJyYW5nZS5sb3c7XG4gICAgICAgICAgICB3aGlsZSAoaSA8PSBzdWJyYW5nZS5oaWdoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIHN1YnJhbmdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLm1hcCgoc3VicmFuZ2UpID0+ICh7XG4gICAgICAgICAgICBsb3c6IHN1YnJhbmdlLmxvdyxcbiAgICAgICAgICAgIGhpZ2g6IHN1YnJhbmdlLmhpZ2gsXG4gICAgICAgICAgICBsZW5ndGg6IDEgKyBzdWJyYW5nZS5oaWdoIC0gc3VicmFuZ2UubG93XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRFJhbmdlO1xuIiwiY29uc3QgcmV0ICAgID0gcmVxdWlyZSgncmV0Jyk7XG5jb25zdCBEUmFuZ2UgPSByZXF1aXJlKCdkcmFuZ2UnKTtcbmNvbnN0IHR5cGVzICA9IHJldC50eXBlcztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFJhbmRFeHAge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWdleHAsIG0pIHtcbiAgICB0aGlzLl9zZXREZWZhdWx0cyhyZWdleHApO1xuICAgIGlmIChyZWdleHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHRoaXMuaWdub3JlQ2FzZSA9IHJlZ2V4cC5pZ25vcmVDYXNlO1xuICAgICAgdGhpcy5tdWx0aWxpbmUgPSByZWdleHAubXVsdGlsaW5lO1xuICAgICAgcmVnZXhwID0gcmVnZXhwLnNvdXJjZTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlZ2V4cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaWdub3JlQ2FzZSA9IG0gJiYgbS5pbmRleE9mKCdpJykgIT09IC0xO1xuICAgICAgdGhpcy5tdWx0aWxpbmUgPSBtICYmIG0uaW5kZXhPZignbScpICE9PSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHJlZ2V4cCBvciBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICB0aGlzLnRva2VucyA9IHJldChyZWdleHApO1xuICB9XG5cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHNvbWUgY3VzdG9tIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldCBmb3IgdGhpcyByZWdleHAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmFuZEV4cH0gcmFuZGV4cFxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqL1xuICBfc2V0RGVmYXVsdHMocmVnZXhwKSB7XG4gICAgLy8gV2hlbiBhIHJlcGV0aXRpb25hbCB0b2tlbiBoYXMgaXRzIG1heCBzZXQgdG8gSW5maW5pdGUsXG4gICAgLy8gcmFuZGV4cCB3b24ndCBhY3R1YWxseSBnZW5lcmF0ZSBhIHJhbmRvbSBhbW91bnQgYmV0d2VlbiBtaW4gYW5kIEluZmluaXRlXG4gICAgLy8gaW5zdGVhZCBpdCB3aWxsIHNlZSBJbmZpbml0ZSBhcyBtaW4gKyAxMDAuXG4gICAgdGhpcy5tYXggPSByZWdleHAubWF4ICE9IG51bGwgPyByZWdleHAubWF4IDpcbiAgICAgIFJhbmRFeHAucHJvdG90eXBlLm1heCAhPSBudWxsID8gUmFuZEV4cC5wcm90b3R5cGUubWF4IDogMTAwO1xuXG4gICAgLy8gVGhpcyBhbGxvd3MgZXhwYW5kaW5nIHRvIGluY2x1ZGUgYWRkaXRpb25hbCBjaGFyYWN0ZXJzXG4gICAgLy8gZm9yIGluc3RhbmNlOiBSYW5kRXhwLmRlZmF1bHRSYW5nZS5hZGQoMCwgNjU1MzUpO1xuICAgIHRoaXMuZGVmYXVsdFJhbmdlID0gcmVnZXhwLmRlZmF1bHRSYW5nZSA/XG4gICAgICByZWdleHAuZGVmYXVsdFJhbmdlIDogdGhpcy5kZWZhdWx0UmFuZ2UuY2xvbmUoKTtcblxuICAgIGlmIChyZWdleHAucmFuZEludCkge1xuICAgICAgdGhpcy5yYW5kSW50ID0gcmVnZXhwLnJhbmRJbnQ7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSByYW5kb20gc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlbih0aGlzLnRva2VucywgW10pO1xuICB9XG5cblxuICAvKipcbiAgICogR2VuZXJhdGUgcmFuZG9tIHN0cmluZyBtb2RlbGVkIGFmdGVyIGdpdmVuIHRva2Vucy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGdyb3Vwc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBfZ2VuKHRva2VuLCBncm91cHMpIHtcbiAgICB2YXIgc3RhY2ssIHN0ciwgbiwgaSwgbDtcblxuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgY2FzZSB0eXBlcy5ST09UOlxuICAgICAgY2FzZSB0eXBlcy5HUk9VUDpcbiAgICAgICAgLy8gSWdub3JlIGxvb2thaGVhZHMgZm9yIG5vdy5cbiAgICAgICAgaWYgKHRva2VuLmZvbGxvd2VkQnkgfHwgdG9rZW4ubm90Rm9sbG93ZWRCeSkgeyByZXR1cm4gJyc7IH1cblxuICAgICAgICAvLyBJbnNlcnQgcGxhY2Vob2xkZXIgdW50aWwgZ3JvdXAgc3RyaW5nIGlzIGdlbmVyYXRlZC5cbiAgICAgICAgaWYgKHRva2VuLnJlbWVtYmVyICYmIHRva2VuLmdyb3VwTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0b2tlbi5ncm91cE51bWJlciA9IGdyb3Vwcy5wdXNoKG51bGwpIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YWNrID0gdG9rZW4ub3B0aW9ucyA/XG4gICAgICAgICAgdGhpcy5fcmFuZFNlbGVjdCh0b2tlbi5vcHRpb25zKSA6IHRva2VuLnN0YWNrO1xuXG4gICAgICAgIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gc3RhY2subGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgc3RyICs9IHRoaXMuX2dlbihzdGFja1tpXSwgZ3JvdXBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi5yZW1lbWJlcikge1xuICAgICAgICAgIGdyb3Vwc1t0b2tlbi5ncm91cE51bWJlcl0gPSBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcblxuICAgICAgY2FzZSB0eXBlcy5QT1NJVElPTjpcbiAgICAgICAgLy8gRG8gbm90aGluZyBmb3Igbm93LlxuICAgICAgICByZXR1cm4gJyc7XG5cbiAgICAgIGNhc2UgdHlwZXMuU0VUOlxuICAgICAgICB2YXIgZXhwYW5kZWRTZXQgPSB0aGlzLl9leHBhbmQodG9rZW4pO1xuICAgICAgICBpZiAoIWV4cGFuZGVkU2V0Lmxlbmd0aCkgeyByZXR1cm4gJyc7IH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5fcmFuZFNlbGVjdChleHBhbmRlZFNldCkpO1xuXG4gICAgICBjYXNlIHR5cGVzLlJFUEVUSVRJT046XG4gICAgICAgIC8vIFJhbmRvbWx5IGdlbmVyYXRlIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICAgICAgICBuID0gdGhpcy5yYW5kSW50KHRva2VuLm1pbixcbiAgICAgICAgICB0b2tlbi5tYXggPT09IEluZmluaXR5ID8gdG9rZW4ubWluICsgdGhpcy5tYXggOiB0b2tlbi5tYXgpO1xuXG4gICAgICAgIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgc3RyICs9IHRoaXMuX2dlbih0b2tlbi52YWx1ZSwgZ3JvdXBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG5cbiAgICAgIGNhc2UgdHlwZXMuUkVGRVJFTkNFOlxuICAgICAgICByZXR1cm4gZ3JvdXBzW3Rva2VuLnZhbHVlIC0gMV0gfHwgJyc7XG5cbiAgICAgIGNhc2UgdHlwZXMuQ0hBUjpcbiAgICAgICAgdmFyIGNvZGUgPSB0aGlzLmlnbm9yZUNhc2UgJiYgdGhpcy5fcmFuZEJvb2woKSA/XG4gICAgICAgICAgdGhpcy5fdG9PdGhlckNhc2UodG9rZW4udmFsdWUpIDogdG9rZW4udmFsdWU7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIElmIGNvZGUgaXMgYWxwaGFiZXRpYywgY29udmVydHMgdG8gb3RoZXIgY2FzZS5cbiAgICogSWYgbm90IGFscGhhYmV0aWMsIHJldHVybnMgYmFjayBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29kZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBfdG9PdGhlckNhc2UoY29kZSkge1xuICAgIHJldHVybiBjb2RlICsgKDk3IDw9IGNvZGUgJiYgY29kZSA8PSAxMjIgPyAtMzIgOlxuICAgICAgNjUgPD0gY29kZSAmJiBjb2RlIDw9IDkwICA/ICAzMiA6IDApO1xuICB9XG5cblxuICAvKipcbiAgICogUmFuZG9tbHkgcmV0dXJucyBhIHRydWUgb3IgZmFsc2UgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfcmFuZEJvb2woKSB7XG4gICAgcmV0dXJuICF0aGlzLnJhbmRJbnQoMCwgMSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSYW5kb21seSBzZWxlY3RzIGFuZCByZXR1cm5zIGEgdmFsdWUgZnJvbSB0aGUgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGFyclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfcmFuZFNlbGVjdChhcnIpIHtcbiAgICBpZiAoYXJyIGluc3RhbmNlb2YgRFJhbmdlKSB7XG4gICAgICByZXR1cm4gYXJyLmluZGV4KHRoaXMucmFuZEludCgwLCBhcnIubGVuZ3RoIC0gMSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyW3RoaXMucmFuZEludCgwLCBhcnIubGVuZ3RoIC0gMSldO1xuICB9XG5cblxuICAvKipcbiAgICogZXhwYW5kcyBhIHRva2VuIHRvIGEgRGlzY29udGludW91c1JhbmdlIG9mIGNoYXJhY3RlcnMgd2hpY2ggaGFzIGFcbiAgICogbGVuZ3RoIGFuZCBhbiBpbmRleCBmdW5jdGlvbiAoZm9yIHJhbmRvbSBzZWxlY3RpbmcpXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuICAgKiBAcmV0dXJuIHtEaXNjb250aW51b3VzUmFuZ2V9XG4gICAqL1xuICBfZXhwYW5kKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IHJldC50eXBlcy5DSEFSKSB7XG4gICAgICByZXR1cm4gbmV3IERSYW5nZSh0b2tlbi52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSByZXQudHlwZXMuUkFOR0UpIHtcbiAgICAgIHJldHVybiBuZXcgRFJhbmdlKHRva2VuLmZyb20sIHRva2VuLnRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRyYW5nZSA9IG5ldyBEUmFuZ2UoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW4uc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdWJyYW5nZSA9IHRoaXMuX2V4cGFuZCh0b2tlbi5zZXRbaV0pO1xuICAgICAgICBkcmFuZ2UuYWRkKHN1YnJhbmdlKTtcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlQ2FzZSkge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3VicmFuZ2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBjb2RlID0gc3VicmFuZ2UuaW5kZXgoaik7XG4gICAgICAgICAgICBsZXQgb3RoZXJDYXNlQ29kZSA9IHRoaXMuX3RvT3RoZXJDYXNlKGNvZGUpO1xuICAgICAgICAgICAgaWYgKGNvZGUgIT09IG90aGVyQ2FzZUNvZGUpIHtcbiAgICAgICAgICAgICAgZHJhbmdlLmFkZChvdGhlckNhc2VDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5ub3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJhbmdlLmNsb25lKCkuc3VidHJhY3QoZHJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSYW5nZS5jbG9uZSgpLmludGVyc2VjdChkcmFuZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJhbmRvbWx5IGdlbmVyYXRlcyBhbmQgcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIGEgYW5kIGIgKGluY2x1c2l2ZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHJhbmRJbnQoYSwgYikge1xuICAgIHJldHVybiBhICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDEgKyBiIC0gYSkpO1xuICB9XG5cblxuICAvKipcbiAgICogRGVmYXVsdCByYW5nZSBvZiBjaGFyYWN0ZXJzIHRvIGdlbmVyYXRlIGZyb20uXG4gICAqL1xuICBnZXQgZGVmYXVsdFJhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZSA9IHRoaXMuX3JhbmdlIHx8IG5ldyBEUmFuZ2UoMzIsIDEyNik7XG4gIH1cblxuICBzZXQgZGVmYXVsdFJhbmdlKHJhbmdlKSB7XG4gICAgdGhpcy5fcmFuZ2UgPSByYW5nZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqXG4gICAqIEVuYWJsZXMgdXNlIG9mIHJhbmRleHAgd2l0aCBhIHNob3J0ZXIgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfCByZWdleHB9XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyByYW5kZXhwKHJlZ2V4cCwgbSkge1xuICAgIHZhciByYW5kZXhwO1xuICAgIGlmKHR5cGVvZiByZWdleHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZWdleHAgPSBuZXcgUmVnRXhwKHJlZ2V4cCwgbSk7XG4gICAgfVxuXG4gICAgaWYgKHJlZ2V4cC5fcmFuZGV4cCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByYW5kZXhwID0gbmV3IFJhbmRFeHAocmVnZXhwLCBtKTtcbiAgICAgIHJlZ2V4cC5fcmFuZGV4cCA9IHJhbmRleHA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmRleHAgPSByZWdleHAuX3JhbmRleHA7XG4gICAgICByYW5kZXhwLl9zZXREZWZhdWx0cyhyZWdleHApO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZGV4cC5nZW4oKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgc3VnYXJ5IC9yZWdleHAvLmdlbiBzeW50YXguXG4gICAqL1xuICBzdGF0aWMgc3VnYXIoKSB7XG4gICAgLyogZXNoaW50IGZyZWV6ZTpmYWxzZSAqL1xuICAgIFJlZ0V4cC5wcm90b3R5cGUuZ2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUmFuZEV4cC5yYW5kZXhwKHRoaXMpO1xuICAgIH07XG4gIH1cbn07XG4iLCJpbXBvcnQgUmFuZEV4cCBmcm9tICdyYW5kZXhwJztcblxuaW1wb3J0IG9wdGlvbkFQSSBmcm9tICcuLi9hcGkvb3B0aW9uJztcbmltcG9ydCBlbnYgZnJvbSAnLi9jb25zdGFudHMnO1xuXG5mdW5jdGlvbiBnZXRSYW5kb21JbnRlZ2VyKG1pbiwgbWF4KSB7XG4gIG1pbiA9IHR5cGVvZiBtaW4gPT09ICd1bmRlZmluZWQnID8gZW52Lk1JTl9JTlRFR0VSIDogbWluO1xuICBtYXggPSB0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJyA/IGVudi5NQVhfSU5URUdFUiA6IG1heDtcblxuICByZXR1cm4gTWF0aC5mbG9vcihvcHRpb25BUEkoJ3JhbmRvbScpKCkgKiAoKG1heCAtIG1pbikgKyAxKSkgKyBtaW47XG59XG5cbmZ1bmN0aW9uIF9yYW5kZXhwKHZhbHVlKSB7XG4gIC8vIHNldCBtYXhpbXVtIGRlZmF1bHQsIHNlZSAjMTkzXG4gIFJhbmRFeHAucHJvdG90eXBlLm1heCA9IG9wdGlvbkFQSSgnZGVmYXVsdFJhbmRFeHBNYXgnKTtcblxuICAvLyBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHRoZSBvcmlnaW5hbCBleGNlcHQgdXNpbmcgb3VyIHJhbmRvbVxuICBSYW5kRXhwLnByb3RvdHlwZS5yYW5kSW50ID0gKGEsIGIpID0+IGEgKyBNYXRoLmZsb29yKG9wdGlvbkFQSSgncmFuZG9tJykoKSAqICgxICsgKGIgLSBhKSkpO1xuXG4gIGNvbnN0IHJlID0gbmV3IFJhbmRFeHAodmFsdWUpO1xuXG4gIHJldHVybiByZS5nZW4oKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHJhbmRvbSBlbGVtZW50IG9mIGEgY29sbGVjdGlvblxuICpcbiAqIEBwYXJhbSBjb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZnVuY3Rpb24gcGljayhjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBjb2xsZWN0aW9uW01hdGguZmxvb3Iob3B0aW9uQVBJKCdyYW5kb20nKSgpICogY29sbGVjdGlvbi5sZW5ndGgpXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHNodWZmbGVkIGNvbGxlY3Rpb24gb2YgZWxlbWVudHNcbiAqXG4gKiBAcGFyYW0gY29sbGVjdGlvblxuICogQHJldHVybnMge1RbXX1cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIGxldCB0bXA7XG4gIGxldCBrZXk7XG4gIGxldCBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICBjb25zdCBjb3B5ID0gY29sbGVjdGlvbi5zbGljZSgpO1xuXG4gIGZvciAoOyBsZW5ndGggPiAwOykge1xuICAgIGtleSA9IE1hdGguZmxvb3Iob3B0aW9uQVBJKCdyYW5kb20nKSgpICogbGVuZ3RoKTtcbiAgICAvLyBzd2FwXG4gICAgbGVuZ3RoIC09IDE7XG4gICAgdG1wID0gY29weVtsZW5ndGhdO1xuICAgIGNvcHlbbGVuZ3RoXSA9IGNvcHlba2V5XTtcbiAgICBjb3B5W2tleV0gPSB0bXA7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChpbmNsdXNpdmUpXG4gKiBVc2luZyBNYXRoLnJvdW5kKCkgd2lsbCBnaXZlIHlvdSBhIG5vbi11bmlmb3JtIGRpc3RyaWJ1dGlvbiFcbiAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTUyNzgyMC83NjkzODRcbiAqL1xuZnVuY3Rpb24gZ2V0UmFuZG9tKG1pbiwgbWF4KSB7XG4gIHJldHVybiAob3B0aW9uQVBJKCdyYW5kb20nKSgpICogKG1heCAtIG1pbikpICsgbWluO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb20gbnVtYmVyIGFjY29yZGluZyB0byBwYXJhbWV0ZXJzIHBhc3NlZFxuICpcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqIEBwYXJhbSBkZWZNaW5cbiAqIEBwYXJhbSBkZWZNYXhcbiAqIEBwYXJhbSBoYXNQcmVjaXNpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG51bWJlcihtaW4sIG1heCwgZGVmTWluLCBkZWZNYXgsIGhhc1ByZWNpc2lvbiA9IGZhbHNlKSB7XG4gIGRlZk1pbiA9IHR5cGVvZiBkZWZNaW4gPT09ICd1bmRlZmluZWQnID8gZW52Lk1JTl9OVU1CRVIgOiBkZWZNaW47XG4gIGRlZk1heCA9IHR5cGVvZiBkZWZNYXggPT09ICd1bmRlZmluZWQnID8gZW52Lk1BWF9OVU1CRVIgOiBkZWZNYXg7XG5cbiAgbWluID0gdHlwZW9mIG1pbiA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZNaW4gOiBtaW47XG4gIG1heCA9IHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnID8gZGVmTWF4IDogbWF4O1xuXG4gIGlmIChtYXggPCBtaW4pIHtcbiAgICBtYXggKz0gbWluO1xuICB9XG5cbiAgaWYgKGhhc1ByZWNpc2lvbikge1xuICAgIHJldHVybiBnZXRSYW5kb20obWluLCBtYXgpO1xuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbUludGVnZXIobWluLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBieSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgcmV0dXJuIG51bWJlcigwLCA2MCkgKiA2MDtcblxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgcmV0dXJuIG51bWJlcigxNSwgNTApICogNjEyO1xuXG4gICAgY2FzZSAnaG91cnMnOlxuICAgICAgcmV0dXJuIG51bWJlcigxMiwgNzIpICogMzYxMjM7XG5cbiAgICBjYXNlICdkYXlzJzpcbiAgICAgIHJldHVybiBudW1iZXIoNywgMzApICogODY0MTIzNDU7XG5cbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgICByZXR1cm4gbnVtYmVyKDQsIDUyKSAqIDYwNDgxMjM0NTtcblxuICAgIGNhc2UgJ21vbnRocyc6XG4gICAgICByZXR1cm4gbnVtYmVyKDIsIDEzKSAqIDI1OTIwMTIzNDU7XG5cbiAgICBjYXNlICd5ZWFycyc6XG4gICAgICByZXR1cm4gbnVtYmVyKDEsIDIwKSAqIDMxMTA0MDEyMzQ1O1xuXG4gICAgZGVmYXVsdDogYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0ZShzdGVwKSB7XG4gIGlmIChzdGVwKSB7XG4gICAgcmV0dXJuIGJ5KHN0ZXApO1xuICB9XG5cbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgZGF5cyA9IG51bWJlcigtMTAwMCwgZW52Lk1PU1RfTkVBUl9EQVRFVElNRSk7XG5cbiAgbm93LnNldFRpbWUobm93LmdldFRpbWUoKSAtIGRheXMpO1xuXG4gIHJldHVybiBub3c7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcGljayxcbiAgZGF0ZSxcbiAgc2h1ZmZsZSxcbiAgbnVtYmVyLFxuICByYW5kZXhwOiBfcmFuZGV4cCxcbn07XG4iLCJpbXBvcnQgb3B0aW9uQVBJIGZyb20gJy4uL2FwaS9vcHRpb24nO1xuaW1wb3J0IGVudiBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgcmFuZG9tIGZyb20gJy4vcmFuZG9tJztcblxuZnVuY3Rpb24gZ2V0TG9jYWxSZWYob2JqLCBwYXRoLCByZWZzKSB7XG4gIGlmIChyZWZzICYmIHJlZnNbcGF0aF0pIHJldHVybiBjbG9uZShyZWZzW3BhdGhdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGNvbnN0IGtleUVsZW1lbnRzID0gcGF0aC5yZXBsYWNlKCcjLycsICcvJykuc3BsaXQoJy8nKTtcblxuICBsZXQgc2NoZW1hID0gb2JqLiRyZWYgJiYgcmVmcyA/IHJlZnNbb2JqLiRyZWZdIDogb2JqO1xuICBpZiAocmVmcyAmJiBwYXRoLmluY2x1ZGVzKCcjLycpICYmIHJlZnNba2V5RWxlbWVudHNbMF1dKSB7XG4gICAgc2NoZW1hID0gcmVmc1trZXlFbGVtZW50cy5zaGlmdCgpXTtcbiAgfVxuXG4gIGlmICgha2V5RWxlbWVudHNbMF0pIGtleUVsZW1lbnRzLnNoaWZ0KCk7XG5cbiAgd2hpbGUgKHNjaGVtYSAmJiBrZXlFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcHJvcCA9IGtleUVsZW1lbnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoIXNjaGVtYVtwcm9wXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9wIG5vdCBmb3VuZDogJHtwcm9wfSAoJHtwYXRofSlgKTtcbiAgICB9XG5cbiAgICBzY2hlbWEgPSBzY2hlbWFbcHJvcF07XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUvZmFsc2Ugd2hldGhlciB0aGUgb2JqZWN0IHBhcmFtZXRlciBoYXMgaXRzIG93biBwcm9wZXJ0aWVzIGRlZmluZWRcbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gcHJvcGVydGllc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc1Byb3BlcnRpZXMob2JqLCAuLi5wcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmZpbHRlcihrZXkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqW2tleV0gIT09ICd1bmRlZmluZWQnO1xuICB9KS5sZW5ndGggPiAwO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBnZW5lcmF0ZWQgZGF0ZSBZWVlZLU1NLUREIHRvIG5vdCBoYXZlXG4gKiBvdXQgb2YgcmFuZ2UgdmFsdWVzXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjbGFtcERhdGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmluY2x1ZGVzKCcgJykpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDAsIDEwKTtcbiAgfVxuXG4gIGxldCBbeWVhciwgbW9udGgsIGRheV0gPSB2YWx1ZS5zcGxpdCgnVCcpWzBdLnNwbGl0KCctJyk7XG5cbiAgbW9udGggPSBNYXRoLm1heCgxLCBNYXRoLm1pbigxMiwgbW9udGgpKTtcbiAgZGF5ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oMzEsIGRheSkpO1xuXG4gIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1gO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHlwZWNhc3RlZCB2YWx1ZS5cbiAqIEV4dGVybmFsIGdlbmVyYXRvcnMgKGZha2VyLCBjaGFuY2UsIGNhc3VhbCkgbWF5IHJldHVybiBkYXRhIGluIG5vbi1leHBlY3RlZCBmb3JtYXRzLCBzdWNoIGFzIHN0cmluZywgd2hlbiB5b3UgbWlnaHQgZXhwZWN0IGFuXG4gKiBpbnRlZ2VyLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZm9yY2UgdGhlIHR5cGVjYXN0LiBUaGlzIGlzIHRoZSBiYXNlIGZvcm1hdHRlciBmb3IgYWxsIHJlc3VsdCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gdHlwZWNhc3QodHlwZSwgc2NoZW1hLCBjYWxsYmFjaykge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAvLyBub3JtYWxpemUgY29uc3RyYWludHNcbiAgc3dpdGNoICh0eXBlIHx8IHNjaGVtYS50eXBlKSB7XG4gICAgY2FzZSAnaW50ZWdlcic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1pbmltdW0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmFtcy5taW5pbXVtID0gc2NoZW1hLm1pbmltdW07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heGltdW0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmFtcy5tYXhpbXVtID0gc2NoZW1hLm1heGltdW07XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2hlbWEuZW51bSkge1xuICAgICAgICBsZXQgbWluID0gTWF0aC5tYXgocGFyYW1zLm1pbmltdW0gfHwgMCwgMCk7XG4gICAgICAgIGxldCBtYXggPSBNYXRoLm1pbihwYXJhbXMubWF4aW11bSB8fCBJbmZpbml0eSwgSW5maW5pdHkpO1xuXG4gICAgICAgIGlmIChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSAmJiBtaW4gPT09IHNjaGVtYS5taW5pbXVtKSB7XG4gICAgICAgICAgbWluICs9IHNjaGVtYS5tdWx0aXBsZU9mIHx8IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gJiYgbWF4ID09PSBzY2hlbWEubWF4aW11bSkge1xuICAgICAgICAgIG1heCAtPSBzY2hlbWEubXVsdGlwbGVPZiB8fCAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlzY2FyZCBvdXQtb2YtYm91bmRzIGVudW1lcmF0aW9uc1xuICAgICAgICBpZiAobWluIHx8IG1heCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBzY2hlbWEuZW51bSA9IHNjaGVtYS5lbnVtLmZpbHRlcih4ID0+IHtcbiAgICAgICAgICAgIGlmICh4ID49IG1pbiAmJiB4IDw9IG1heCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgcGFyYW1zLm1pbkxlbmd0aCA9IG9wdGlvbkFQSSgnbWluTGVuZ3RoJykgfHwgMDtcbiAgICAgIHBhcmFtcy5tYXhMZW5ndGggPSBvcHRpb25BUEkoJ21heExlbmd0aCcpIHx8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5MZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmFtcy5taW5MZW5ndGggPSBNYXRoLm1heChwYXJhbXMubWluTGVuZ3RoLCBzY2hlbWEubWluTGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4TGVuZ3RoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJhbXMubWF4TGVuZ3RoID0gTWF0aC5taW4ocGFyYW1zLm1heExlbmd0aCwgc2NoZW1hLm1heExlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICB9XG5cbiAgLy8gZXhlY3V0ZSBnZW5lcmF0b3JcbiAgbGV0IHZhbHVlID0gY2FsbGJhY2socGFyYW1zKTtcblxuICAvLyBhbGxvdyBudWxsIHZhbHVlcyB0byBiZSByZXR1cm5lZFxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIG91dHB1dCB2YWx1ZVxuICBzd2l0Y2ggKHR5cGUgfHwgc2NoZW1hLnR5cGUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgdmFsdWUgPSAhIXZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG5cbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWF4KHBhcmFtcy5taW5MZW5ndGggfHwgMCwgMCk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1pbihwYXJhbXMubWF4TGVuZ3RoIHx8IEluZmluaXR5LCBJbmZpbml0eSk7XG5cbiAgICAgIGxldCBwcmV2O1xuICAgICAgbGV0IG5vQ2hhbmdlQ291bnQgPSAwO1xuXG4gICAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHByZXYgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoIXNjaGVtYS5wYXR0ZXJuKSB7XG4gICAgICAgICAgdmFsdWUgKz0gYCR7cmFuZG9tLnBpY2soWycgJywgJy8nLCAnXycsICctJywgJysnLCAnPScsICdAJywgJ14nXSl9JHt2YWx1ZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICs9IHJhbmRvbS5yYW5kZXhwKHNjaGVtYS5wYXR0ZXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF2b2lkIGluZmluaXRlLWxvb3BzIHdoaWxlIGZpbGxpbmcgc3RyaW5ncywgaWYgbm8gY2hhbmdlc1xuICAgICAgICAvLyBhcmUgbWFkZSB3ZSBqdXN0IGJyZWFrIHRoZSBsb29wLi4uIHNlZSAjNTQwXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gcHJldikge1xuICAgICAgICAgIG5vQ2hhbmdlQ291bnQgKz0gMTtcbiAgICAgICAgICBpZiAobm9DaGFuZ2VDb3VudCA9PT0gMykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vQ2hhbmdlQ291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBtYXgpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgbWF4KTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChzY2hlbWEuZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ2RhdGUtdGltZSc6XG4gICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKGNsYW1wRGF0ZSh2YWx1ZSkpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvKFswLTldKTArWiQvLCAnJDFaJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZnVsbC1kYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShjbGFtcERhdGUodmFsdWUpKS50b0lTT1N0cmluZygpLnN1YnN0cigwLCAxMCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShgMTk2OS0wMS0wMSAke3ZhbHVlfWApLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDExKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDogYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgT2JqZWN0LmtleXMoYikuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2YgYltrZXldICE9PSAnb2JqZWN0JyB8fCBiW2tleV0gPT09IG51bGwpIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltrZXldKSkge1xuICAgICAgYVtrZXldID0gYVtrZXldIHx8IFtdO1xuICAgICAgLy8gZml4ICMyOTIgLSBza2lwIGR1cGxpY2F0ZWQgdmFsdWVzIGZyb20gbWVyZ2Ugb2JqZWN0IChiKVxuICAgICAgYltrZXldLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhW2tleV0pICYmIGFba2V5XS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICBhW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFba2V5XSAhPT0gJ29iamVjdCcgfHwgYVtrZXldID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoYVtrZXldKSkge1xuICAgICAgYVtrZXldID0gbWVyZ2Uoe30sIGJba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IG1lcmdlKGFba2V5XSwgYltrZXldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjbG9uZShvYmosIGNhY2hlID0gbmV3IE1hcCgpKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChjYWNoZS5oYXMob2JqKSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBjYWNoZS5zZXQob2JqLCBhcnIpO1xuXG4gICAgYXJyLnB1c2goLi4ub2JqLm1hcCh4ID0+IGNsb25lKHgsIGNhY2hlKSkpO1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICBjb25zdCBjbG9uZWRPYmogPSB7fTtcbiAgY2FjaGUuc2V0KG9iaiwgY2xvbmVkT2JqKTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKHByZXYsIGN1cikgPT4ge1xuICAgIHByZXZbY3VyXSA9IGNsb25lKG9ialtjdXJdLCBjYWNoZSk7XG4gICAgcmV0dXJuIHByZXY7XG4gIH0sIGNsb25lZE9iaik7XG59XG5cbmZ1bmN0aW9uIHNob3J0KHNjaGVtYSkge1xuICBjb25zdCBzID0gSlNPTi5zdHJpbmdpZnkoc2NoZW1hKTtcbiAgY29uc3QgbCA9IEpTT04uc3RyaW5naWZ5KHNjaGVtYSwgbnVsbCwgMik7XG5cbiAgcmV0dXJuIHMubGVuZ3RoID4gNDAwID8gYCR7bC5zdWJzdHIoMCwgNDAwKX0uLi5gIDogbDtcbn1cblxuZnVuY3Rpb24gYW55VmFsdWUoKSB7XG4gIHJldHVybiByYW5kb20ucGljayhbXG4gICAgZmFsc2UsXG4gICAgdHJ1ZSxcbiAgICBudWxsLFxuICAgIC0xLFxuICAgIE5hTixcbiAgICBNYXRoLlBJLFxuICAgIEluZmluaXR5LFxuICAgIHVuZGVmaW5lZCxcbiAgICBbXSxcbiAgICB7fSxcbiAgICAvLyBGSVhNRTogdXNlIGJ1aWx0LWluIHJhbmRvbT9cbiAgICBNYXRoLnJhbmRvbSgpLFxuICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKSxcbiAgXSk7XG59XG5cbmZ1bmN0aW9uIG5vdFZhbHVlKHNjaGVtYSwgcGFyZW50KSB7XG4gIGNvbnN0IGNvcHkgPSBtZXJnZSh7fSwgcGFyZW50KTtcblxuICBpZiAodHlwZW9mIHNjaGVtYS5taW5pbXVtICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvcHkubWF4aW11bSA9IHNjaGVtYS5taW5pbXVtO1xuICAgIGNvcHkuZXhjbHVzaXZlTWF4aW11bSA9IHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHNjaGVtYS5tYXhpbXVtICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvcHkubWluaW11bSA9IHNjaGVtYS5tYXhpbXVtID4gY29weS5tYXhpbXVtID8gMCA6IHNjaGVtYS5tYXhpbXVtO1xuICAgIGNvcHkuZXhjbHVzaXZlTWluaW11bSA9IHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHNjaGVtYS5taW5MZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29weS5tYXhMZW5ndGggPSBzY2hlbWEubWluTGVuZ3RoO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEubWF4TGVuZ3RoICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvcHkubWluTGVuZ3RoID0gc2NoZW1hLm1heExlbmd0aCA+IGNvcHkubWF4TGVuZ3RoID8gMCA6IHNjaGVtYS5tYXhMZW5ndGg7XG4gIH1cblxuICBpZiAoc2NoZW1hLnR5cGUpIHtcbiAgICBjb3B5LnR5cGUgPSByYW5kb20ucGljayhlbnYuU0NBTEFSX1RZUEVTLmZpbHRlcih4ID0+IHtcbiAgICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkgPyBzY2hlbWEudHlwZSA6IFtzY2hlbWEudHlwZV07XG5cbiAgICAgIHJldHVybiB0eXBlcy5ldmVyeSh0eXBlID0+IHtcbiAgICAgICAgLy8gdHJlYXQgYm90aCB0eXBlcyBhcyBfc2ltaWxhciBlbm91Z2hfIHRvIGJlIHNraXBwZWQgZXF1YWxcbiAgICAgICAgaWYgKHggPT09ICdudW1iZXInIHx8IHggPT09ICdpbnRlZ2VyJykge1xuICAgICAgICAgIHJldHVybiB0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnaW50ZWdlcic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geCAhPT0gdHlwZTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfSBlbHNlIGlmIChzY2hlbWEuZW51bSkge1xuICAgIGxldCB2YWx1ZTtcblxuICAgIGRvIHtcbiAgICAgIHZhbHVlID0gYW55VmFsdWUoKTtcbiAgICB9IHdoaWxlIChzY2hlbWEuZW51bS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpO1xuXG4gICAgY29weS5lbnVtID0gW3ZhbHVlXTtcbiAgfVxuXG4gIGlmIChzY2hlbWEucmVxdWlyZWQgJiYgY29weS5wcm9wZXJ0aWVzKSB7XG4gICAgc2NoZW1hLnJlcXVpcmVkLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBkZWxldGUgY29weS5wcm9wZXJ0aWVzW3Byb3BdO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVE9ETzogZXhwbG9yZSBtb3JlIHNjZW5hcmlvc1xuXG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlRm9yU2NoZW1hKHZhbHVlLCBzY2hlbWEpIHtcbiAgY29uc3Qgc2NoZW1hSGFzTWluID0gc2NoZW1hLm1pbmltdW0gIT09IHVuZGVmaW5lZDtcbiAgY29uc3Qgc2NoZW1hSGFzTWF4ID0gc2NoZW1hLm1heGltdW0gIT09IHVuZGVmaW5lZDtcblxuICByZXR1cm4gKFxuICAgIChzY2hlbWFIYXNNaW4gfHwgc2NoZW1hSGFzTWF4KVxuICAgICYmICghc2NoZW1hSGFzTWluIHx8IHZhbHVlID49IHNjaGVtYS5taW5pbXVtKVxuICAgICYmICghc2NoZW1hSGFzTWF4IHx8IHZhbHVlIDw9IHNjaGVtYS5tYXhpbXVtKVxuICApO1xufVxuXG4vLyBGSVhNRTogZXZhbHVhdGUgbW9yZSBjb25zdHJhaW50cz9cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzY2hlbWFzKSB7XG4gIHJldHVybiAhc2NoZW1hcy5ldmVyeShzY2hlbWEgPT4gdmFsaWRhdGVWYWx1ZUZvclNjaGVtYSh2YWx1ZSwgc2NoZW1hKSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVmFsdWVGb3JPbmVPZih2YWx1ZSwgb25lT2YpIHtcbiAgY29uc3QgdmFsaWRDb3VudCA9IG9uZU9mLnJlZHVjZSgoY291bnQsIHNjaGVtYSkgPT4gKGNvdW50ICsgKCh2YWxpZGF0ZVZhbHVlRm9yU2NoZW1hKHZhbHVlLCBzY2hlbWEpKSA/IDEgOiAwKSksIDApO1xuICByZXR1cm4gdmFsaWRDb3VudCA9PT0gMTtcbn1cblxuZnVuY3Rpb24gaXNLZXkocHJvcCkge1xuICByZXR1cm4gWydlbnVtJywgJ2NvbnN0JywgJ2RlZmF1bHQnLCAnZXhhbXBsZXMnLCAncmVxdWlyZWQnLCAnZGVmaW5pdGlvbnMnLCAnaXRlbXMnLCAncHJvcGVydGllcyddLmluY2x1ZGVzKHByb3ApO1xufVxuXG5mdW5jdGlvbiBvbWl0UHJvcHMob2JqLCBwcm9wcykge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIC5maWx0ZXIoa2V5ID0+ICFwcm9wcy5pbmNsdWRlcyhrZXkpKVxuICAgIC5yZWR1Y2UoKGNvcHksIGspID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgY29weVtrXSA9IG9ialtrXS5zbGljZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weVtrXSA9IG9ialtrXSBpbnN0YW5jZW9mIE9iamVjdFxuICAgICAgICAgID8gbWVyZ2Uoe30sIG9ialtrXSlcbiAgICAgICAgICA6IG9ialtrXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfSwge30pO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZSh2YWx1ZSwgc2NoZW1hKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoeCA9PiB0ZW1wbGF0ZSh4LCBzY2hlbWEpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8jXFx7KFtcXHcuLV0rKVxcfS9nLCAoXywgJDEpID0+IHNjaGVtYVskMV0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBnaXZlbiBvYmplY3QgaXMgZW1wdHkgKGhhcyBubyBwcm9wZXJ0aWVzKVxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBnaXZlbiBrZXkgaXMgcmVxdWlyZWQgb3IgaWYgc291cmNlIG9iamVjdCB3YXMgY3JlYXRlZCBieSBhIHN1YnJvdXRpbmUgKGFscmVhZHkgY2xlYW5lZClcbiAqXG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQ2xlYW4oa2V5LCBzY2hlbWEpIHtcbiAgY29uc3QgaXNSZXF1aXJlZCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSAmJiBzY2hlbWEucmVxdWlyZWQuaW5jbHVkZXMoa2V5KTtcbiAgY29uc3Qgd2FzQ2xlYW5lZCA9IHR5cGVvZiBzY2hlbWEudGh1bmsgPT09ICdmdW5jdGlvbicgfHwgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAmJiB0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLnRodW5rID09PSAnZnVuY3Rpb24nKTtcblxuICByZXR1cm4gIWlzUmVxdWlyZWQgJiYgIXdhc0NsZWFuZWQ7XG59XG5cbi8qKlxuICogQ2xlYW5zIHVwIHRoZSBzb3VyY2Ugb2JqZWN0IHJlbW92aW5nIGVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAqIFdpbGwgbm90IHJlbW92ZSB2YWx1ZXMgd2hpY2ggYXJlIHNwZWNpZmllZCBhcyBgcmVxdWlyZWRgXG4gKlxuICogQHBhcmFtIG9ialxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIGlzQXJyYXlcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuKG9iaiwgc2NoZW1hLCBpc0FycmF5ID0gZmFsc2UpIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmpcbiAgICAgIC5tYXAodmFsdWUgPT4gY2xlYW4odmFsdWUsIHNjaGVtYSwgdHJ1ZSkpXG4gICAgICAuZmlsdGVyKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpO1xuICB9XG5cbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGsgPT4ge1xuICAgIGlmIChpc0VtcHR5KG9ialtrXSkpIHtcbiAgICAgIGlmIChzaG91bGRDbGVhbihrLCBzY2hlbWEpKSB7XG4gICAgICAgIGRlbGV0ZSBvYmpba107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY2xlYW4ob2JqW2tdLCBzY2hlbWEpO1xuXG4gICAgICBpZiAoIWlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgIG9ialtrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9ialtrXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlbGV0ZSBvYmpba107XG4gICAgfVxuICB9KTtcblxuICBpZiAoIU9iamVjdC5rZXlzKG9iaikubGVuZ3RoICYmIGlzQXJyYXkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBoYXNQcm9wZXJ0aWVzLFxuICBnZXRMb2NhbFJlZixcbiAgb21pdFByb3BzLFxuICB0eXBlY2FzdCxcbiAgbWVyZ2UsXG4gIGNsb25lLFxuICBzaG9ydCxcbiAgbm90VmFsdWUsXG4gIGFueVZhbHVlLFxuICB2YWxpZGF0ZSxcbiAgdmFsaWRhdGVWYWx1ZUZvclNjaGVtYSxcbiAgdmFsaWRhdGVWYWx1ZUZvck9uZU9mLFxuICBpc0tleSxcbiAgdGVtcGxhdGUsXG4gIHNob3VsZENsZWFuLFxuICBjbGVhbixcbiAgaXNFbXB0eSxcbiAgY2xhbXBEYXRlLFxufTtcbiIsImltcG9ydCB1dGlsIGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuXG4vLyBkeW5hbWljIHByb3h5IGZvciBjdXN0b20gZ2VuZXJhdG9yc1xuZnVuY3Rpb24gcHJveHkoZ2VuKSB7XG4gIHJldHVybiAodmFsdWUsIHNjaGVtYSwgcHJvcGVydHksIHJvb3RTY2hlbWEpID0+IHtcbiAgICBsZXQgZm4gPSB2YWx1ZTtcbiAgICBsZXQgYXJncyA9IFtdO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgbmVzdGVkIG9iamVjdCwgZmlyc3Qta2V5IGlzIHRoZSBnZW5lcmF0b3JcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgZm4gPSBPYmplY3Qua2V5cyh2YWx1ZSlbMF07XG5cbiAgICAgIC8vIHRyZWF0IHRoZSBnaXZlbiBhcnJheSBhcyBhcmd1bWVudHMsXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVtmbl0pKSB7XG4gICAgICAgIC8vIGlmIHRoZSBnZW5lcmF0b3IgaXMgZXhwZWN0aW5nIGFycmF5cyB0aGV5IHNob3VsZCBiZSBuZXN0ZWQsIGUuZy4gYFtbMSwgMiwgM10sIHRydWUsIC4uLl1gXG4gICAgICAgIGFyZ3MgPSB2YWx1ZVtmbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzLnB1c2godmFsdWVbZm5dKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0IGZvciBrZXlwYXRocywgZS5nLiBcImludGVybmV0LmVtYWlsXCJcbiAgICBjb25zdCBwcm9wcyA9IGZuLnNwbGl0KCcuJyk7XG5cbiAgICAvLyByZXRyaWV2ZSBhIGZyZXNoIGRlcGVuZGVuY3lcbiAgICBsZXQgY3R4ID0gZ2VuKCk7XG5cbiAgICB3aGlsZSAocHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgY3R4ID0gY3R4W3Byb3BzLnNoaWZ0KCldO1xuICAgIH1cblxuICAgIC8vIHJldHJpZXZlIGxhc3QgdmFsdWUgZnJvbSBjb250ZXh0IG9iamVjdFxuICAgIHZhbHVlID0gdHlwZW9mIGN0eCA9PT0gJ29iamVjdCcgPyBjdHhbcHJvcHNbMF1dIDogY3R4O1xuXG4gICAgLy8gaW52b2tlIGR5bmFtaWMgZ2VuZXJhdG9yc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkoY3R4LCBhcmdzLm1hcCh4ID0+IHV0aWwudGVtcGxhdGUoeCwgcm9vdFNjaGVtYSkpKTtcbiAgICB9XG5cbiAgICAvLyB0ZXN0IGZvciBwZW5kaW5nIGNhbGxiYWNrc1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVzb2x2ZSB2YWx1ZSBmb3IgJyR7cHJvcGVydHl9OiAke2ZufScsIGdpdmVuOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogQ29udGFpbmVyIGlzIHVzZWQgdG8gd3JhcCBleHRlcm5hbCBnZW5lcmF0b3JzIChmYWtlciwgY2hhbmNlLCBjYXN1YWwsIGV0Yy4pIGFuZCBpdHMgZGVwZW5kZW5jaWVzLlxuICpcbiAqIC0gYGpzZi5leHRlbmQoJ2Zha2VyJylgIHdpbGwgZW5oYW5jZSBvciBkZWZpbmUgdGhlIGdpdmVuIGRlcGVuZGVuY3kuXG4gKiAtIGBqc2YuZGVmaW5lKCdmYWtlcicpYCB3aWxsIHByb3ZpZGUgdGhlIFwiZmFrZXJcIiBrZXl3b3JkIHN1cHBvcnQuXG4gKlxuICogUmFuZEV4cCBpcyBub3QgbG9uZ2VyIGNvbnNpZGVyZWQgYW4gXCJleHRlbnNpb25cIi5cbiAqL1xuY2xhc3MgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gZHluYW1pYyByZXF1aXJlcyAtIGhhbmRsZSBhbGwgZGVwZW5kZW5jaWVzXG4gICAgLy8gdGhleSB3aWxsIE5PVCBiZSBpbmNsdWRlZCBvbiB0aGUgYnVuZGxlXG4gICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMuc3VwcG9ydCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0gbmFtZVxuICAgKi9cbiAgcmVzZXQobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgICAgdGhpcy5zdXBwb3J0ID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5W25hbWVdO1xuICAgICAgZGVsZXRlIHRoaXMuc3VwcG9ydFtuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgZGVwZW5kZW5jeSBnaXZlbiBieSBuYW1lXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXh0ZW5kKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZWdpc3RyeVtuYW1lXSA9IGNhbGxiYWNrKHRoaXMucmVnaXN0cnlbbmFtZV0pO1xuXG4gICAgLy8gYnVpbHQtaW4gcHJveHkgKGNhbiBiZSBvdmVycmlkZGVuKVxuICAgIGlmICghdGhpcy5zdXBwb3J0W25hbWVdKSB7XG4gICAgICB0aGlzLnN1cHBvcnRbbmFtZV0gPSBwcm94eSgoKSA9PiB0aGlzLnJlZ2lzdHJ5W25hbWVdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGtleXdvcmQgc3VwcG9ydCBieSBuYW1lXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZGVmaW5lKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zdXBwb3J0W25hbWVdID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBkZXBlbmRlbmN5IGdpdmVuIGJ5IG5hbWVcbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHJldHVybnMge0RlcGVuZGVuY3l9XG4gICAqL1xuICBnZXQobmFtZSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5yZWdpc3RyeVtuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihgJyR7bmFtZX0nIGRlcGVuZGVuY3kgZG9lc24ndCBleGlzdC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnlbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgYSBjdXN0b20ga2V5d29yZFxuICAgKiBAcGFyYW0gc2NoZW1hXG4gICAqL1xuICB3cmFwKHNjaGVtYSkge1xuICAgIGlmICghKCdnZW5lcmF0ZScgaW4gc2NoZW1hKSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge307XG5cbiAgICAgIGxldCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgY29uc3QgZm4gPSBrZXlzW2xlbmd0aF0ucmVwbGFjZSgvXngtLywgJycpO1xuICAgICAgICBjb25zdCBnZW4gPSB0aGlzLnN1cHBvcnRbZm5dO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZ2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjaGVtYSwgJ2dlbmVyYXRlJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IChyb290U2NoZW1hLCBrZXkpID0+IGdlbi5jYWxsKGNvbnRleHQsIHNjaGVtYVtrZXlzW2xlbmd0aF1dLCBzY2hlbWEsIGtleXNbbGVuZ3RoXSwgcm9vdFNjaGVtYSwga2V5LnNsaWNlKCkpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XG4iLCJpbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi4vY2xhc3MvUmVnaXN0cnknO1xuXG4vLyBpbnN0YW50aWF0ZVxuY29uc3QgcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcblxuLyoqXG4gKiBDdXN0b20gZm9ybWF0IEFQSVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pzb24tc2NoZW1hLWZha2VyL2pzb24tc2NoZW1hLWZha2VyI2N1c3RvbS1mb3JtYXRzXG4gKiBAcGFyYW0gbmFtZU9yRm9ybWF0TWFwXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEFQSShuYW1lT3JGb3JtYXRNYXAsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yRm9ybWF0TWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiByZWdpc3RyeS5saXN0KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIG5hbWVPckZvcm1hdE1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZWdpc3RyeS5yZWdpc3RlcihuYW1lT3JGb3JtYXRNYXAsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSBmYWxzZSkge1xuICAgICAgcmVnaXN0cnkudW5yZWdpc3RlcihuYW1lT3JGb3JtYXRNYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVnaXN0cnkuZ2V0KG5hbWVPckZvcm1hdE1hcCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyTWFueShuYW1lT3JGb3JtYXRNYXApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdEFQSTtcbiIsImNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9ICdQYXJzZUVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFyc2VFcnJvcjtcbiIsImNvbnN0IGluZmVycmVkUHJvcGVydGllcyA9IHtcbiAgYXJyYXk6IFtcbiAgICAnYWRkaXRpb25hbEl0ZW1zJyxcbiAgICAnaXRlbXMnLFxuICAgICdtYXhJdGVtcycsXG4gICAgJ21pbkl0ZW1zJyxcbiAgICAndW5pcXVlSXRlbXMnLFxuICBdLFxuICBpbnRlZ2VyOiBbXG4gICAgJ2V4Y2x1c2l2ZU1heGltdW0nLFxuICAgICdleGNsdXNpdmVNaW5pbXVtJyxcbiAgICAnbWF4aW11bScsXG4gICAgJ21pbmltdW0nLFxuICAgICdtdWx0aXBsZU9mJyxcbiAgXSxcbiAgb2JqZWN0OiBbXG4gICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJyxcbiAgICAnZGVwZW5kZW5jaWVzJyxcbiAgICAnbWF4UHJvcGVydGllcycsXG4gICAgJ21pblByb3BlcnRpZXMnLFxuICAgICdwYXR0ZXJuUHJvcGVydGllcycsXG4gICAgJ3Byb3BlcnRpZXMnLFxuICAgICdyZXF1aXJlZCcsXG4gIF0sXG4gIHN0cmluZzogW1xuICAgICdtYXhMZW5ndGgnLFxuICAgICdtaW5MZW5ndGgnLFxuICAgICdwYXR0ZXJuJyxcbiAgICAnZm9ybWF0JyxcbiAgXSxcbn07XG5cbmluZmVycmVkUHJvcGVydGllcy5udW1iZXIgPSBpbmZlcnJlZFByb3BlcnRpZXMuaW50ZWdlcjtcblxuY29uc3Qgc3Vic2NoZW1hUHJvcGVydGllcyA9IFtcbiAgJ2FkZGl0aW9uYWxJdGVtcycsXG4gICdpdGVtcycsXG4gICdhZGRpdGlvbmFsUHJvcGVydGllcycsXG4gICdkZXBlbmRlbmNpZXMnLFxuICAncGF0dGVyblByb3BlcnRpZXMnLFxuICAncHJvcGVydGllcycsXG5dO1xuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIGtleXMgb2YgYG9iamAgYW5kOlxuICogLSBjaGVja3Mgd2hldGhlciB0aG9zZSBrZXlzIG1hdGNoIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBpbmZlcnJlZCB0eXBlXG4gKiAtIG1ha2VzIHN1cmUgdGhhdCBgb2JqYCBpcyBub3QgYSBzdWJzY2hlbWE7IF9EbyBub3QgYXR0ZW1wdCB0byBpbmZlciBwcm9wZXJ0aWVzIG5hbWVkIGFzIHN1YnNjaGVtYSBjb250YWluZXJzLiBUaGVcbiAqIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IGFueSBwcm9wZXJ0eSBuYW1lIHdpdGhpbiB0aG9zZSBjb250YWluZXJzIHRoYXQgbWF0Y2hlcyBvbmUgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBmb3JcbiAqIGluZmVycmluZyBtaXNzaW5nIHR5cGUgdmFsdWVzIGNhdXNlcyB0aGUgY29udGFpbmVyIGl0c2VsZiB0byBnZXQgcHJvY2Vzc2VkIHdoaWNoIGxlYWRzIHRvIGludmFsaWQgb3V0cHV0LiAoSXNzdWUgNjIpX1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtYXRjaGVzVHlwZShvYmosIGxhc3RFbGVtZW50SW5QYXRoLCBpbmZlcnJlZFR5cGVQcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihwcm9wID0+IHtcbiAgICBjb25zdCBpc1N1YnNjaGVtYSA9IHN1YnNjaGVtYVByb3BlcnRpZXMuaW5kZXhPZihsYXN0RWxlbWVudEluUGF0aCkgPiAtMTtcbiAgICBjb25zdCBpbmZlcnJlZFByb3BlcnR5Rm91bmQgPSBpbmZlcnJlZFR5cGVQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPiAtMTtcblxuICAgIGlmIChpbmZlcnJlZFByb3BlcnR5Rm91bmQgJiYgIWlzU3Vic2NoZW1hKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pLmxlbmd0aCA+IDA7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gYG9iamAgdHlwZSBtaWdodCBiZSBpbmZlcnJlZC4gVGhlIG1lY2hhbmlzbSBpdGVyYXRlcyB0aHJvdWdoIGFsbCBpbmZlcnJlZCB0eXBlcyBkZWZpbml0aW9ucyxcbiAqIHRyaWVzIHRvIG1hdGNoIGFsbG93ZWQgcHJvcGVydGllcyB3aXRoIHByb3BlcnRpZXMgb2YgZ2l2ZW4gYG9iamAuIFJldHVybnMgdHlwZSBuYW1lLCBpZiBpbmZlcnJlZCwgb3IgbnVsbC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gKi9cbmZ1bmN0aW9uIGluZmVyVHlwZShvYmosIHNjaGVtYVBhdGgpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluZmVycmVkUHJvcGVydGllcyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSBrZXlzW2ldO1xuICAgIGNvbnN0IGxhc3RFbGVtZW50SW5QYXRoID0gc2NoZW1hUGF0aFtzY2hlbWFQYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKG1hdGNoZXNUeXBlKG9iaiwgbGFzdEVsZW1lbnRJblBhdGgsIGluZmVycmVkUHJvcGVydGllc1t0eXBlTmFtZV0pKSB7XG4gICAgICByZXR1cm4gdHlwZU5hbWU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluZmVyVHlwZTtcbiIsImltcG9ydCBvcHRpb25BUEkgZnJvbSAnLi4vYXBpL29wdGlvbic7XG5cbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbWl6ZWQgYm9vbGVhbiB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbkdlbmVyYXRvcigpIHtcbiAgcmV0dXJuIG9wdGlvbkFQSSgncmFuZG9tJykoKSA+IDAuNTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYm9vbGVhbkdlbmVyYXRvcjtcbiIsImltcG9ydCBib29sZWFuR2VuZXJhdG9yIGZyb20gJy4uL2dlbmVyYXRvcnMvYm9vbGVhbic7XG5cbmNvbnN0IGJvb2xlYW5UeXBlID0gYm9vbGVhbkdlbmVyYXRvcjtcblxuZXhwb3J0IGRlZmF1bHQgYm9vbGVhblR5cGU7XG4iLCIvKipcbiAqIEdlbmVyYXRlcyBudWxsIHZhbHVlLlxuICpcbiAqIEByZXR1cm5zIHtudWxsfVxuICovXG5mdW5jdGlvbiBudWxsR2VuZXJhdG9yKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbnVsbEdlbmVyYXRvcjtcbiIsImltcG9ydCBudWxsR2VuZXJhdG9yIGZyb20gJy4uL2dlbmVyYXRvcnMvbnVsbCc7XG5cbmNvbnN0IG51bGxUeXBlID0gbnVsbEdlbmVyYXRvcjtcblxuZXhwb3J0IGRlZmF1bHQgbnVsbFR5cGU7XG4iLCJpbXBvcnQgcmFuZG9tIGZyb20gJy4uL2NvcmUvcmFuZG9tJztcbmltcG9ydCB1dGlscyBmcm9tICcuLi9jb3JlL3V0aWxzJztcbmltcG9ydCBQYXJzZUVycm9yIGZyb20gJy4uL2NvcmUvZXJyb3InO1xuaW1wb3J0IG9wdGlvbkFQSSBmcm9tICcuLi9hcGkvb3B0aW9uJztcblxuLy8gVE9ETyBwcm92aWRlIHR5cGVzXG5mdW5jdGlvbiB1bmlxdWUocGF0aCwgaXRlbXMsIHZhbHVlLCBzYW1wbGUsIHJlc29sdmUsIHRyYXZlcnNlQ2FsbGJhY2spIHtcbiAgY29uc3QgdG1wID0gW107XG4gIGNvbnN0IHNlZW4gPSBbXTtcblxuICBmdW5jdGlvbiB3YWxrKG9iaikge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmoudmFsdWUpO1xuXG4gICAgaWYgKHNlZW4uaW5kZXhPZihqc29uKSA9PT0gLTEpIHtcbiAgICAgIHNlZW4ucHVzaChqc29uKTtcbiAgICAgIHRtcC5wdXNoKG9iaik7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGl0ZW1zLmZvckVhY2god2Fsayk7XG5cbiAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbj9cbiAgbGV0IGxpbWl0ID0gMTAwO1xuXG4gIHdoaWxlICh0bXAubGVuZ3RoICE9PSBpdGVtcy5sZW5ndGgpIHtcbiAgICBpZiAoIXdhbGsodHJhdmVyc2VDYWxsYmFjayh2YWx1ZS5pdGVtcyB8fCBzYW1wbGUsIHBhdGgsIHJlc29sdmUpKSkge1xuICAgICAgbGltaXQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoIWxpbWl0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG1wO1xufVxuXG4vLyBUT0RPIHByb3ZpZGUgdHlwZXNcbmZ1bmN0aW9uIGFycmF5VHlwZSh2YWx1ZSwgcGF0aCwgcmVzb2x2ZSwgdHJhdmVyc2VDYWxsYmFjaykge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gIGlmICghKHZhbHVlLml0ZW1zIHx8IHZhbHVlLmFkZGl0aW9uYWxJdGVtcykpIHtcbiAgICBpZiAodXRpbHMuaGFzUHJvcGVydGllcyh2YWx1ZSwgJ21pbkl0ZW1zJywgJ21heEl0ZW1zJywgJ3VuaXF1ZUl0ZW1zJykpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBtaXNzaW5nIGl0ZW1zIGZvciAke3V0aWxzLnNob3J0KHZhbHVlKX1gLCBwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUuaXRlbXMpKSB7XG4gICAgcmV0dXJuIHZhbHVlLml0ZW1zLm1hcCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBjb25zdCBpdGVtU3VicGF0aCA9IHBhdGguY29uY2F0KFsnaXRlbXMnLCBrZXldKTtcblxuICAgICAgcmV0dXJuIHRyYXZlcnNlQ2FsbGJhY2soaXRlbSwgaXRlbVN1YnBhdGgsIHJlc29sdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgbGV0IG1pbkl0ZW1zID0gdmFsdWUubWluSXRlbXM7XG4gIGxldCBtYXhJdGVtcyA9IHZhbHVlLm1heEl0ZW1zO1xuXG4gIGNvbnN0IGRlZmF1bHRNaW5JdGVtcyA9IG9wdGlvbkFQSSgnbWluSXRlbXMnKTtcbiAgY29uc3QgZGVmYXVsdE1heEl0ZW1zID0gb3B0aW9uQVBJKCdtYXhJdGVtcycpO1xuXG4gIGlmIChkZWZhdWx0TWluSXRlbXMpIHtcbiAgICAvLyBmaXggYm91bmRhcmllc1xuICAgIG1pbkl0ZW1zID0gdHlwZW9mIG1pbkl0ZW1zID09PSAndW5kZWZpbmVkJ1xuICAgICAgPyBkZWZhdWx0TWluSXRlbXNcbiAgICAgIDogTWF0aC5taW4oZGVmYXVsdE1pbkl0ZW1zLCBtaW5JdGVtcyk7XG4gIH1cblxuICBpZiAoZGVmYXVsdE1heEl0ZW1zKSB7XG4gICAgbWF4SXRlbXMgPSB0eXBlb2YgbWF4SXRlbXMgPT09ICd1bmRlZmluZWQnXG4gICAgICA/IGRlZmF1bHRNYXhJdGVtc1xuICAgICAgOiBNYXRoLm1pbihkZWZhdWx0TWF4SXRlbXMsIG1heEl0ZW1zKTtcblxuICAgIC8vIERvbid0IGFsbG93IHVzZXIgdG8gc2V0IG1heCBpdGVtcyBhYm92ZSBvdXIgbWF4aW11bVxuICAgIGlmIChtYXhJdGVtcyAmJiBtYXhJdGVtcyA+IGRlZmF1bHRNYXhJdGVtcykge1xuICAgICAgbWF4SXRlbXMgPSBkZWZhdWx0TWF4SXRlbXM7XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgYWxsb3cgdXNlciB0byBzZXQgbWluIGl0ZW1zIGFib3ZlIG91ciBtYXhpbXVtXG4gICAgaWYgKG1pbkl0ZW1zICYmIG1pbkl0ZW1zID4gZGVmYXVsdE1heEl0ZW1zKSB7XG4gICAgICBtaW5JdGVtcyA9IG1heEl0ZW1zO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wdGlvbmFsc1Byb2JhYmlsaXR5ID0gb3B0aW9uQVBJKCdhbHdheXNGYWtlT3B0aW9uYWxzJykgPT09IHRydWUgPyAxLjAgOiBvcHRpb25BUEkoJ29wdGlvbmFsc1Byb2JhYmlsaXR5Jyk7XG4gIGNvbnN0IGZpeGVkUHJvYmFiaWxpdGllcyA9IG9wdGlvbkFQSSgnYWx3YXlzRmFrZU9wdGlvbmFscycpIHx8IG9wdGlvbkFQSSgnZml4ZWRQcm9iYWJpbGl0aWVzJykgfHwgZmFsc2U7XG5cbiAgbGV0IGxlbmd0aCA9IHJhbmRvbS5udW1iZXIobWluSXRlbXMsIG1heEl0ZW1zLCAxLCA1KTtcblxuICBpZiAob3B0aW9uYWxzUHJvYmFiaWxpdHkgIT09IG51bGwpIHtcbiAgICBsZW5ndGggPSBNYXRoLm1heChmaXhlZFByb2JhYmlsaXRpZXNcbiAgICAgID8gTWF0aC5yb3VuZCgobWF4SXRlbXMgfHwgbGVuZ3RoKSAqIG9wdGlvbmFsc1Byb2JhYmlsaXR5KVxuICAgICAgOiBNYXRoLmFicyhyYW5kb20ubnVtYmVyKG1pbkl0ZW1zLCBtYXhJdGVtcykgKiBvcHRpb25hbHNQcm9iYWJpbGl0eSksIG1pbkl0ZW1zIHx8IDApO1xuICB9XG5cbiAgLy8gVE9ETyBiZWxvdyBsb29rcyBiYWQuIFNob3VsZCBhZGRpdGlvbmFsSXRlbXMgYmUgY29waWVkIGFzLWlzP1xuICBjb25zdCBzYW1wbGUgPSB0eXBlb2YgdmFsdWUuYWRkaXRpb25hbEl0ZW1zID09PSAnb2JqZWN0JyA/IHZhbHVlLmFkZGl0aW9uYWxJdGVtcyA6IHt9O1xuXG4gIGZvciAobGV0IGN1cnJlbnQgPSBpdGVtcy5sZW5ndGg7IGN1cnJlbnQgPCBsZW5ndGg7IGN1cnJlbnQgKz0gMSkge1xuICAgIGNvbnN0IGl0ZW1TdWJwYXRoID0gcGF0aC5jb25jYXQoWydpdGVtcycsIGN1cnJlbnRdKTtcbiAgICBjb25zdCBlbGVtZW50ID0gdHJhdmVyc2VDYWxsYmFjayh2YWx1ZS5pdGVtcyB8fCBzYW1wbGUsIGl0ZW1TdWJwYXRoLCByZXNvbHZlKTtcblxuICAgIGl0ZW1zLnB1c2goZWxlbWVudCk7XG4gIH1cblxuICBpZiAodmFsdWUuY29udGFpbnMgJiYgbGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGlkeCA9IHJhbmRvbS5udW1iZXIoMCwgbGVuZ3RoIC0gMSk7XG5cbiAgICBpdGVtc1tpZHhdID0gdHJhdmVyc2VDYWxsYmFjayh2YWx1ZS5jb250YWlucywgcGF0aC5jb25jYXQoWydpdGVtcycsIGlkeF0pLCByZXNvbHZlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZS51bmlxdWVJdGVtcykge1xuICAgIHJldHVybiB1bmlxdWUocGF0aC5jb25jYXQoWydpdGVtcyddKSwgaXRlbXMsIHZhbHVlLCBzYW1wbGUsIHJlc29sdmUsIHRyYXZlcnNlQ2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVR5cGU7XG4iLCJpbXBvcnQgcmFuZG9tIGZyb20gJy4uL2NvcmUvcmFuZG9tJztcbmltcG9ydCBlbnYgZnJvbSAnLi4vY29yZS9jb25zdGFudHMnO1xuXG5mdW5jdGlvbiBudW1iZXJUeXBlKHZhbHVlKSB7XG4gIGxldCBtaW4gPSB0eXBlb2YgdmFsdWUubWluaW11bSA9PT0gJ3VuZGVmaW5lZCcgPyBlbnYuTUlOX0lOVEVHRVIgOiB2YWx1ZS5taW5pbXVtO1xuICBsZXQgbWF4ID0gdHlwZW9mIHZhbHVlLm1heGltdW0gPT09ICd1bmRlZmluZWQnID8gZW52Lk1BWF9JTlRFR0VSIDogdmFsdWUubWF4aW11bTtcblxuICBjb25zdCBtdWx0aXBsZU9mID0gdmFsdWUubXVsdGlwbGVPZjtcblxuICBpZiAobXVsdGlwbGVPZikge1xuICAgIG1heCA9IE1hdGguZmxvb3IobWF4IC8gbXVsdGlwbGVPZikgKiBtdWx0aXBsZU9mO1xuICAgIG1pbiA9IE1hdGguY2VpbChtaW4gLyBtdWx0aXBsZU9mKSAqIG11bHRpcGxlT2Y7XG4gIH1cblxuICBpZiAodmFsdWUuZXhjbHVzaXZlTWluaW11bSAmJiBtaW4gPT09IHZhbHVlLm1pbmltdW0pIHtcbiAgICBtaW4gKz0gbXVsdGlwbGVPZiB8fCAxO1xuICB9XG5cbiAgaWYgKHZhbHVlLmV4Y2x1c2l2ZU1heGltdW0gJiYgbWF4ID09PSB2YWx1ZS5tYXhpbXVtKSB7XG4gICAgbWF4IC09IG11bHRpcGxlT2YgfHwgMTtcbiAgfVxuXG4gIGlmIChtaW4gPiBtYXgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgaWYgKG11bHRpcGxlT2YpIHtcbiAgICBpZiAoU3RyaW5nKG11bHRpcGxlT2YpLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgIGxldCBiYXNlID0gcmFuZG9tLm51bWJlcihNYXRoLmZsb29yKG1pbiAvIG11bHRpcGxlT2YpLCBNYXRoLmZsb29yKG1heCAvIG11bHRpcGxlT2YpKSAqIG11bHRpcGxlT2Y7XG5cbiAgICAgIHdoaWxlIChiYXNlIDwgbWluKSB7XG4gICAgICAgIGJhc2UgKz0gdmFsdWUubXVsdGlwbGVPZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYm91bmRhcnkgPSAobWF4IC0gbWluKSAvIG11bHRpcGxlT2Y7XG5cbiAgICBsZXQgbnVtO1xuICAgIGxldCBmaXg7XG5cbiAgICBkbyB7XG4gICAgICBudW0gPSByYW5kb20ubnVtYmVyKDAsIGJvdW5kYXJ5KSAqIG11bHRpcGxlT2Y7XG4gICAgICBmaXggPSAobnVtIC8gbXVsdGlwbGVPZikgJSAxO1xuICAgIH0gd2hpbGUgKGZpeCAhPT0gMCk7XG5cbiAgICAvLyBGSVhNRTogaHR0cHM6Ly9naXRodWIuY29tL2pzb24tc2NoZW1hLWZha2VyL2pzb24tc2NoZW1hLWZha2VyL2lzc3Vlcy8zNzlcblxuICAgIHJldHVybiBtaW4gKyBudW07XG4gIH1cblxuICByZXR1cm4gcmFuZG9tLm51bWJlcihtaW4sIG1heCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBudW1iZXJUeXBlO1xuIiwiaW1wb3J0IG51bWJlciBmcm9tICcuL251bWJlcic7XG5cbi8vIFRoZSBgaW50ZWdlcmAgdHlwZSBpcyBqdXN0IGEgd3JhcHBlciBmb3IgdGhlIGBudW1iZXJgIHR5cGUuIFRoZSBgbnVtYmVyYCB0eXBlXG4vLyByZXR1cm5zIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIGFuZCBgaW50ZWdlcmAgdHlwZSB0cnVuY2F0ZXMgdGhlIGZyYWN0aW9uXG4vLyBwYXJ0LCBsZWF2aW5nIHRoZSByZXN1bHQgYXMgYW4gaW50ZWdlci5cblxuZnVuY3Rpb24gaW50ZWdlclR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIG51bWJlcih7IG11bHRpcGxlT2Y6IDEsIC4uLnZhbHVlIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbnRlZ2VyVHlwZTtcbiIsImltcG9ydCByYW5kb20gZnJvbSAnLi4vY29yZS9yYW5kb20nO1xuXG5jb25zdCBMSVBTVU1fV09SRFMgPSBgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmVcbmV0IGRvbG9yZSBtYWduYSBhbGlxdWEgVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0gcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhXG5jb21tb2RvIGNvbnNlcXVhdCBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYVxucGFyaWF0dXIgRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdFxubGFib3J1bWAuc3BsaXQoL1xcVy8pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb21pemVkIGFycmF5IG9mIHNpbmdsZSBsb3JlbSBpcHN1bSB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIHdvcmRzR2VuZXJhdG9yKGxlbmd0aCkge1xuICBjb25zdCB3b3JkcyA9IHJhbmRvbS5zaHVmZmxlKExJUFNVTV9XT1JEUyk7XG5cbiAgcmV0dXJuIHdvcmRzLnNsaWNlKDAsIGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdvcmRzR2VuZXJhdG9yO1xuIiwiaW1wb3J0IGNvbnN0YW50cyBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XG5pbXBvcnQgcmFuZG9tIGZyb20gJy4uL2NvcmUvcmFuZG9tJztcbmltcG9ydCB3b3JkcyBmcm9tICcuLi9nZW5lcmF0b3JzL3dvcmRzJztcbmltcG9ydCB1dGlscyBmcm9tICcuLi9jb3JlL3V0aWxzJztcbmltcG9ydCBvcHRpb25BUEkgZnJvbSAnLi4vYXBpL29wdGlvbic7XG5cbi8vIGZhbGxiYWNrIGdlbmVyYXRvclxuY29uc3QgYW55VHlwZSA9IHsgdHlwZTogY29uc3RhbnRzLkFMTE9XRURfVFlQRVMgfTtcblxuLy8gVE9ETyBwcm92aWRlIHR5cGVzXG5mdW5jdGlvbiBvYmplY3RUeXBlKHZhbHVlLCBwYXRoLCByZXNvbHZlLCB0cmF2ZXJzZUNhbGxiYWNrKSB7XG4gIGNvbnN0IHByb3BzID0ge307XG5cbiAgY29uc3QgcHJvcGVydGllcyA9IHZhbHVlLnByb3BlcnRpZXMgfHwge307XG4gIGNvbnN0IHBhdHRlcm5Qcm9wZXJ0aWVzID0gdmFsdWUucGF0dGVyblByb3BlcnRpZXMgfHwge307XG4gIGNvbnN0IHJlcXVpcmVkUHJvcGVydGllcyA9IHR5cGVvZiB2YWx1ZS5yZXF1aXJlZCA9PT0gJ2Jvb2xlYW4nID8gW10gOiAodmFsdWUucmVxdWlyZWQgfHwgW10pLnNsaWNlKCk7XG4gIGNvbnN0IGFsbG93c0FkZGl0aW9uYWwgPSB2YWx1ZS5hZGRpdGlvbmFsUHJvcGVydGllcyAhPT0gZmFsc2U7XG5cbiAgY29uc3QgcHJvcGVydHlLZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGNvbnN0IHBhdHRlcm5Qcm9wZXJ0eUtleXMgPSBPYmplY3Qua2V5cyhwYXR0ZXJuUHJvcGVydGllcyk7XG4gIGNvbnN0IG9wdGlvbmFsUHJvcGVydGllcyA9IHByb3BlcnR5S2V5cy5jb25jYXQocGF0dGVyblByb3BlcnR5S2V5cykucmVkdWNlKChfcmVzcG9uc2UsIF9rZXkpID0+IHtcbiAgICBpZiAocmVxdWlyZWRQcm9wZXJ0aWVzLmluZGV4T2YoX2tleSkgPT09IC0xKSBfcmVzcG9uc2UucHVzaChfa2V5KTtcbiAgICByZXR1cm4gX3Jlc3BvbnNlO1xuICB9LCBbXSk7XG4gIGNvbnN0IGFsbFByb3BlcnRpZXMgPSByZXF1aXJlZFByb3BlcnRpZXMuY29uY2F0KG9wdGlvbmFsUHJvcGVydGllcyk7XG5cbiAgY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXMgPSBhbGxvd3NBZGRpdGlvbmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICA/ICh2YWx1ZS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdHJ1ZSA/IGFueVR5cGUgOiB2YWx1ZS5hZGRpdGlvbmFsUHJvcGVydGllcylcbiAgICA6IHZhbHVlLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuXG4gIGlmICghYWxsb3dzQWRkaXRpb25hbFxuICAgICYmIHByb3BlcnR5S2V5cy5sZW5ndGggPT09IDBcbiAgICAmJiBwYXR0ZXJuUHJvcGVydHlLZXlzLmxlbmd0aCA9PT0gMFxuICAgICYmIHV0aWxzLmhhc1Byb3BlcnRpZXModmFsdWUsICdtaW5Qcm9wZXJ0aWVzJywgJ21heFByb3BlcnRpZXMnLCAnZGVwZW5kZW5jaWVzJywgJ3JlcXVpcmVkJylcbiAgKSB7XG4gICAgLy8ganVzdCBub3RoaW5nXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAob3B0aW9uQVBJKCdyZXF1aXJlZE9ubHknKSA9PT0gdHJ1ZSkge1xuICAgIHJlcXVpcmVkUHJvcGVydGllcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAocHJvcGVydGllc1trZXldKSB7XG4gICAgICAgIHByb3BzW2tleV0gPSBwcm9wZXJ0aWVzW2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJhdmVyc2VDYWxsYmFjayhwcm9wcywgcGF0aC5jb25jYXQoWydwcm9wZXJ0aWVzJ10pLCByZXNvbHZlLCB2YWx1ZSk7XG4gIH1cblxuICBjb25zdCBvcHRpb25hbHNQcm9iYWJpbGl0eSA9IG9wdGlvbkFQSSgnYWx3YXlzRmFrZU9wdGlvbmFscycpID09PSB0cnVlID8gMS4wIDogb3B0aW9uQVBJKCdvcHRpb25hbHNQcm9iYWJpbGl0eScpO1xuICBjb25zdCBmaXhlZFByb2JhYmlsaXRpZXMgPSBvcHRpb25BUEkoJ2Fsd2F5c0Zha2VPcHRpb25hbHMnKSB8fCBvcHRpb25BUEkoJ2ZpeGVkUHJvYmFiaWxpdGllcycpIHx8IGZhbHNlO1xuICBjb25zdCBpZ25vcmVQcm9wZXJ0aWVzID0gb3B0aW9uQVBJKCdpZ25vcmVQcm9wZXJ0aWVzJykgfHwgW107XG4gIGNvbnN0IHJldXNlUHJvcHMgPSBvcHRpb25BUEkoJ3JldXNlUHJvcGVydGllcycpO1xuICBjb25zdCBmaWxsUHJvcHMgPSBvcHRpb25BUEkoJ2ZpbGxQcm9wZXJ0aWVzJyk7XG5cbiAgY29uc3QgbWF4ID0gdmFsdWUubWF4UHJvcGVydGllcyB8fCAoYWxsUHJvcGVydGllcy5sZW5ndGggKyAoYWxsb3dzQWRkaXRpb25hbCA/IHJhbmRvbS5udW1iZXIoMSwgNSkgOiAwKSk7XG5cbiAgbGV0IG1pbiA9IE1hdGgubWF4KHZhbHVlLm1pblByb3BlcnRpZXMgfHwgMCwgcmVxdWlyZWRQcm9wZXJ0aWVzLmxlbmd0aCk7XG4gIGxldCBuZWVkZWRFeHRyYXMgPSBNYXRoLm1heCgwLCBhbGxQcm9wZXJ0aWVzLmxlbmd0aCAtIG1pbik7XG5cbiAgaWYgKGFsbFByb3BlcnRpZXMubGVuZ3RoID09PSAxICYmICFyZXF1aXJlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgbWluID0gTWF0aC5tYXgocmFuZG9tLm51bWJlcihmaWxsUHJvcHMgPyAxIDogMCwgbWF4KSwgbWluKTtcbiAgfVxuXG4gIGlmIChvcHRpb25hbHNQcm9iYWJpbGl0eSAhPT0gbnVsbCkge1xuICAgIGlmIChmaXhlZFByb2JhYmlsaXRpZXMgPT09IHRydWUpIHtcbiAgICAgIG5lZWRlZEV4dHJhcyA9IE1hdGgucm91bmQoKG1pbiAtIHJlcXVpcmVkUHJvcGVydGllcy5sZW5ndGgpICsgKG9wdGlvbmFsc1Byb2JhYmlsaXR5ICogKGFsbFByb3BlcnRpZXMubGVuZ3RoIC0gbWluKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZWVkZWRFeHRyYXMgPSByYW5kb20ubnVtYmVyKG1pbiAtIHJlcXVpcmVkUHJvcGVydGllcy5sZW5ndGgsIG9wdGlvbmFsc1Byb2JhYmlsaXR5ICogKGFsbFByb3BlcnRpZXMubGVuZ3RoIC0gbWluKSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXh0cmFQcm9wZXJ0aWVzUmFuZG9tT3JkZXIgPSByYW5kb20uc2h1ZmZsZShvcHRpb25hbFByb3BlcnRpZXMpLnNsaWNlKDAsIG5lZWRlZEV4dHJhcyk7XG4gIGNvbnN0IGV4dHJhUHJvcGVydGllcyA9IG9wdGlvbmFsUHJvcGVydGllcy5maWx0ZXIoX2l0ZW0gPT4ge1xuICAgIHJldHVybiBleHRyYVByb3BlcnRpZXNSYW5kb21PcmRlci5pbmRleE9mKF9pdGVtKSAhPT0gLTE7XG4gIH0pO1xuXG4gIC8vIHByb3BlcnRpZXMgYXJlIHJlYWQgZnJvbSByaWdodC10by1sZWZ0XG4gIGNvbnN0IF9saW1pdCA9IG9wdGlvbmFsc1Byb2JhYmlsaXR5ICE9PSBudWxsIHx8IHJlcXVpcmVkUHJvcGVydGllcy5sZW5ndGggPT09IG1heCA/IG1heCA6IHJhbmRvbS5udW1iZXIoMCwgbWF4KTtcbiAgY29uc3QgX3Byb3BzID0gcmVxdWlyZWRQcm9wZXJ0aWVzLmNvbmNhdChyYW5kb20uc2h1ZmZsZShleHRyYVByb3BlcnRpZXMpLnNsaWNlKDAsIF9saW1pdCkpLnNsaWNlKDAsIG1heCk7XG4gIGNvbnN0IF9kZWZucyA9IFtdO1xuXG4gIGlmICh2YWx1ZS5kZXBlbmRlbmNpZXMpIHtcbiAgICBPYmplY3Qua2V5cyh2YWx1ZS5kZXBlbmRlbmNpZXMpLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBjb25zdCBfcmVxdWlyZWQgPSB2YWx1ZS5kZXBlbmRlbmNpZXNbcHJvcF07XG5cbiAgICAgIGlmIChfcHJvcHMuaW5kZXhPZihwcm9wKSAhPT0gLTEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3JlcXVpcmVkKSkge1xuICAgICAgICAgIC8vIHByb3BlcnR5LWRlcGVuZGVuY2llc1xuICAgICAgICAgIF9yZXF1aXJlZC5mb3JFYWNoKHN1YiA9PiB7XG4gICAgICAgICAgICBpZiAoX3Byb3BzLmluZGV4T2Yoc3ViKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgX3Byb3BzLnB1c2goc3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVmbnMucHVzaChfcmVxdWlyZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBzY2hlbWEtZGVwZW5kZW5jaWVzXG4gICAgaWYgKF9kZWZucy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZS5kZXBlbmRlbmNpZXM7XG5cbiAgICAgIHJldHVybiB0cmF2ZXJzZUNhbGxiYWNrKHtcbiAgICAgICAgYWxsT2Y6IF9kZWZucy5jb25jYXQodmFsdWUpLFxuICAgICAgfSwgcGF0aC5jb25jYXQoWydwcm9wZXJ0aWVzJ10pLCByZXNvbHZlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2tpcHBlZCA9IFtdO1xuICBjb25zdCBtaXNzaW5nID0gW107XG5cbiAgX3Byb3BzLmZvckVhY2goa2V5ID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlnbm9yZVByb3BlcnRpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICgoaWdub3JlUHJvcGVydGllc1tpXSBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBpZ25vcmVQcm9wZXJ0aWVzW2ldLnRlc3Qoa2V5KSlcbiAgICAgICAgfHwgKHR5cGVvZiBpZ25vcmVQcm9wZXJ0aWVzW2ldID09PSAnc3RyaW5nJyAmJiBpZ25vcmVQcm9wZXJ0aWVzW2ldID09PSBrZXkpXG4gICAgICAgIHx8ICh0eXBlb2YgaWdub3JlUHJvcGVydGllc1tpXSA9PT0gJ2Z1bmN0aW9uJyAmJiBpZ25vcmVQcm9wZXJ0aWVzW2ldKHByb3BlcnRpZXNba2V5XSwga2V5KSkpIHtcbiAgICAgICAgc2tpcHBlZC5wdXNoKGtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICBpZiAocmVxdWlyZWRQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgcHJvcHNba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvcGVydGllc1trZXldKSB7XG4gICAgICBwcm9wc1trZXldID0gcHJvcGVydGllc1trZXldO1xuICAgIH1cblxuICAgIGxldCBmb3VuZDtcblxuICAgIC8vIHRoZW4gdHJ5IHBhdHRlcm5Qcm9wZXJ0aWVzXG4gICAgcGF0dGVyblByb3BlcnR5S2V5cy5mb3JFYWNoKF9rZXkgPT4ge1xuICAgICAgaWYgKGtleS5tYXRjaChuZXcgUmVnRXhwKF9rZXkpKSkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHByb3BzW2tleV0pIHtcbiAgICAgICAgICB1dGlscy5tZXJnZShwcm9wc1trZXldLCBwYXR0ZXJuUHJvcGVydGllc1tfa2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcmFuZG9tLnJhbmRleHAoa2V5KV0gPSBwYXR0ZXJuUHJvcGVydGllc1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgLy8gdHJ5IHBhdHRlcm5Qcm9wZXJ0aWVzIGFnYWluLFxuICAgICAgY29uc3Qgc3Vic2NoZW1hID0gcGF0dGVyblByb3BlcnRpZXNba2V5XSB8fCBhZGRpdGlvbmFsUHJvcGVydGllcztcblxuICAgICAgLy8gRklYTUU6IGFsbG93IGFueVR5cGUgYXMgZmFsbGJhY2sgd2hlbiBubyBzdWJzY2hlbWEgaXMgZ2l2ZW4/XG5cbiAgICAgIGlmIChzdWJzY2hlbWEgJiYgYWRkaXRpb25hbFByb3BlcnRpZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSB3ZSBjYW4gdXNlIGFkZGl0aW9uYWxQcm9wZXJ0aWVzP1xuICAgICAgICBwcm9wc1twYXR0ZXJuUHJvcGVydGllc1trZXldID8gcmFuZG9tLnJhbmRleHAoa2V5KSA6IGtleV0gPSBwcm9wZXJ0aWVzW2tleV0gfHwgc3Vic2NoZW1hO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlzc2luZy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBkaXNjYXJkIGFscmVhZHkgaWdub3JlZCBwcm9wcyBpZiB0aGV5J3JlIG5vdCByZXF1aXJlZCB0byBiZSBmaWxsZWQuLi5cbiAgbGV0IGN1cnJlbnQgPSBPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoICsgKGZpbGxQcm9wcyA/IDAgOiBza2lwcGVkLmxlbmd0aCk7XG5cbiAgLy8gZ2VuZXJhdGUgZHluYW1pYyBzdWZmaXggZm9yIGFkZGl0aW9uYWwgcHJvcHMuLi5cbiAgY29uc3QgaGFzaCA9IHN1ZmZpeCA9PiByYW5kb20ucmFuZGV4cChgXz9bX2EtZlxcXFxkXXsxLDN9JHtzdWZmaXggPyAnXFxcXCQ/JyA6ICcnfWApO1xuXG4gIGZ1bmN0aW9uIGdldChmcm9tKSB7XG4gICAgbGV0IG9uZTtcblxuICAgIGRvIHtcbiAgICAgIGlmICghZnJvbS5sZW5ndGgpIGJyZWFrO1xuICAgICAgb25lID0gZnJvbS5zaGlmdCgpO1xuICAgIH0gd2hpbGUgKHByb3BzW29uZV0pO1xuXG4gICAgcmV0dXJuIG9uZTtcbiAgfVxuXG4gIGxldCBtaW5Qcm9wcyA9IG1pbjtcbiAgaWYgKGFsbG93c0FkZGl0aW9uYWwgJiYgIXJlcXVpcmVkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICBtaW5Qcm9wcyA9IE1hdGgubWF4KG9wdGlvbmFsc1Byb2JhYmlsaXR5ID09PSBudWxsIHx8IGFkZGl0aW9uYWxQcm9wZXJ0aWVzID8gcmFuZG9tLm51bWJlcihmaWxsUHJvcHMgPyAxIDogMCwgbWF4KSA6IDAsIG1pbik7XG4gIH1cblxuICB3aGlsZSAoZmlsbFByb3BzKSB7XG4gICAgaWYgKCEocGF0dGVyblByb3BlcnR5S2V5cy5sZW5ndGggfHwgYWxsb3dzQWRkaXRpb25hbCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50ID49IG1pblByb3BzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dzQWRkaXRpb25hbCkge1xuICAgICAgaWYgKHJldXNlUHJvcHMgJiYgKChwcm9wZXJ0eUtleXMubGVuZ3RoIC0gY3VycmVudCkgPiBtaW5Qcm9wcykpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IGtleTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgY291bnQgKz0gMTtcblxuICAgICAgICAgIC8vIHNraXAgbGFyZ2Ugb2JqZWN0c1xuICAgICAgICAgIGlmIChjb3VudCA+IDEwMDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleSA9IGdldChyZXF1aXJlZFByb3BlcnRpZXMpIHx8IHJhbmRvbS5waWNrKHByb3BlcnR5S2V5cyk7XG4gICAgICAgIH0gd2hpbGUgKHR5cGVvZiBwcm9wc1trZXldICE9PSAndW5kZWZpbmVkJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHByb3BzW2tleV0gPSBwcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgY3VycmVudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhdHRlcm5Qcm9wZXJ0eUtleXMubGVuZ3RoICYmICFhZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICBjb25zdCBwcm9wID0gcmFuZG9tLnBpY2socGF0dGVyblByb3BlcnR5S2V5cyk7XG4gICAgICAgIGNvbnN0IHdvcmQgPSByYW5kb20ucmFuZGV4cChwcm9wKTtcblxuICAgICAgICBpZiAoIXByb3BzW3dvcmRdKSB7XG4gICAgICAgICAgcHJvcHNbd29yZF0gPSBwYXR0ZXJuUHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgICBjdXJyZW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdvcmQgPSBnZXQocmVxdWlyZWRQcm9wZXJ0aWVzKSB8fCAod29yZHMoMSkgKyBoYXNoKCkpO1xuXG4gICAgICAgIGlmICghcHJvcHNbd29yZF0pIHtcbiAgICAgICAgICBwcm9wc1t3b3JkXSA9IGFkZGl0aW9uYWxQcm9wZXJ0aWVzIHx8IGFueVR5cGU7XG4gICAgICAgICAgY3VycmVudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGN1cnJlbnQgPCBtaW4gJiYgaSA8IHBhdHRlcm5Qcm9wZXJ0eUtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IF9rZXkgPSBwYXR0ZXJuUHJvcGVydHlLZXlzW2ldO1xuICAgICAgY29uc3Qgd29yZCA9IHJhbmRvbS5yYW5kZXhwKF9rZXkpO1xuXG5cbiAgICAgIGlmICghcHJvcHNbd29yZF0pIHtcbiAgICAgICAgcHJvcHNbd29yZF0gPSBwYXR0ZXJuUHJvcGVydGllc1tfa2V5XTtcbiAgICAgICAgY3VycmVudCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpbGwgdXAtdG8gdGhpcyB2YWx1ZSBhbmQgbm8gbW9yZSFcbiAgaWYgKHJlcXVpcmVkUHJvcGVydGllcy5sZW5ndGggPT09IDAgJiYgKCFhbGxvd3NBZGRpdGlvbmFsIHx8IG9wdGlvbmFsc1Byb2JhYmlsaXR5ID09PSBmYWxzZSkpIHtcbiAgICBjb25zdCBtYXhpbXVtID0gcmFuZG9tLm51bWJlcihtaW4sIG1heCk7XG5cbiAgICBmb3IgKDsgY3VycmVudCA8IG1heGltdW07KSB7XG4gICAgICBjb25zdCB3b3JkID0gZ2V0KHByb3BlcnR5S2V5cyk7XG5cbiAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgIHByb3BzW3dvcmRdID0gcHJvcGVydGllc1t3b3JkXTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCArPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUNhbGxiYWNrKHByb3BzLCBwYXRoLmNvbmNhdChbJ3Byb3BlcnRpZXMnXSksIHJlc29sdmUsIHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VHlwZTtcbiIsImltcG9ydCB3b3JkcyBmcm9tICcuL3dvcmRzJztcbmltcG9ydCByYW5kb20gZnJvbSAnLi4vY29yZS9yYW5kb20nO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIGJ5IHRodW5rR2VuZXJhdG9yIHRvIHByb2R1Y2Ugc29tZSB3b3JkcyBmb3IgdGhlIGZpbmFsIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBwcm9kdWNlKCkge1xuICBjb25zdCBsZW5ndGggPSByYW5kb20ubnVtYmVyKDEsIDUpO1xuXG4gIHJldHVybiB3b3JkcyhsZW5ndGgpLmpvaW4oJyAnKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9taXplZCBjb25jYXRlbmF0ZWQgc3RyaW5nIGJhc2VkIG9uIHdvcmRzIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0aHVua0dlbmVyYXRvcihtaW4gPSAwLCBtYXggPSAxNDApIHtcbiAgY29uc3QgX21pbiA9IE1hdGgubWF4KDAsIG1pbik7XG4gIGNvbnN0IF9tYXggPSByYW5kb20ubnVtYmVyKF9taW4sIG1heCk7XG5cbiAgbGV0IHJlc3VsdCA9IHByb2R1Y2UoKTtcblxuICAvLyBhcHBlbmQgdW50aWwgbGVuZ3RoIGlzIHJlYWNoZWRcbiAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBfbWluKSB7XG4gICAgcmVzdWx0ICs9IHByb2R1Y2UoKTtcbiAgfVxuXG4gIC8vIGN1dCBpZiBuZWVkZWRcbiAgaWYgKHJlc3VsdC5sZW5ndGggPiBfbWF4KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cigwLCBfbWF4KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRodW5rR2VuZXJhdG9yO1xuIiwiaW1wb3J0IHJhbmRvbSBmcm9tICcuLi9jb3JlL3JhbmRvbSc7XG5cbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbWl6ZWQgaXB2NCBhZGRyZXNzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGlwdjRHZW5lcmF0b3IoKSB7XG4gIHJldHVybiBbMCwgMCwgMCwgMF0ubWFwKCgpID0+IHtcbiAgICByZXR1cm4gcmFuZG9tLm51bWJlcigwLCAyNTUpO1xuICB9KS5qb2luKCcuJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlwdjRHZW5lcmF0b3I7XG4iLCJpbXBvcnQgcmFuZG9tIGZyb20gJy4uL2NvcmUvcmFuZG9tJztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9taXplZCBkYXRlIHRpbWUgSVNPIGZvcm1hdCBzdHJpbmcuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGF0ZVRpbWVHZW5lcmF0b3IoKSB7XG4gIHJldHVybiByYW5kb20uZGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRhdGVUaW1lR2VuZXJhdG9yO1xuIiwiaW1wb3J0IGRhdGVUaW1lR2VuZXJhdG9yIGZyb20gJy4vZGF0ZVRpbWUnO1xuXG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb21pemVkIGRhdGUgZm9ybWF0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBkYXRlR2VuZXJhdG9yKCkge1xuICByZXR1cm4gZGF0ZVRpbWVHZW5lcmF0b3IoKS5zbGljZSgwLCAxMCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRhdGVHZW5lcmF0b3I7XG4iLCJpbXBvcnQgZGF0ZVRpbWVHZW5lcmF0b3IgZnJvbSAnLi9kYXRlVGltZSc7XG5cbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbWl6ZWQgdGltZSBmb3JtYXQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRpbWVHZW5lcmF0b3IoKSB7XG4gIHJldHVybiBkYXRlVGltZUdlbmVyYXRvcigpLnNsaWNlKDExKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGltZUdlbmVyYXRvcjtcbiIsImltcG9ydCByYW5kb20gZnJvbSAnLi4vY29yZS9yYW5kb20nO1xuXG5jb25zdCBGUkFHTUVOVCA9ICdbYS16QS1aXVthLXpBLVowLTkrLS5dKic7XG5jb25zdCBVUklfUEFUVEVSTiA9IGBodHRwcz86Ly97aG9zdG5hbWV9KD86JHtGUkFHTUVOVH0pK2A7XG5jb25zdCBQQVJBTV9QQVRURVJOID0gJyg/OlxcXFw/KFthLXpdezEsN30oPVxcXFx3ezEsNX0pPyYpezAsM30pPyc7XG5cbi8qKlxuICogUHJlZGVmaW5lZCBjb3JlIGZvcm1hdHNcbiAqIEB0eXBlIHtba2V5OiBzdHJpbmddOiBzdHJpbmd9XG4gKi9cbmNvbnN0IHJlZ2V4cHMgPSB7XG4gIGVtYWlsOiAnW2EtekEtWlxcXFxkXVthLXpBLVpcXFxcZC1dezEsMTN9W2EtekEtWlxcXFxkXUB7aG9zdG5hbWV9JyxcbiAgaG9zdG5hbWU6ICdbYS16QS1aXXsxLDMzfVxcXFwuW2Etel17Miw0fScsXG4gIGlwdjY6ICdbYS1mXFxcXGRdezR9KDpbYS1mXFxcXGRdezR9KXs3fScsXG4gIHVyaTogVVJJX1BBVFRFUk4sXG4gIHNsdWc6ICdbYS16QS1aXFxcXGRfLV0rJyxcblxuICAvLyB0eXBlcyBmcm9tIGRyYWZ0LTBbNjddICg/KVxuICAndXJpLXJlZmVyZW5jZSc6IGAke1VSSV9QQVRURVJOfSR7UEFSQU1fUEFUVEVSTn1gLFxuICAndXJpLXRlbXBsYXRlJzogVVJJX1BBVFRFUk4ucmVwbGFjZSgnKD86JywgJyg/Oi9cXFxce1thLXpdWzphLXpBLVowLTktXSpcXFxcfXwnKSxcbiAgJ2pzb24tcG9pbnRlcic6IGAoLyg/OiR7RlJBR01FTlQucmVwbGFjZSgnXSonLCAnL10qJyl9fH5bMDFdKSkrYCxcblxuICAvLyBzb21lIHR5cGVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL09BSS9PcGVuQVBJLVNwZWNpZmljYXRpb24vYmxvYi9tYXN0ZXIvdmVyc2lvbnMvMy4wLjEubWQjZGF0YS10eXBlcyAoPylcbiAgdXVpZDogJ15bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JCcsXG59O1xuXG5yZWdleHBzLmlyaSA9IHJlZ2V4cHNbJ3VyaS1yZWZlcmVuY2UnXTtcbnJlZ2V4cHNbJ2lyaS1yZWZlcmVuY2UnXSA9IHJlZ2V4cHNbJ3VyaS1yZWZlcmVuY2UnXTtcblxucmVnZXhwc1snaWRuLWVtYWlsJ10gPSByZWdleHBzLmVtYWlsO1xucmVnZXhwc1snaWRuLWhvc3RuYW1lJ10gPSByZWdleHBzLmhvc3RuYW1lO1xuXG5jb25zdCBBTExPV0VEX0ZPUk1BVFMgPSBuZXcgUmVnRXhwKGBcXFxceygke09iamVjdC5rZXlzKHJlZ2V4cHMpLmpvaW4oJ3wnKX0pXFxcXH1gKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9taXplZCBzdHJpbmcgYmFzaW5nIG9uIGEgYnVpbHQtaW4gcmVnZXggZm9ybWF0XG4gKlxuICogQHBhcmFtIGNvcmVGb3JtYXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNvcmVGb3JtYXRHZW5lcmF0b3IoY29yZUZvcm1hdCkge1xuICByZXR1cm4gcmFuZG9tLnJhbmRleHAocmVnZXhwc1tjb3JlRm9ybWF0XSkucmVwbGFjZShBTExPV0VEX0ZPUk1BVFMsIChtYXRjaCwga2V5KSA9PiB7XG4gICAgcmV0dXJuIHJhbmRvbS5yYW5kZXhwKHJlZ2V4cHNba2V5XSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3JlRm9ybWF0R2VuZXJhdG9yO1xuIiwiaW1wb3J0IHRodW5rIGZyb20gJy4uL2dlbmVyYXRvcnMvdGh1bmsnO1xuaW1wb3J0IGlwdjQgZnJvbSAnLi4vZ2VuZXJhdG9ycy9pcHY0JztcbmltcG9ydCBkYXRlVGltZSBmcm9tICcuLi9nZW5lcmF0b3JzL2RhdGVUaW1lJztcbmltcG9ydCBkYXRlIGZyb20gJy4uL2dlbmVyYXRvcnMvZGF0ZSc7XG5pbXBvcnQgdGltZSBmcm9tICcuLi9nZW5lcmF0b3JzL3RpbWUnO1xuaW1wb3J0IGNvcmVGb3JtYXQgZnJvbSAnLi4vZ2VuZXJhdG9ycy9jb3JlRm9ybWF0JztcbmltcG9ydCBvcHRpb25BUEkgZnJvbSAnLi4vYXBpL29wdGlvbic7XG5pbXBvcnQgZm9ybWF0IGZyb20gJy4uL2FwaS9mb3JtYXQnO1xuaW1wb3J0IHJhbmRvbSBmcm9tICcuLi9jb3JlL3JhbmRvbSc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vY29yZS91dGlscyc7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRm9ybWF0KHZhbHVlLCBpbnZhbGlkKSB7XG4gIGNvbnN0IGNhbGxiYWNrID0gZm9ybWF0KHZhbHVlLmZvcm1hdCk7XG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSk7XG4gIH1cblxuICBzd2l0Y2ggKHZhbHVlLmZvcm1hdCkge1xuICAgIGNhc2UgJ2RhdGUtdGltZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgcmV0dXJuIGRhdGVUaW1lKCk7XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICByZXR1cm4gZGF0ZSgpO1xuICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgcmV0dXJuIHRpbWUoKTtcbiAgICBjYXNlICdpcHY0JzpcbiAgICAgIHJldHVybiBpcHY0KCk7XG4gICAgY2FzZSAncmVnZXgnOlxuICAgICAgLy8gVE9ETzogZGlzY3Vzc1xuICAgICAgcmV0dXJuICcuKz8nO1xuICAgIGNhc2UgJ2VtYWlsJzpcbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgY2FzZSAnaXB2Nic6XG4gICAgY2FzZSAndXJpJzpcbiAgICBjYXNlICd1cmktcmVmZXJlbmNlJzpcbiAgICBjYXNlICdpcmknOlxuICAgIGNhc2UgJ2lyaS1yZWZlcmVuY2UnOlxuICAgIGNhc2UgJ2lkbi1lbWFpbCc6XG4gICAgY2FzZSAnaWRuLWhvc3RuYW1lJzpcbiAgICBjYXNlICdqc29uLXBvaW50ZXInOlxuICAgIGNhc2UgJ3NsdWcnOlxuICAgIGNhc2UgJ3VyaS10ZW1wbGF0ZSc6XG4gICAgY2FzZSAndXVpZCc6XG4gICAgICByZXR1cm4gY29yZUZvcm1hdCh2YWx1ZS5mb3JtYXQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAob3B0aW9uQVBJKCdmYWlsT25JbnZhbGlkRm9ybWF0JykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gcmVnaXN0cnkga2V5ICR7dXRpbHMuc2hvcnQodmFsdWUuZm9ybWF0KX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZm9ybWF0ICcke3ZhbHVlLmZvcm1hdH0nYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5nVHlwZSh2YWx1ZSkge1xuICAvLyBoZXJlIHdlIG5lZWQgdG8gZm9yY2UgdHlwZSB0byBmaXggIzQ2N1xuICBjb25zdCBvdXRwdXQgPSB1dGlscy50eXBlY2FzdCgnc3RyaW5nJywgdmFsdWUsIG9wdHMgPT4ge1xuICAgIGlmICh2YWx1ZS5mb3JtYXQpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZUZvcm1hdCh2YWx1ZSwgKCkgPT4gdGh1bmsob3B0cy5taW5MZW5ndGgsIG9wdHMubWF4TGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnBhdHRlcm4pIHtcbiAgICAgIHJldHVybiByYW5kb20ucmFuZGV4cCh2YWx1ZS5wYXR0ZXJuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGh1bmsob3B0cy5taW5MZW5ndGgsIG9wdHMubWF4TGVuZ3RoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5nVHlwZTtcbiIsImltcG9ydCBfYm9vbGVhbiBmcm9tICcuL2Jvb2xlYW4nO1xuaW1wb3J0IF9udWxsIGZyb20gJy4vbnVsbCc7XG5pbXBvcnQgX2FycmF5IGZyb20gJy4vYXJyYXknO1xuaW1wb3J0IF9pbnRlZ2VyIGZyb20gJy4vaW50ZWdlcic7XG5pbXBvcnQgX251bWJlciBmcm9tICcuL251bWJlcic7XG5pbXBvcnQgX29iamVjdCBmcm9tICcuL29iamVjdCc7XG5pbXBvcnQgX3N0cmluZyBmcm9tICcuL3N0cmluZyc7XG5cbmNvbnN0IHR5cGVNYXAgPSB7XG4gIGJvb2xlYW46IF9ib29sZWFuLFxuICBudWxsOiBfbnVsbCxcbiAgYXJyYXk6IF9hcnJheSxcbiAgaW50ZWdlcjogX2ludGVnZXIsXG4gIG51bWJlcjogX251bWJlcixcbiAgb2JqZWN0OiBfb2JqZWN0LFxuICBzdHJpbmc6IF9zdHJpbmcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlTWFwO1xuIiwiaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHJhbmRvbSBmcm9tICcuL3JhbmRvbSc7XG5pbXBvcnQgUGFyc2VFcnJvciBmcm9tICcuL2Vycm9yJztcbmltcG9ydCBpbmZlclR5cGUgZnJvbSAnLi9pbmZlcic7XG5pbXBvcnQgdHlwZXMgZnJvbSAnLi4vdHlwZXMvaW5kZXgnO1xuaW1wb3J0IG9wdGlvbkFQSSBmcm9tICcuLi9hcGkvb3B0aW9uJztcblxuZnVuY3Rpb24gZ2V0TWV0YSh7ICRjb21tZW50OiBjb21tZW50LCB0aXRsZSwgZGVzY3JpcHRpb24gfSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoeyBjb21tZW50LCB0aXRsZSwgZGVzY3JpcHRpb24gfSlcbiAgICAuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlKVxuICAgIC5yZWR1Y2UoKG1lbW8sIFtrLCB2XSkgPT4ge1xuICAgICAgbWVtb1trXSA9IHY7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSk7XG59XG5cbi8vIFRPRE8gcHJvdmlkZSB0eXBlc1xuZnVuY3Rpb24gdHJhdmVyc2Uoc2NoZW1hLCBwYXRoLCByZXNvbHZlLCByb290U2NoZW1hKSB7XG4gIHNjaGVtYSA9IHJlc29sdmUoc2NoZW1hLCBudWxsLCBwYXRoKTtcblxuICBpZiAoc2NoZW1hICYmIChzY2hlbWEub25lT2YgfHwgc2NoZW1hLmFueU9mIHx8IHNjaGVtYS5hbGxPZikpIHtcbiAgICBzY2hlbWEgPSByZXNvbHZlKHNjaGVtYSwgbnVsbCwgcGF0aCk7XG4gIH1cblxuICBpZiAoIXNjaGVtYSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgLi4uZ2V0TWV0YShzY2hlbWEpLFxuICAgIHNjaGVtYVBhdGg6IHBhdGgsXG4gIH07XG5cbiAgLy8gZGVmYXVsdCB2YWx1ZXMgaGFzIGhpZ2hlciBwcmVjZWRlbmNlXG4gIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gIT09ICdwcm9wZXJ0aWVzJykge1xuICAgIC8vIGV4YW1wbGUgdmFsdWVzIGhhdmUgaGlnaGVzdCBwcmVjZWRlbmNlXG4gICAgaWYgKG9wdGlvbkFQSSgndXNlRXhhbXBsZXNWYWx1ZScpICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmV4YW1wbGVzKSkge1xuICAgICAgLy8gaW5jbHVkZSBgZGVmYXVsdGAgdmFsdWUgYXMgZXhhbXBsZSB0b29cbiAgICAgIGNvbnN0IGZpeGVkRXhhbXBsZXMgPSBzY2hlbWEuZXhhbXBsZXNcbiAgICAgICAgLmNvbmNhdCgnZGVmYXVsdCcgaW4gc2NoZW1hID8gW3NjaGVtYS5kZWZhdWx0XSA6IFtdKTtcblxuICAgICAgcmV0dXJuIHsgdmFsdWU6IHV0aWxzLnR5cGVjYXN0KG51bGwsIHNjaGVtYSwgKCkgPT4gcmFuZG9tLnBpY2soZml4ZWRFeGFtcGxlcykpLCBjb250ZXh0IH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbkFQSSgndXNlRGVmYXVsdFZhbHVlJykgJiYgJ2RlZmF1bHQnIGluIHNjaGVtYSkge1xuICAgICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSAnJyB8fCAhb3B0aW9uQVBJKCdyZXBsYWNlRW1wdHlCeVJhbmRvbVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHNjaGVtYS5kZWZhdWx0LCBjb250ZXh0IH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCd0ZW1wbGF0ZScgaW4gc2NoZW1hKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogdXRpbHMudGVtcGxhdGUoc2NoZW1hLnRlbXBsYXRlLCByb290U2NoZW1hKSwgY29udGV4dCB9O1xuICAgIH1cblxuICAgIGlmICgnY29uc3QnIGluIHNjaGVtYSkge1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IHNjaGVtYS5jb25zdCwgY29udGV4dCB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChzY2hlbWEubm90ICYmIHR5cGVvZiBzY2hlbWEubm90ID09PSAnb2JqZWN0Jykge1xuICAgIHNjaGVtYSA9IHV0aWxzLm5vdFZhbHVlKHNjaGVtYS5ub3QsIHV0aWxzLm9taXRQcm9wcyhzY2hlbWEsIFsnbm90J10pKTtcblxuICAgIC8vIGJ1aWxkIG5ldyBvYmplY3QgdmFsdWUgZnJvbSBub3Qtc2NoZW1hIVxuICAgIGlmIChzY2hlbWEudHlwZSAmJiBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGNvbnRleHQ6IGlubmVyQ29udGV4dCB9ID0gdHJhdmVyc2Uoc2NoZW1hLCBwYXRoLmNvbmNhdChbJ25vdCddKSwgcmVzb2x2ZSwgcm9vdFNjaGVtYSk7XG4gICAgICByZXR1cm4geyB2YWx1ZTogdXRpbHMuY2xlYW4odmFsdWUsIHNjaGVtYSwgZmFsc2UpLCBjb250ZXh0OiB7IC4uLmNvbnRleHQsIGl0ZW1zOiBpbm5lckNvbnRleHQgfSB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIHRodW5rcyBjYW4gcmV0dXJuIHN1Yi1zY2hlbWFzXG4gIGlmICh0eXBlb2Ygc2NoZW1hLnRodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gcmVzdWx0IGlzIGFscmVhZHkgY2xlYW5lZCBpbiB0aHVua1xuICAgIGNvbnN0IHsgdmFsdWUsIGNvbnRleHQ6IGlubmVyQ29udGV4dCB9ID0gdHJhdmVyc2Uoc2NoZW1hLnRodW5rKHJvb3RTY2hlbWEpLCBwYXRoLCByZXNvbHZlKTtcbiAgICByZXR1cm4geyB2YWx1ZSwgY29udGV4dDogeyAuLi5jb250ZXh0LCBpdGVtczogaW5uZXJDb250ZXh0IH0gfTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2NoZW1hLmdlbmVyYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgcmV0dmFsID0gdXRpbHMudHlwZWNhc3QobnVsbCwgc2NoZW1hLCAoKSA9PiBzY2hlbWEuZ2VuZXJhdGUocm9vdFNjaGVtYSwgcGF0aCkpO1xuICAgIGNvbnN0IHR5cGUgPSByZXR2YWwgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmV0dmFsO1xuICAgIGlmICh0eXBlID09PSBzY2hlbWEudHlwZVxuICAgICAgfHwgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpICYmIHNjaGVtYS50eXBlLmluY2x1ZGVzKHR5cGUpKVxuICAgICAgfHwgKHR5cGUgPT09ICdudW1iZXInICYmIHNjaGVtYS50eXBlID09PSAnaW50ZWdlcicpXG4gICAgICB8fCAoQXJyYXkuaXNBcnJheShyZXR2YWwpICYmIHNjaGVtYS50eXBlID09PSAnYXJyYXknKSkge1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IHJldHZhbCwgY29udGV4dCB9O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2NoZW1hLnBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHV0aWxzLnR5cGVjYXN0KCdzdHJpbmcnLCBzY2hlbWEsICgpID0+IHJhbmRvbS5yYW5kZXhwKHNjaGVtYS5wYXR0ZXJuKSksIGNvbnRleHQgfTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1dGlscy50eXBlY2FzdChudWxsLCBzY2hlbWEsICgpID0+IHJhbmRvbS5waWNrKHNjaGVtYS5lbnVtKSksIGNvbnRleHQgfTtcbiAgfVxuXG4gIC8vIHNob3J0LWNpcmN1aXQgYXMgd2UgZG9uJ3QgcGxhbiBnZW5lcmF0ZSBtb3JlIHZhbHVlcyFcbiAgaWYgKHNjaGVtYS5qc29uUGF0aCkge1xuICAgIHJldHVybiB7IHZhbHVlOiBzY2hlbWEsIGNvbnRleHQgfTtcbiAgfVxuXG4gIC8vIFRPRE8gcmVtb3ZlIHRoZSB1Z2x5IG92ZXJjb21lXG4gIGxldCB0eXBlID0gc2NoZW1hLnR5cGU7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICB0eXBlID0gcmFuZG9tLnBpY2sodHlwZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQXR0ZW1wdCB0byBpbmZlciB0aGUgdHlwZVxuICAgIHR5cGUgPSBpbmZlclR5cGUoc2NoZW1hLCBwYXRoKSB8fCB0eXBlO1xuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHNjaGVtYS50eXBlID0gdHlwZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF0eXBlc1t0eXBlXSkge1xuICAgICAgaWYgKG9wdGlvbkFQSSgnZmFpbE9uSW52YWxpZFR5cGVzJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYHVua25vd24gcHJpbWl0aXZlICR7dXRpbHMuc2hvcnQodHlwZSl9YCwgcGF0aC5jb25jYXQoWyd0eXBlJ10pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uQVBJKCdkZWZhdWx0SW52YWxpZFR5cGVQcm9kdWN0Jyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZXNbdmFsdWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHR5cGVzW3ZhbHVlXShzY2hlbWEsIHBhdGgsIHJlc29sdmUsIHRyYXZlcnNlKSwgY29udGV4dCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGNvbnRleHQgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaW5uZXJSZXN1bHQgPSB0eXBlc1t0eXBlXShzY2hlbWEsIHBhdGgsIHJlc29sdmUsIHRyYXZlcnNlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGlubmVyUmVzdWx0Lm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSksXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICAgIGl0ZW1zOiBpbm5lclJlc3VsdC5tYXAoXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpXG4gICAgICAgICAgICAgICAgICA/ICh7IGNvbnRleHQ6IGMgfSkgPT4gY1xuICAgICAgICAgICAgICAgICAgOiAoeyBjb250ZXh0OiBjIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBpbmRleCBmcm9tIHRoZSBwYXRoIHRvIGdldCB0aGUgcmVhbCBzY2hlbWEgcGF0aFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjLnNjaGVtYVBhdGguc2xpY2UoMCwgLTEpLFxuICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpbm5lclJlc3VsdC52YWx1ZSwgY29udGV4dDogeyAuLi5jb250ZXh0LCBpdGVtczogaW5uZXJSZXN1bHQuY29udGV4dCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGlubmVyUmVzdWx0LCBjb250ZXh0IH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZS5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGUuc3RhY2ssIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHZhbHVlQ29weSA9IHt9O1xuICBsZXQgY29udGV4dENvcHkgPSB7IC4uLmNvbnRleHQgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgdmFsdWVDb3B5ID0gW107XG4gIH1cblxuICBjb25zdCBwcnVuZVByb3BlcnRpZXMgPSBvcHRpb25BUEkoJ3BydW5lUHJvcGVydGllcycpIHx8IFtdO1xuXG4gIE9iamVjdC5rZXlzKHNjaGVtYSkuZm9yRWFjaChwcm9wID0+IHtcbiAgICBpZiAocHJ1bmVQcm9wZXJ0aWVzLmluY2x1ZGVzKHByb3ApKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWFbcHJvcF0gPT09ICdvYmplY3QnICYmIHByb3AgIT09ICdkZWZpbml0aW9ucycpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGNvbnRleHQ6IGlubmVyQ29udGV4dCB9ID0gdHJhdmVyc2Uoc2NoZW1hW3Byb3BdLCBwYXRoLmNvbmNhdChbcHJvcF0pLCByZXNvbHZlLCB2YWx1ZUNvcHkpO1xuICAgICAgdmFsdWVDb3B5W3Byb3BdID0gdXRpbHMuY2xlYW4odmFsdWUsIHNjaGVtYVtwcm9wXSwgZmFsc2UpO1xuICAgICAgY29udGV4dENvcHlbcHJvcF0gPSBpbm5lckNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlQ29weVtwcm9wXSA9IHNjaGVtYVtwcm9wXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZUNvcHksIGNvbnRleHQ6IGNvbnRleHRDb3B5IH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRyYXZlcnNlO1xuIiwiaW1wb3J0IG9wdGlvbkFQSSBmcm9tICcuLi9hcGkvb3B0aW9uJztcbmltcG9ydCByYW5kb20gZnJvbSAnLi9yYW5kb20nO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBidWlsZFJlc29sdmVTY2hlbWEgPSAoe1xuICByZWZzLFxuICBzY2hlbWEsXG4gIGNvbnRhaW5lcixcbiAgc3luY2hyb25vdXMsXG4gIHJlZkRlcHRoTWF4LFxuICByZWZEZXB0aE1pbixcbn0pID0+IHtcbiAgY29uc3QgcmVjdXJzaXZlVXRpbCA9IHt9O1xuICBjb25zdCBzZWVuUmVmcyA9IHt9O1xuXG4gIGxldCBkZXB0aCA9IDA7XG4gIGxldCBsYXN0UmVmO1xuICBsZXQgbGFzdFBhdGg7XG5cbiAgcmVjdXJzaXZlVXRpbC5yZXNvbHZlU2NoZW1hID0gKHN1YiwgaW5kZXgsIHJvb3RQYXRoKSA9PiB7XG4gICAgLy8gcHJldmVudCBudWxsIHN1YiBmcm9tIGRlZmF1bHQvZXhhbXBsZSBudWxsIHZhbHVlcyB0byB0aHJvd1xuICAgIGlmIChzdWIgPT09IG51bGwgfHwgc3ViID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3ViLmdlbmVyYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc3ViO1xuICAgIH1cblxuICAgIC8vIGNsZWFudXBcbiAgICBjb25zdCBfaWQgPSBzdWIuJGlkIHx8IHN1Yi5pZDtcblxuICAgIGlmICh0eXBlb2YgX2lkID09PSAnc3RyaW5nJykge1xuICAgICAgZGVsZXRlIHN1Yi5pZDtcbiAgICAgIGRlbGV0ZSBzdWIuJGlkO1xuICAgICAgZGVsZXRlIHN1Yi4kc2NoZW1hO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3ViLiRyZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBtYXhEZXB0aCA9IE1hdGgubWF4KHJlZkRlcHRoTWluLCByZWZEZXB0aE1heCkgLSAxO1xuXG4gICAgICAvLyBpbmNyZWFzaW5nIGRlcHRoIG9ubHkgZm9yIHJlcGVhdGVkIHJlZnMgc2VlbXMgdG8gYmUgZml4aW5nICMyNThcbiAgICAgIGlmIChzdWIuJHJlZiA9PT0gJyMnIHx8IHNlZW5SZWZzW3N1Yi4kcmVmXSA8IDAgfHwgKGxhc3RSZWYgPT09IHN1Yi4kcmVmICYmICsrZGVwdGggPiBtYXhEZXB0aCkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBpZiAoc3ViLiRyZWYgIT09ICcjJyAmJiBsYXN0UGF0aCAmJiBsYXN0UGF0aC5sZW5ndGggPT09IHJvb3RQYXRoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB1dGlscy5nZXRMb2NhbFJlZihzY2hlbWEsIHN1Yi4kcmVmLCBzeW5jaHJvbm91cyAmJiByZWZzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3ViLiRyZWY7XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VlblJlZnNbc3ViLiRyZWZdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWVuUmVmc1tzdWIuJHJlZl0gPSByYW5kb20ubnVtYmVyKHJlZkRlcHRoTWluLCByZWZEZXB0aE1heCkgLSAxO1xuICAgICAgfVxuXG4gICAgICBsYXN0UGF0aCA9IHJvb3RQYXRoO1xuICAgICAgbGFzdFJlZiA9IHN1Yi4kcmVmO1xuXG4gICAgICBsZXQgcmVmO1xuXG4gICAgICBpZiAoc3ViLiRyZWYuaW5kZXhPZignIy8nKSA9PT0gLTEpIHtcbiAgICAgICAgcmVmID0gcmVmc1tzdWIuJHJlZl0gfHwgbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZiA9IHV0aWxzLmdldExvY2FsUmVmKHNjaGVtYSwgc3ViLiRyZWYsIHN5bmNocm9ub3VzICYmIHJlZnMpIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGxldCBmaXhlZDtcbiAgICAgIGlmICh0eXBlb2YgcmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIXJlZiAmJiBvcHRpb25BUEkoJ2lnbm9yZU1pc3NpbmdSZWZzJykgIT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZmVyZW5jZSBub3QgZm91bmQ6ICR7c3ViLiRyZWZ9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWVuUmVmc1tzdWIuJHJlZl0gLT0gMTtcbiAgICAgICAgdXRpbHMubWVyZ2Uoc3ViLCByZWYgfHwge30pO1xuICAgICAgICBmaXhlZCA9IHN5bmNocm9ub3VzICYmIHJlZiAmJiByZWYuJHJlZjtcbiAgICAgIH1cblxuICAgICAgLy8ganVzdCByZW1vdmUgdGhlIHJlZmVyZW5jZVxuICAgICAgaWYgKCFmaXhlZCkgZGVsZXRlIHN1Yi4kcmVmO1xuICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWIuYWxsT2YpKSB7XG4gICAgICBjb25zdCBzY2hlbWFzID0gc3ViLmFsbE9mO1xuXG4gICAgICBkZWxldGUgc3ViLmFsbE9mO1xuXG4gICAgICAvLyB0aGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgYWxsIHN1Yi1zY2hlbWFzXG4gICAgICAvLyBtdXN0IGJlIHJlc29sdmVkIGJlZm9yZSBhbnkgbWVyZ2VcbiAgICAgIHNjaGVtYXMuZm9yRWFjaChzdWJTY2hlbWEgPT4ge1xuICAgICAgICBjb25zdCBfc3ViID0gcmVjdXJzaXZlVXRpbC5yZXNvbHZlU2NoZW1hKHN1YlNjaGVtYSwgbnVsbCwgcm9vdFBhdGgpO1xuXG4gICAgICAgIC8vIGNhbGwgZ2l2ZW4gdGh1bmtzIGlmIHByZXNlbnRcbiAgICAgICAgdXRpbHMubWVyZ2Uoc3ViLCB0eXBlb2YgX3N1Yi50aHVuayA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gX3N1Yi50aHVuayhzdWIpXG4gICAgICAgICAgOiBfc3ViKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViLmFsbE9mKSkge1xuICAgICAgICAgIHJlY3Vyc2l2ZVV0aWwucmVzb2x2ZVNjaGVtYShzdWIsIGluZGV4LCByb290UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1Yi5vbmVPZiB8fCBzdWIuYW55T2YpKSB7XG4gICAgICBjb25zdCBtaXggPSBzdWIub25lT2YgfHwgc3ViLmFueU9mO1xuXG4gICAgICAvLyB0ZXN0IGV2ZXJ5IHZhbHVlIGZyb20gdGhlIGVudW0gYWdhaW5zdCBlYWNoLW9uZU9mXG4gICAgICAvLyBzY2hlbWEsIG9ubHkgdmFsdWVzIHRoYXQgdmFsaWRhdGUgb25jZSBhcmUga2VwdFxuICAgICAgaWYgKHN1Yi5lbnVtICYmIHN1Yi5vbmVPZikge1xuICAgICAgICBzdWIuZW51bSA9IHN1Yi5lbnVtLmZpbHRlcih4ID0+IHV0aWxzLnZhbGlkYXRlKHgsIG1peCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHVuayhyb290U2NoZW1hKSB7XG4gICAgICAgICAgY29uc3QgY29weSA9IHV0aWxzLm9taXRQcm9wcyhzdWIsIFsnYW55T2YnLCAnb25lT2YnXSk7XG4gICAgICAgICAgY29uc3QgZml4ZWQgPSByYW5kb20ucGljayhtaXgpO1xuXG4gICAgICAgICAgdXRpbHMubWVyZ2UoY29weSwgZml4ZWQpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBmcm9tIG1lcmdlZCBzY2hlbWFzXG4gICAgICAgICAgbWl4LmZvckVhY2gob21pdCA9PiB7XG4gICAgICAgICAgICBpZiAob21pdC5yZXF1aXJlZCAmJiBvbWl0ICE9PSBmaXhlZCkge1xuICAgICAgICAgICAgICBvbWl0LnJlcXVpcmVkLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNsdWRlc0tleSA9IGNvcHkucmVxdWlyZWQgJiYgY29weS5yZXF1aXJlZC5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChjb3B5LnByb3BlcnRpZXMgJiYgIWluY2x1ZGVzS2V5KSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgY29weS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RTY2hlbWEgJiYgcm9vdFNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFNjaGVtYS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhzdWIpLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBpZiAoKEFycmF5LmlzQXJyYXkoc3ViW3Byb3BdKSB8fCB0eXBlb2Ygc3ViW3Byb3BdID09PSAnb2JqZWN0JykgJiYgIXV0aWxzLmlzS2V5KHByb3ApKSB7XG4gICAgICAgIHN1Yltwcm9wXSA9IHJlY3Vyc2l2ZVV0aWwucmVzb2x2ZVNjaGVtYShzdWJbcHJvcF0sIHByb3AsIHJvb3RQYXRoLmNvbmNhdChwcm9wKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhdm9pZCBleHRyYSBjYWxscyBvbiBzdWItc2NoZW1hcywgZml4ZXMgIzQ1OFxuICAgIGlmIChyb290UGF0aCkge1xuICAgICAgY29uc3QgbGFzdFByb3AgPSByb290UGF0aFtyb290UGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKGxhc3RQcm9wID09PSAncHJvcGVydGllcycgfHwgbGFzdFByb3AgPT09ICdpdGVtcycpIHtcbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyLndyYXAoc3ViKTtcbiAgfTtcblxuICByZXR1cm4gcmVjdXJzaXZlVXRpbDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkUmVzb2x2ZVNjaGVtYTtcbiIsImltcG9ydCB7IGdldERlcGVuZGVuY2llcyB9IGZyb20gJy4uL3ZlbmRvcic7XG5pbXBvcnQgb3B0aW9uQVBJIGZyb20gJy4uL2FwaS9vcHRpb24nO1xuaW1wb3J0IHRyYXZlcnNlIGZyb20gJy4vdHJhdmVyc2UnO1xuaW1wb3J0IHJhbmRvbSBmcm9tICcuL3JhbmRvbSc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYnVpbGRSZXNvbHZlU2NoZW1hIGZyb20gJy4vYnVpbGRSZXNvbHZlU2NoZW1hJztcblxuZnVuY3Rpb24gcGljayhkYXRhKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpXG4gICAgPyByYW5kb20ucGljayhkYXRhKVxuICAgIDogZGF0YTtcbn1cblxuZnVuY3Rpb24gY3ljbGUoZGF0YSwgcmV2ZXJzZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gcmV2ZXJzZVxuICAgID8gZGF0YS5wb3AoKVxuICAgIDogZGF0YS5zaGlmdCgpO1xuXG4gIGlmIChyZXZlcnNlKSB7XG4gICAgZGF0YS51bnNoaWZ0KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKG9iaiwgZGF0YSwgdmFsdWVzLCBwcm9wZXJ0eSkge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoIXZhbHVlcykge1xuICAgIHZhbHVlcyA9IHt9O1xuICB9XG5cbiAgaWYgKCFkYXRhKSB7XG4gICAgZGF0YSA9IG9iajtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcCh4ID0+IHJlc29sdmUoeCwgZGF0YSwgdmFsdWVzLCBwcm9wZXJ0eSkpO1xuICB9XG5cbiAgaWYgKG9iai5qc29uUGF0aCkge1xuICAgIGNvbnN0IHsgSlNPTlBhdGggfSA9IGdldERlcGVuZGVuY2llcygpO1xuXG4gICAgY29uc3QgcGFyYW1zID0gdHlwZW9mIG9iai5qc29uUGF0aCAhPT0gJ29iamVjdCdcbiAgICAgID8geyBwYXRoOiBvYmouanNvblBhdGggfVxuICAgICAgOiBvYmouanNvblBhdGg7XG5cbiAgICBwYXJhbXMuZ3JvdXAgPSBvYmouZ3JvdXAgfHwgcGFyYW1zLmdyb3VwIHx8IHByb3BlcnR5O1xuICAgIHBhcmFtcy5jeWNsZSA9IG9iai5jeWNsZSB8fCBwYXJhbXMuY3ljbGUgfHwgZmFsc2U7XG4gICAgcGFyYW1zLnJldmVyc2UgPSBvYmoucmV2ZXJzZSB8fCBwYXJhbXMucmV2ZXJzZSB8fCBmYWxzZTtcbiAgICBwYXJhbXMuY291bnQgPSBvYmouY291bnQgfHwgcGFyYW1zLmNvdW50IHx8IDE7XG5cbiAgICBjb25zdCBrZXkgPSBgJHtwYXJhbXMuZ3JvdXB9X18ke3BhcmFtcy5wYXRofWA7XG5cbiAgICBpZiAoIXZhbHVlc1trZXldKSB7XG4gICAgICBpZiAocGFyYW1zLmNvdW50ID4gMSkge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IEpTT05QYXRoKHBhcmFtcy5wYXRoLCBkYXRhKS5zbGljZSgwLCBwYXJhbXMuY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzW2tleV0gPSBKU09OUGF0aChwYXJhbXMucGF0aCwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5jeWNsZSB8fCBwYXJhbXMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIGN5Y2xlKHZhbHVlc1trZXldLCBwYXJhbXMucmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBpY2sodmFsdWVzW2tleV0pO1xuICB9XG5cbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGsgPT4ge1xuICAgIG9ialtrXSA9IHJlc29sdmUob2JqW2tdLCBkYXRhLCB2YWx1ZXMsIGspO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBUT0RPIHByb3ZpZGUgdHlwZXM/XG5mdW5jdGlvbiBydW4ocmVmcywgc2NoZW1hLCBjb250YWluZXIsIHN5bmNocm9ub3VzKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2NoZW1hKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW5wdXQsIGV4cGVjdGluZyBvYmplY3QgYnV0IGdpdmVuICR7dHlwZW9mIHNjaGVtYX1gKTtcbiAgfVxuXG4gIGNvbnN0IHJlZkRlcHRoTWluID0gb3B0aW9uQVBJKCdyZWZEZXB0aE1pbicpIHx8IDA7XG4gIGNvbnN0IHJlZkRlcHRoTWF4ID0gb3B0aW9uQVBJKCdyZWZEZXB0aE1heCcpIHx8IDM7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IHJlc29sdmVTY2hlbWEgfSA9IGJ1aWxkUmVzb2x2ZVNjaGVtYSh7XG4gICAgICByZWZzLFxuICAgICAgc2NoZW1hLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgc3luY2hyb25vdXMsXG4gICAgICByZWZEZXB0aE1pbixcbiAgICAgIHJlZkRlcHRoTWF4LFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYXZlcnNlKHV0aWxzLmNsb25lKHNjaGVtYSksIFtdLCByZXNvbHZlU2NoZW1hKTtcblxuICAgIGlmIChvcHRpb25BUEkoJ3Jlc29sdmVKc29uUGF0aCcpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcmVzb2x2ZShyZXN1bHQudmFsdWUpLFxuICAgICAgICBjb250ZXh0OiByZXN1bHQuY29udGV4dCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLnBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlLm1lc3NhZ2V9IGluIC8ke2UucGF0aC5qb2luKCcvJyl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJ1bjtcbiIsImZ1bmN0aW9uIHJlbmRlckpTKHJlcykge1xuICByZXR1cm4gcmVzLnZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJKUztcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2hhciA9IHtcbiAgQU5DSE9SOiAnJicsXG4gIENPTU1FTlQ6ICcjJyxcbiAgVEFHOiAnIScsXG4gIERJUkVDVElWRVNfRU5EOiAnLScsXG4gIERPQ1VNRU5UX0VORDogJy4nXG59O1xuY29uc3QgVHlwZSA9IHtcbiAgQUxJQVM6ICdBTElBUycsXG4gIEJMQU5LX0xJTkU6ICdCTEFOS19MSU5FJyxcbiAgQkxPQ0tfRk9MREVEOiAnQkxPQ0tfRk9MREVEJyxcbiAgQkxPQ0tfTElURVJBTDogJ0JMT0NLX0xJVEVSQUwnLFxuICBDT01NRU5UOiAnQ09NTUVOVCcsXG4gIERJUkVDVElWRTogJ0RJUkVDVElWRScsXG4gIERPQ1VNRU5UOiAnRE9DVU1FTlQnLFxuICBGTE9XX01BUDogJ0ZMT1dfTUFQJyxcbiAgRkxPV19TRVE6ICdGTE9XX1NFUScsXG4gIE1BUDogJ01BUCcsXG4gIE1BUF9LRVk6ICdNQVBfS0VZJyxcbiAgTUFQX1ZBTFVFOiAnTUFQX1ZBTFVFJyxcbiAgUExBSU46ICdQTEFJTicsXG4gIFFVT1RFX0RPVUJMRTogJ1FVT1RFX0RPVUJMRScsXG4gIFFVT1RFX1NJTkdMRTogJ1FVT1RFX1NJTkdMRScsXG4gIFNFUTogJ1NFUScsXG4gIFNFUV9JVEVNOiAnU0VRX0lURU0nXG59O1xuY29uc3QgZGVmYXVsdFRhZ1ByZWZpeCA9ICd0YWc6eWFtbC5vcmcsMjAwMjonO1xuY29uc3QgZGVmYXVsdFRhZ3MgPSB7XG4gIE1BUDogJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsXG4gIFNFUTogJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsXG4gIFNUUjogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cidcbn07XG5cbmZ1bmN0aW9uIGZpbmRMaW5lU3RhcnRzKHNyYykge1xuICBjb25zdCBscyA9IFswXTtcbiAgbGV0IG9mZnNldCA9IHNyYy5pbmRleE9mKCdcXG4nKTtcblxuICB3aGlsZSAob2Zmc2V0ICE9PSAtMSkge1xuICAgIG9mZnNldCArPSAxO1xuICAgIGxzLnB1c2gob2Zmc2V0KTtcbiAgICBvZmZzZXQgPSBzcmMuaW5kZXhPZignXFxuJywgb2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiBscztcbn1cblxuZnVuY3Rpb24gZ2V0U3JjSW5mbyhjc3QpIHtcbiAgbGV0IGxpbmVTdGFydHMsIHNyYztcblxuICBpZiAodHlwZW9mIGNzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBsaW5lU3RhcnRzID0gZmluZExpbmVTdGFydHMoY3N0KTtcbiAgICBzcmMgPSBjc3Q7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3N0KSkgY3N0ID0gY3N0WzBdO1xuXG4gICAgaWYgKGNzdCAmJiBjc3QuY29udGV4dCkge1xuICAgICAgaWYgKCFjc3QubGluZVN0YXJ0cykgY3N0LmxpbmVTdGFydHMgPSBmaW5kTGluZVN0YXJ0cyhjc3QuY29udGV4dC5zcmMpO1xuICAgICAgbGluZVN0YXJ0cyA9IGNzdC5saW5lU3RhcnRzO1xuICAgICAgc3JjID0gY3N0LmNvbnRleHQuc3JjO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGluZVN0YXJ0cyxcbiAgICBzcmNcbiAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTGluZVBvcyAtIE9uZS1pbmRleGVkIHBvc2l0aW9uIGluIHRoZSBzb3VyY2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29sXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGxpbmUvY29sIHBvc2l0aW9uIG1hdGNoaW5nIGEgY2hhcmFjdGVyIG9mZnNldC5cbiAqXG4gKiBBY2NlcHRzIGEgc291cmNlIHN0cmluZyBvciBhIENTVCBkb2N1bWVudCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci4gV2l0aFxuICogdGhlIGxhdHRlciwgc3RhcnRpbmcgaW5kaWNlcyBmb3IgbGluZXMgYXJlIGNhY2hlZCBpbiB0aGUgZG9jdW1lbnQgYXNcbiAqIGBsaW5lU3RhcnRzOiBudW1iZXJbXWAuXG4gKlxuICogUmV0dXJucyBhIG9uZS1pbmRleGVkIGB7IGxpbmUsIGNvbCB9YCBsb2NhdGlvbiBpZiBmb3VuZCwgb3JcbiAqIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ3xEb2N1bWVudHxEb2N1bWVudFtdfSBjc3RcbiAqIEByZXR1cm5zIHs/TGluZVBvc31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpbmVQb3Mob2Zmc2V0LCBjc3QpIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCA8IDApIHJldHVybiBudWxsO1xuICBjb25zdCB7XG4gICAgbGluZVN0YXJ0cyxcbiAgICBzcmNcbiAgfSA9IGdldFNyY0luZm8oY3N0KTtcbiAgaWYgKCFsaW5lU3RhcnRzIHx8ICFzcmMgfHwgb2Zmc2V0ID4gc3JjLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lU3RhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBsaW5lU3RhcnRzW2ldO1xuXG4gICAgaWYgKG9mZnNldCA8IHN0YXJ0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBpLFxuICAgICAgICBjb2w6IG9mZnNldCAtIGxpbmVTdGFydHNbaSAtIDFdICsgMVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID09PSBzdGFydCkgcmV0dXJuIHtcbiAgICAgIGxpbmU6IGkgKyAxLFxuICAgICAgY29sOiAxXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGxpbmUgPSBsaW5lU3RhcnRzLmxlbmd0aDtcbiAgcmV0dXJuIHtcbiAgICBsaW5lLFxuICAgIGNvbDogb2Zmc2V0IC0gbGluZVN0YXJ0c1tsaW5lIC0gMV0gKyAxXG4gIH07XG59XG4vKipcbiAqIEdldCBhIHNwZWNpZmllZCBsaW5lIGZyb20gdGhlIHNvdXJjZS5cbiAqXG4gKiBBY2NlcHRzIGEgc291cmNlIHN0cmluZyBvciBhIENTVCBkb2N1bWVudCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci4gV2l0aFxuICogdGhlIGxhdHRlciwgc3RhcnRpbmcgaW5kaWNlcyBmb3IgbGluZXMgYXJlIGNhY2hlZCBpbiB0aGUgZG9jdW1lbnQgYXNcbiAqIGBsaW5lU3RhcnRzOiBudW1iZXJbXWAuXG4gKlxuICogUmV0dXJucyB0aGUgbGluZSBhcyBhIHN0cmluZyBpZiBmb3VuZCwgb3IgYG51bGxgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGluZSBPbmUtaW5kZXhlZCBsaW5lIG51bWJlclxuICogQHBhcmFtIHtzdHJpbmd8RG9jdW1lbnR8RG9jdW1lbnRbXX0gY3N0XG4gKiBAcmV0dXJucyB7P3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRMaW5lKGxpbmUsIGNzdCkge1xuICBjb25zdCB7XG4gICAgbGluZVN0YXJ0cyxcbiAgICBzcmNcbiAgfSA9IGdldFNyY0luZm8oY3N0KTtcbiAgaWYgKCFsaW5lU3RhcnRzIHx8ICEobGluZSA+PSAxKSB8fCBsaW5lID4gbGluZVN0YXJ0cy5sZW5ndGgpIHJldHVybiBudWxsO1xuICBjb25zdCBzdGFydCA9IGxpbmVTdGFydHNbbGluZSAtIDFdO1xuICBsZXQgZW5kID0gbGluZVN0YXJ0c1tsaW5lXTsgLy8gdW5kZWZpbmVkIGZvciBsYXN0IGxpbmU7IHRoYXQncyBvayBmb3Igc2xpY2UoKVxuXG4gIHdoaWxlIChlbmQgJiYgZW5kID4gc3RhcnQgJiYgc3JjW2VuZCAtIDFdID09PSAnXFxuJykgLS1lbmQ7XG5cbiAgcmV0dXJuIHNyYy5zbGljZShzdGFydCwgZW5kKTtcbn1cbi8qKlxuICogUHJldHR5LXByaW50IHRoZSBzdGFydGluZyBsaW5lIGZyb20gdGhlIHNvdXJjZSBpbmRpY2F0ZWQgYnkgdGhlIHJhbmdlIGBwb3NgXG4gKlxuICogVHJpbXMgb3V0cHV0IHRvIGBtYXhXaWR0aGAgY2hhcnMgd2hpbGUga2VlcGluZyB0aGUgc3RhcnRpbmcgY29sdW1uIHZpc2libGUsXG4gKiB1c2luZyBg4oCmYCBhdCBlaXRoZXIgZW5kIHRvIGluZGljYXRlIGRyb3BwZWQgY2hhcmFjdGVycy5cbiAqXG4gKiBSZXR1cm5zIGEgdHdvLWxpbmUgc3RyaW5nIChvciBgbnVsbGApIHdpdGggYFxcbmAgYXMgc2VwYXJhdG9yOyB0aGUgc2Vjb25kIGxpbmVcbiAqIHdpbGwgaG9sZCBhcHByb3ByaWF0ZWx5IGluZGVudGVkIGBeYCBtYXJrcyBpbmRpY2F0aW5nIHRoZSBjb2x1bW4gcmFuZ2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICogQHBhcmFtIHtMaW5lUG9zfSBwb3Muc3RhcnRcbiAqIEBwYXJhbSB7TGluZVBvc30gW3Bvcy5lbmRdXG4gKiBAcGFyYW0ge3N0cmluZ3xEb2N1bWVudHxEb2N1bWVudFtdKn0gY3N0XG4gKiBAcGFyYW0ge251bWJlcn0gW21heFdpZHRoPTgwXVxuICogQHJldHVybnMgez9zdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0UHJldHR5Q29udGV4dCh7XG4gIHN0YXJ0LFxuICBlbmRcbn0sIGNzdCwgbWF4V2lkdGggPSA4MCkge1xuICBsZXQgc3JjID0gZ2V0TGluZShzdGFydC5saW5lLCBjc3QpO1xuICBpZiAoIXNyYykgcmV0dXJuIG51bGw7XG4gIGxldCB7XG4gICAgY29sXG4gIH0gPSBzdGFydDtcblxuICBpZiAoc3JjLmxlbmd0aCA+IG1heFdpZHRoKSB7XG4gICAgaWYgKGNvbCA8PSBtYXhXaWR0aCAtIDEwKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyKDAsIG1heFdpZHRoIC0gMSkgKyAn4oCmJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFsZldpZHRoID0gTWF0aC5yb3VuZChtYXhXaWR0aCAvIDIpO1xuICAgICAgaWYgKHNyYy5sZW5ndGggPiBjb2wgKyBoYWxmV2lkdGgpIHNyYyA9IHNyYy5zdWJzdHIoMCwgY29sICsgaGFsZldpZHRoIC0gMSkgKyAn4oCmJztcbiAgICAgIGNvbCAtPSBzcmMubGVuZ3RoIC0gbWF4V2lkdGg7XG4gICAgICBzcmMgPSAn4oCmJyArIHNyYy5zdWJzdHIoMSAtIG1heFdpZHRoKTtcbiAgICB9XG4gIH1cblxuICBsZXQgZXJyTGVuID0gMTtcbiAgbGV0IGVyckVuZCA9ICcnO1xuXG4gIGlmIChlbmQpIHtcbiAgICBpZiAoZW5kLmxpbmUgPT09IHN0YXJ0LmxpbmUgJiYgY29sICsgKGVuZC5jb2wgLSBzdGFydC5jb2wpIDw9IG1heFdpZHRoICsgMSkge1xuICAgICAgZXJyTGVuID0gZW5kLmNvbCAtIHN0YXJ0LmNvbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyTGVuID0gTWF0aC5taW4oc3JjLmxlbmd0aCArIDEsIG1heFdpZHRoKSAtIGNvbDtcbiAgICAgIGVyckVuZCA9ICfigKYnO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9mZnNldCA9IGNvbCA+IDEgPyAnICcucmVwZWF0KGNvbCAtIDEpIDogJyc7XG4gIGNvbnN0IGVyciA9ICdeJy5yZXBlYXQoZXJyTGVuKTtcbiAgcmV0dXJuIGAke3NyY31cXG4ke29mZnNldH0ke2Vycn0ke2VyckVuZH1gO1xufVxuXG5jbGFzcyBSYW5nZSB7XG4gIHN0YXRpYyBjb3B5KG9yaWcpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKG9yaWcuc3RhcnQsIG9yaWcuZW5kKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQgfHwgc3RhcnQ7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5zdGFydCAhPT0gJ251bWJlcicgfHwgIXRoaXMuZW5kIHx8IHRoaXMuZW5kIDw9IHRoaXMuc3RhcnQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBgb3JpZ1N0YXJ0YCBhbmQgYG9yaWdFbmRgIHRvIHBvaW50IHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgcmFuZ2UgZm9yXG4gICAqIHRoaXMgbm9kZSwgd2hpY2ggbWF5IGRpZmZlciBkdWUgdG8gZHJvcHBlZCBDUiBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBjciAtIFBvc2l0aW9ucyBvZiBkcm9wcGVkIENSIGNoYXJhY3RlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFN0YXJ0aW5nIGluZGV4IG9mIGBjcmAgZnJvbSB0aGUgbGFzdCBjYWxsXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIG5leHQgb2Zmc2V0LCBtYXRjaGluZyB0aGUgb25lIGZvdW5kIGZvciBgb3JpZ1N0YXJ0YFxuICAgKi9cblxuXG4gIHNldE9yaWdSYW5nZShjciwgb2Zmc2V0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChjci5sZW5ndGggPT09IDAgfHwgZW5kIDw9IGNyWzBdKSB7XG4gICAgICB0aGlzLm9yaWdTdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5vcmlnRW5kID0gZW5kO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBsZXQgaSA9IG9mZnNldDtcblxuICAgIHdoaWxlIChpIDwgY3IubGVuZ3RoKSB7XG4gICAgICBpZiAoY3JbaV0gPiBzdGFydCkgYnJlYWs7ZWxzZSArK2k7XG4gICAgfVxuXG4gICAgdGhpcy5vcmlnU3RhcnQgPSBzdGFydCArIGk7XG4gICAgY29uc3QgbmV4dE9mZnNldCA9IGk7XG5cbiAgICB3aGlsZSAoaSA8IGNyLmxlbmd0aCkge1xuICAgICAgLy8gaWYgZW5kIHdhcyBhdCBcXG4sIGl0IHNob3VsZCBub3cgYmUgYXQgXFxyXG4gICAgICBpZiAoY3JbaV0gPj0gZW5kKSBicmVhaztlbHNlICsraTtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdFbmQgPSBlbmQgKyBpO1xuICAgIHJldHVybiBuZXh0T2Zmc2V0O1xuICB9XG5cbn1cblxuLyoqIFJvb3QgY2xhc3Mgb2YgYWxsIG5vZGVzICovXG5cbmNsYXNzIE5vZGUge1xuICBzdGF0aWMgYWRkU3RyaW5nVGVybWluYXRvcihzcmMsIG9mZnNldCwgc3RyKSB7XG4gICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSByZXR1cm4gc3RyO1xuICAgIGNvbnN0IG5leHQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgcmV0dXJuIG5leHQgPj0gc3JjLmxlbmd0aCB8fCBzcmNbbmV4dF0gPT09ICdcXG4nID8gc3RyICsgJ1xcbicgOiBzdHI7XG4gIH0gLy8gXigtLS18Li4uKVxuXG5cbiAgc3RhdGljIGF0RG9jdW1lbnRCb3VuZGFyeShzcmMsIG9mZnNldCwgc2VwKSB7XG4gICAgY29uc3QgY2gwID0gc3JjW29mZnNldF07XG4gICAgaWYgKCFjaDApIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHByZXYgPSBzcmNbb2Zmc2V0IC0gMV07XG4gICAgaWYgKHByZXYgJiYgcHJldiAhPT0gJ1xcbicpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChzZXApIHtcbiAgICAgIGlmIChjaDAgIT09IHNlcCkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2gwICE9PSBDaGFyLkRJUkVDVElWRVNfRU5EICYmIGNoMCAhPT0gQ2hhci5ET0NVTUVOVF9FTkQpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBjaDEgPSBzcmNbb2Zmc2V0ICsgMV07XG4gICAgY29uc3QgY2gyID0gc3JjW29mZnNldCArIDJdO1xuICAgIGlmIChjaDEgIT09IGNoMCB8fCBjaDIgIT09IGNoMCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGNoMyA9IHNyY1tvZmZzZXQgKyAzXTtcbiAgICByZXR1cm4gIWNoMyB8fCBjaDMgPT09ICdcXG4nIHx8IGNoMyA9PT0gJ1xcdCcgfHwgY2gzID09PSAnICc7XG4gIH1cblxuICBzdGF0aWMgZW5kT2ZJZGVudGlmaWVyKHNyYywgb2Zmc2V0KSB7XG4gICAgbGV0IGNoID0gc3JjW29mZnNldF07XG4gICAgY29uc3QgaXNWZXJiYXRpbSA9IGNoID09PSAnPCc7XG4gICAgY29uc3Qgbm90T2sgPSBpc1ZlcmJhdGltID8gWydcXG4nLCAnXFx0JywgJyAnLCAnPiddIDogWydcXG4nLCAnXFx0JywgJyAnLCAnWycsICddJywgJ3snLCAnfScsICcsJ107XG5cbiAgICB3aGlsZSAoY2ggJiYgbm90T2suaW5kZXhPZihjaCkgPT09IC0xKSBjaCA9IHNyY1tvZmZzZXQgKz0gMV07XG5cbiAgICBpZiAoaXNWZXJiYXRpbSAmJiBjaCA9PT0gJz4nKSBvZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGljIGVuZE9mSW5kZW50KHNyYywgb2Zmc2V0KSB7XG4gICAgbGV0IGNoID0gc3JjW29mZnNldF07XG5cbiAgICB3aGlsZSAoY2ggPT09ICcgJykgY2ggPSBzcmNbb2Zmc2V0ICs9IDFdO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHN0YXRpYyBlbmRPZkxpbmUoc3JjLCBvZmZzZXQpIHtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0XTtcblxuICAgIHdoaWxlIChjaCAmJiBjaCAhPT0gJ1xcbicpIGNoID0gc3JjW29mZnNldCArPSAxXTtcblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBzdGF0aWMgZW5kT2ZXaGl0ZVNwYWNlKHNyYywgb2Zmc2V0KSB7XG4gICAgbGV0IGNoID0gc3JjW29mZnNldF07XG5cbiAgICB3aGlsZSAoY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcpIGNoID0gc3JjW29mZnNldCArPSAxXTtcblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBzdGF0aWMgc3RhcnRPZkxpbmUoc3JjLCBvZmZzZXQpIHtcbiAgICBsZXQgY2ggPSBzcmNbb2Zmc2V0IC0gMV07XG4gICAgaWYgKGNoID09PSAnXFxuJykgcmV0dXJuIG9mZnNldDtcblxuICAgIHdoaWxlIChjaCAmJiBjaCAhPT0gJ1xcbicpIGNoID0gc3JjW29mZnNldCAtPSAxXTtcblxuICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICB9XG4gIC8qKlxuICAgKiBFbmQgb2YgaW5kZW50YXRpb24sIG9yIG51bGwgaWYgdGhlIGxpbmUncyBpbmRlbnQgbGV2ZWwgaXMgbm90IG1vcmVcbiAgICogdGhhbiBgaW5kZW50YFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRlbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVTdGFydFxuICAgKiBAcmV0dXJucyB7P251bWJlcn1cbiAgICovXG5cblxuICBzdGF0aWMgZW5kT2ZCbG9ja0luZGVudChzcmMsIGluZGVudCwgbGluZVN0YXJ0KSB7XG4gICAgY29uc3QgaW5FbmQgPSBOb2RlLmVuZE9mSW5kZW50KHNyYywgbGluZVN0YXJ0KTtcblxuICAgIGlmIChpbkVuZCA+IGxpbmVTdGFydCArIGluZGVudCkge1xuICAgICAgcmV0dXJuIGluRW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3c0VuZCA9IE5vZGUuZW5kT2ZXaGl0ZVNwYWNlKHNyYywgaW5FbmQpO1xuICAgICAgY29uc3QgY2ggPSBzcmNbd3NFbmRdO1xuICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcbicpIHJldHVybiB3c0VuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBhdEJsYW5rKHNyYywgb2Zmc2V0LCBlbmRBc0JsYW5rKSB7XG4gICAgY29uc3QgY2ggPSBzcmNbb2Zmc2V0XTtcbiAgICByZXR1cm4gY2ggPT09ICdcXG4nIHx8IGNoID09PSAnXFx0JyB8fCBjaCA9PT0gJyAnIHx8IGVuZEFzQmxhbmsgJiYgIWNoO1xuICB9XG5cbiAgc3RhdGljIG5leHROb2RlSXNJbmRlbnRlZChjaCwgaW5kZW50RGlmZiwgaW5kaWNhdG9yQXNJbmRlbnQpIHtcbiAgICBpZiAoIWNoIHx8IGluZGVudERpZmYgPCAwKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGluZGVudERpZmYgPiAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gaW5kaWNhdG9yQXNJbmRlbnQgJiYgY2ggPT09ICctJztcbiAgfSAvLyBzaG91bGQgYmUgYXQgbGluZSBvciBzdHJpbmcgZW5kLCBvciBhdCBuZXh0IG5vbi13aGl0ZXNwYWNlIGNoYXJcblxuXG4gIHN0YXRpYyBub3JtYWxpemVPZmZzZXQoc3JjLCBvZmZzZXQpIHtcbiAgICBjb25zdCBjaCA9IHNyY1tvZmZzZXRdO1xuICAgIHJldHVybiAhY2ggPyBvZmZzZXQgOiBjaCAhPT0gJ1xcbicgJiYgc3JjW29mZnNldCAtIDFdID09PSAnXFxuJyA/IG9mZnNldCAtIDEgOiBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gIH0gLy8gZm9sZCBzaW5nbGUgbmV3bGluZSBpbnRvIHNwYWNlLCBtdWx0aXBsZSBuZXdsaW5lcyB0byBOIC0gMSBuZXdsaW5lc1xuICAvLyBwcmVzdW1lcyBzcmNbb2Zmc2V0XSA9PT0gJ1xcbidcblxuXG4gIHN0YXRpYyBmb2xkTmV3bGluZShzcmMsIG9mZnNldCwgaW5kZW50KSB7XG4gICAgbGV0IGluQ291bnQgPSAwO1xuICAgIGxldCBlcnJvciA9IGZhbHNlO1xuICAgIGxldCBmb2xkID0gJyc7XG4gICAgbGV0IGNoID0gc3JjW29mZnNldCArIDFdO1xuXG4gICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnXFxuJykge1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgIGluQ291bnQgPSAwO1xuICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgIGZvbGQgKz0gJ1xcbic7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICBpZiAoaW5Db3VudCA8PSBpbmRlbnQpIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCArIDIpIC0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICBpbkNvdW50ICs9IDE7XG4gICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3JjW29mZnNldCArIDFdO1xuICAgIH1cblxuICAgIGlmICghZm9sZCkgZm9sZCA9ICcgJztcbiAgICBpZiAoY2ggJiYgaW5Db3VudCA8PSBpbmRlbnQpIGVycm9yID0gdHJ1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9sZCxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb250ZXh0Jywge1xuICAgICAgdmFsdWU6IGNvbnRleHQgfHwgbnVsbCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgdGhpcy5yYW5nZSA9IG51bGw7XG4gICAgdGhpcy52YWx1ZVJhbmdlID0gbnVsbDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHMgfHwgW107XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgfVxuXG4gIGdldFByb3BWYWx1ZShpZHgsIGtleSwgc2tpcEtleSkge1xuICAgIGlmICghdGhpcy5jb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB7XG4gICAgICBzcmNcbiAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLnByb3BzW2lkeF07XG4gICAgcmV0dXJuIHByb3AgJiYgc3JjW3Byb3Auc3RhcnRdID09PSBrZXkgPyBzcmMuc2xpY2UocHJvcC5zdGFydCArIChza2lwS2V5ID8gMSA6IDApLCBwcm9wLmVuZCkgOiBudWxsO1xuICB9XG5cbiAgZ2V0IGFuY2hvcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuZ2V0UHJvcFZhbHVlKGksIENoYXIuQU5DSE9SLCB0cnVlKTtcbiAgICAgIGlmIChhbmNob3IgIT0gbnVsbCkgcmV0dXJuIGFuY2hvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBjb21tZW50KCkge1xuICAgIGNvbnN0IGNvbW1lbnRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLmdldFByb3BWYWx1ZShpLCBDaGFyLkNPTU1FTlQsIHRydWUpO1xuICAgICAgaWYgKGNvbW1lbnQgIT0gbnVsbCkgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tbWVudHMubGVuZ3RoID4gMCA/IGNvbW1lbnRzLmpvaW4oJ1xcbicpIDogbnVsbDtcbiAgfVxuXG4gIGNvbW1lbnRIYXNSZXF1aXJlZFdoaXRlc3BhY2Uoc3RhcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzcmNcbiAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGlmICh0aGlzLmhlYWRlciAmJiBzdGFydCA9PT0gdGhpcy5oZWFkZXIuZW5kKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF0aGlzLnZhbHVlUmFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7XG4gICAgICBlbmRcbiAgICB9ID0gdGhpcy52YWx1ZVJhbmdlO1xuICAgIHJldHVybiBzdGFydCAhPT0gZW5kIHx8IE5vZGUuYXRCbGFuayhzcmMsIGVuZCAtIDEpO1xuICB9XG5cbiAgZ2V0IGhhc0NvbW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzcmNcbiAgICAgIH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc3JjW3RoaXMucHJvcHNbaV0uc3RhcnRdID09PSBDaGFyLkNPTU1FTlQpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldCBoYXNQcm9wcygpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNyY1xuICAgICAgfSA9IHRoaXMuY29udGV4dDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzcmNbdGhpcy5wcm9wc1tpXS5zdGFydF0gIT09IENoYXIuQ09NTUVOVCkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0IGluY2x1ZGVzVHJhaWxpbmdMaW5lcygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQganNvbkxpa2UoKSB7XG4gICAgY29uc3QganNvbkxpa2VUeXBlcyA9IFtUeXBlLkZMT1dfTUFQLCBUeXBlLkZMT1dfU0VRLCBUeXBlLlFVT1RFX0RPVUJMRSwgVHlwZS5RVU9URV9TSU5HTEVdO1xuICAgIHJldHVybiBqc29uTGlrZVR5cGVzLmluZGV4T2YodGhpcy50eXBlKSAhPT0gLTE7XG4gIH1cblxuICBnZXQgcmFuZ2VBc0xpbmVQb3MoKSB7XG4gICAgaWYgKCF0aGlzLnJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRMaW5lUG9zKHRoaXMucmFuZ2Uuc3RhcnQsIHRoaXMuY29udGV4dC5yb290KTtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGVuZCA9IGdldExpbmVQb3ModGhpcy5yYW5nZS5lbmQsIHRoaXMuY29udGV4dC5yb290KTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9O1xuICB9XG5cbiAgZ2V0IHJhd1ZhbHVlKCkge1xuICAgIGlmICghdGhpcy52YWx1ZVJhbmdlIHx8ICF0aGlzLmNvbnRleHQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSA9IHRoaXMudmFsdWVSYW5nZTtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNyYy5zbGljZShzdGFydCwgZW5kKTtcbiAgfVxuXG4gIGdldCB0YWcoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB0YWcgPSB0aGlzLmdldFByb3BWYWx1ZShpLCBDaGFyLlRBRywgZmFsc2UpO1xuXG4gICAgICBpZiAodGFnICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRhZ1sxXSA9PT0gJzwnKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmJhdGltOiB0YWcuc2xpY2UoMiwgLTEpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICBjb25zdCBbXywgaGFuZGxlLCBzdWZmaXhdID0gdGFnLm1hdGNoKC9eKC4qISkoW14hXSopJC8pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYW5kbGUsXG4gICAgICAgICAgICBzdWZmaXhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgdmFsdWVSYW5nZUNvbnRhaW5zTmV3bGluZSgpIHtcbiAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSB8fCAhdGhpcy5jb250ZXh0KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9ID0gdGhpcy52YWx1ZVJhbmdlO1xuICAgIGNvbnN0IHtcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgaWYgKHNyY1tpXSA9PT0gJ1xcbicpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHBhcnNlQ29tbWVudChzdGFydCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICBpZiAoc3JjW3N0YXJ0XSA9PT0gQ2hhci5DT01NRU5UKSB7XG4gICAgICBjb25zdCBlbmQgPSBOb2RlLmVuZE9mTGluZShzcmMsIHN0YXJ0ICsgMSk7XG4gICAgICBjb25zdCBjb21tZW50UmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICB0aGlzLnByb3BzLnB1c2goY29tbWVudFJhbmdlKTtcbiAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9XG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgdGhlIGBvcmlnU3RhcnRgIGFuZCBgb3JpZ0VuZGAgdmFsdWVzIG9mIGFsbCByYW5nZXMgZm9yIHRoaXNcbiAgICogbm9kZS4gRXh0ZW5kZWQgYnkgY2hpbGQgY2xhc3NlcyB0byBoYW5kbGUgZGVzY2VuZGFudCBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gY3IgLSBQb3NpdGlvbnMgb2YgZHJvcHBlZCBDUiBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBTdGFydGluZyBpbmRleCBvZiBgY3JgIGZyb20gdGhlIGxhc3QgY2FsbFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBuZXh0IG9mZnNldCwgbWF0Y2hpbmcgdGhlIG9uZSBmb3VuZCBmb3IgYG9yaWdTdGFydGBcbiAgICovXG5cblxuICBzZXRPcmlnUmFuZ2VzKGNyLCBvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5yYW5nZSkgb2Zmc2V0ID0gdGhpcy5yYW5nZS5zZXRPcmlnUmFuZ2UoY3IsIG9mZnNldCk7XG4gICAgaWYgKHRoaXMudmFsdWVSYW5nZSkgdGhpcy52YWx1ZVJhbmdlLnNldE9yaWdSYW5nZShjciwgb2Zmc2V0KTtcbiAgICB0aGlzLnByb3BzLmZvckVhY2gocHJvcCA9PiBwcm9wLnNldE9yaWdSYW5nZShjciwgb2Zmc2V0KSk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgc3JjXG4gICAgICB9LFxuICAgICAgcmFuZ2UsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc3RyID0gc3JjLnNsaWNlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgIHJldHVybiBOb2RlLmFkZFN0cmluZ1Rlcm1pbmF0b3Ioc3JjLCByYW5nZS5lbmQsIHN0cik7XG4gIH1cblxufVxuXG5jbGFzcyBZQU1MRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHNvdXJjZSwgbWVzc2FnZSkge1xuICAgIGlmICghbWVzc2FnZSB8fCAhKHNvdXJjZSBpbnN0YW5jZW9mIE5vZGUpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJndW1lbnRzIGZvciBuZXcgJHtuYW1lfWApO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICB9XG5cbiAgbWFrZVByZXR0eSgpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlKSByZXR1cm47XG4gICAgdGhpcy5ub2RlVHlwZSA9IHRoaXMuc291cmNlLnR5cGU7XG4gICAgY29uc3QgY3N0ID0gdGhpcy5zb3VyY2UuY29udGV4dCAmJiB0aGlzLnNvdXJjZS5jb250ZXh0LnJvb3Q7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5yYW5nZSA9IG5ldyBSYW5nZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gY3N0ICYmIGdldExpbmVQb3ModGhpcy5vZmZzZXQsIGNzdCk7XG5cbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBjb25zdCBlbmQgPSB7XG4gICAgICAgICAgbGluZTogc3RhcnQubGluZSxcbiAgICAgICAgICBjb2w6IHN0YXJ0LmNvbCArIDFcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saW5lUG9zID0ge1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgdGhpcy5vZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNvdXJjZS5yYW5nZTtcbiAgICAgIHRoaXMubGluZVBvcyA9IHRoaXMuc291cmNlLnJhbmdlQXNMaW5lUG9zO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxpbmVQb3MpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgY29sXG4gICAgICB9ID0gdGhpcy5saW5lUG9zLnN0YXJ0O1xuICAgICAgdGhpcy5tZXNzYWdlICs9IGAgYXQgbGluZSAke2xpbmV9LCBjb2x1bW4gJHtjb2x9YDtcbiAgICAgIGNvbnN0IGN0eCA9IGNzdCAmJiBnZXRQcmV0dHlDb250ZXh0KHRoaXMubGluZVBvcywgY3N0KTtcbiAgICAgIGlmIChjdHgpIHRoaXMubWVzc2FnZSArPSBgOlxcblxcbiR7Y3R4fVxcbmA7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuc291cmNlO1xuICB9XG5cbn1cbmNsYXNzIFlBTUxSZWZlcmVuY2VFcnJvciBleHRlbmRzIFlBTUxFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKCdZQU1MUmVmZXJlbmNlRXJyb3InLCBzb3VyY2UsIG1lc3NhZ2UpO1xuICB9XG5cbn1cbmNsYXNzIFlBTUxTZW1hbnRpY0Vycm9yIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIoJ1lBTUxTZW1hbnRpY0Vycm9yJywgc291cmNlLCBtZXNzYWdlKTtcbiAgfVxuXG59XG5jbGFzcyBZQU1MU3ludGF4RXJyb3IgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcignWUFNTFN5bnRheEVycm9yJywgc291cmNlLCBtZXNzYWdlKTtcbiAgfVxuXG59XG5jbGFzcyBZQU1MV2FybmluZyBleHRlbmRzIFlBTUxFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKCdZQU1MV2FybmluZycsIHNvdXJjZSwgbWVzc2FnZSk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuY2xhc3MgUGxhaW5WYWx1ZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgZW5kT2ZMaW5lKHNyYywgc3RhcnQsIGluRmxvdykge1xuICAgIGxldCBjaCA9IHNyY1tzdGFydF07XG4gICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuXG4gICAgd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJykge1xuICAgICAgaWYgKGluRmxvdyAmJiAoY2ggPT09ICdbJyB8fCBjaCA9PT0gJ10nIHx8IGNoID09PSAneycgfHwgY2ggPT09ICd9JyB8fCBjaCA9PT0gJywnKSkgYnJlYWs7XG4gICAgICBjb25zdCBuZXh0ID0gc3JjW29mZnNldCArIDFdO1xuICAgICAgaWYgKGNoID09PSAnOicgJiYgKCFuZXh0IHx8IG5leHQgPT09ICdcXG4nIHx8IG5leHQgPT09ICdcXHQnIHx8IG5leHQgPT09ICcgJyB8fCBpbkZsb3cgJiYgbmV4dCA9PT0gJywnKSkgYnJlYWs7XG4gICAgICBpZiAoKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSAmJiBuZXh0ID09PSAnIycpIGJyZWFrO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICBjaCA9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIGdldCBzdHJWYWx1ZSgpIHtcbiAgICBpZiAoIXRoaXMudmFsdWVSYW5nZSB8fCAhdGhpcy5jb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICBsZXQge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9ID0gdGhpcy52YWx1ZVJhbmdlO1xuICAgIGNvbnN0IHtcbiAgICAgIHNyY1xuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgbGV0IGNoID0gc3JjW2VuZCAtIDFdO1xuXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIChjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcpKSBjaCA9IHNyY1stLWVuZCAtIDFdO1xuXG4gICAgbGV0IHN0ciA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoID0gc3JjW2ldO1xuXG4gICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmb2xkLFxuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9ID0gTm9kZS5mb2xkTmV3bGluZShzcmMsIGksIC0xKTtcbiAgICAgICAgc3RyICs9IGZvbGQ7XG4gICAgICAgIGkgPSBvZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICBjb25zdCB3c1N0YXJ0ID0gaTtcbiAgICAgICAgbGV0IG5leHQgPSBzcmNbaSArIDFdO1xuXG4gICAgICAgIHdoaWxlIChpIDwgZW5kICYmIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpKSB7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIG5leHQgPSBzcmNbaSArIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHQgIT09ICdcXG4nKSBzdHIgKz0gaSA+IHdzU3RhcnQgPyBzcmMuc2xpY2Uod3NTdGFydCwgaSArIDEpIDogY2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gY2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2gwID0gc3JjW3N0YXJ0XTtcblxuICAgIHN3aXRjaCAoY2gwKSB7XG4gICAgICBjYXNlICdcXHQnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ1BsYWluIHZhbHVlIGNhbm5vdCBzdGFydCB3aXRoIGEgdGFiIGNoYXJhY3Rlcic7XG4gICAgICAgICAgY29uc3QgZXJyb3JzID0gW25ldyBZQU1MU2VtYW50aWNFcnJvcih0aGlzLCBtc2cpXTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgICAgc3RyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdAJzpcbiAgICAgIGNhc2UgJ2AnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYFBsYWluIHZhbHVlIGNhbm5vdCBzdGFydCB3aXRoIHJlc2VydmVkIGNoYXJhY3RlciAke2NoMH1gO1xuICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtuZXcgWUFNTFNlbWFudGljRXJyb3IodGhpcywgbXNnKV07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICAgIHN0clxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICBwYXJzZUJsb2NrVmFsdWUoc3RhcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmRlbnQsXG4gICAgICBpbkZsb3csXG4gICAgICBzcmNcbiAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICBsZXQgdmFsdWVFbmQgPSBzdGFydDtcblxuICAgIGZvciAobGV0IGNoID0gc3JjW29mZnNldF07IGNoID09PSAnXFxuJzsgY2ggPSBzcmNbb2Zmc2V0XSkge1xuICAgICAgaWYgKE5vZGUuYXREb2N1bWVudEJvdW5kYXJ5KHNyYywgb2Zmc2V0ICsgMSkpIGJyZWFrO1xuICAgICAgY29uc3QgZW5kID0gTm9kZS5lbmRPZkJsb2NrSW5kZW50KHNyYywgaW5kZW50LCBvZmZzZXQgKyAxKTtcbiAgICAgIGlmIChlbmQgPT09IG51bGwgfHwgc3JjW2VuZF0gPT09ICcjJykgYnJlYWs7XG5cbiAgICAgIGlmIChzcmNbZW5kXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVFbmQgPSBQbGFpblZhbHVlLmVuZE9mTGluZShzcmMsIGVuZCwgaW5GbG93KTtcbiAgICAgICAgb2Zmc2V0ID0gdmFsdWVFbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmFsdWVSYW5nZS5pc0VtcHR5KCkpIHRoaXMudmFsdWVSYW5nZS5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMudmFsdWVSYW5nZS5lbmQgPSB2YWx1ZUVuZDtcbiAgICByZXR1cm4gdmFsdWVFbmQ7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHBsYWluIHZhbHVlIGZyb20gdGhlIHNvdXJjZVxuICAgKlxuICAgKiBBY2NlcHRlZCBmb3JtcyBhcmU6XG4gICAqIGBgYFxuICAgKiAjY29tbWVudFxuICAgKlxuICAgKiBmaXJzdCBsaW5lXG4gICAqXG4gICAqIGZpcnN0IGxpbmUgI2NvbW1lbnRcbiAgICpcbiAgICogZmlyc3QgbGluZVxuICAgKiBibG9ja1xuICAgKiBsaW5lc1xuICAgKlxuICAgKiAjY29tbWVudFxuICAgKiBibG9ja1xuICAgKiBsaW5lc1xuICAgKiBgYGBcbiAgICogd2hlcmUgYmxvY2sgbGluZXMgYXJlIGVtcHR5IG9yIGhhdmUgYW4gaW5kZW50IGxldmVsIGdyZWF0ZXIgdGhhbiBgaW5kZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJzZUNvbnRleHR9IGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggb2YgZmlyc3QgY2hhcmFjdGVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gSW5kZXggb2YgdGhlIGNoYXJhY3RlciBhZnRlciB0aGlzIHNjYWxhciwgbWF5IGJlIGBcXG5gXG4gICAqL1xuXG5cbiAgcGFyc2UoY29udGV4dCwgc3RhcnQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIGluRmxvdyxcbiAgICAgIHNyY1xuICAgIH0gPSBjb250ZXh0O1xuICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICBjb25zdCBjaCA9IHNyY1tvZmZzZXRdO1xuXG4gICAgaWYgKGNoICYmIGNoICE9PSAnIycgJiYgY2ggIT09ICdcXG4nKSB7XG4gICAgICBvZmZzZXQgPSBQbGFpblZhbHVlLmVuZE9mTGluZShzcmMsIHN0YXJ0LCBpbkZsb3cpO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWVSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgPSBOb2RlLmVuZE9mV2hpdGVTcGFjZShzcmMsIG9mZnNldCk7XG4gICAgb2Zmc2V0ID0gdGhpcy5wYXJzZUNvbW1lbnQob2Zmc2V0KTtcblxuICAgIGlmICghdGhpcy5oYXNDb21tZW50IHx8IHRoaXMudmFsdWVSYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMucGFyc2VCbG9ja1ZhbHVlKG9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG59XG5cbmV4cG9ydHMuQ2hhciA9IENoYXI7XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xuZXhwb3J0cy5QbGFpblZhbHVlID0gUGxhaW5WYWx1ZTtcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuVHlwZSA9IFR5cGU7XG5leHBvcnRzLllBTUxFcnJvciA9IFlBTUxFcnJvcjtcbmV4cG9ydHMuWUFNTFJlZmVyZW5jZUVycm9yID0gWUFNTFJlZmVyZW5jZUVycm9yO1xuZXhwb3J0cy5ZQU1MU2VtYW50aWNFcnJvciA9IFlBTUxTZW1hbnRpY0Vycm9yO1xuZXhwb3J0cy5ZQU1MU3ludGF4RXJyb3IgPSBZQU1MU3ludGF4RXJyb3I7XG5leHBvcnRzLllBTUxXYXJuaW5nID0gWUFNTFdhcm5pbmc7XG5leHBvcnRzLl9kZWZpbmVQcm9wZXJ0eSA9IF9kZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydHMuZGVmYXVsdFRhZ1ByZWZpeCA9IGRlZmF1bHRUYWdQcmVmaXg7XG5leHBvcnRzLmRlZmF1bHRUYWdzID0gZGVmYXVsdFRhZ3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQbGFpblZhbHVlID0gcmVxdWlyZSgnLi9QbGFpblZhbHVlLWVjOGU1ODhlLmpzJyk7XG5cbmZ1bmN0aW9uIGFkZENvbW1lbnRCZWZvcmUoc3RyLCBpbmRlbnQsIGNvbW1lbnQpIHtcbiAgaWYgKCFjb21tZW50KSByZXR1cm4gc3RyO1xuICBjb25zdCBjYyA9IGNvbW1lbnQucmVwbGFjZSgvW1xcc1xcU11eL2dtLCBgJCYke2luZGVudH0jYCk7XG4gIHJldHVybiBgIyR7Y2N9XFxuJHtpbmRlbnR9JHtzdHJ9YDtcbn1cbmZ1bmN0aW9uIGFkZENvbW1lbnQoc3RyLCBpbmRlbnQsIGNvbW1lbnQpIHtcbiAgcmV0dXJuICFjb21tZW50ID8gc3RyIDogY29tbWVudC5pbmRleE9mKCdcXG4nKSA9PT0gLTEgPyBgJHtzdHJ9ICMke2NvbW1lbnR9YCA6IGAke3N0cn1cXG5gICsgY29tbWVudC5yZXBsYWNlKC9eL2dtLCBgJHtpbmRlbnQgfHwgJyd9I2ApO1xufVxuXG5jbGFzcyBOb2RlIHt9XG5cbmZ1bmN0aW9uIHRvSlNPTih2YWx1ZSwgYXJnLCBjdHgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiB0b0pTT04odiwgU3RyaW5nKGkpLCBjdHgpKTtcblxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGFuY2hvciA9IGN0eCAmJiBjdHguYW5jaG9ycyAmJiBjdHguYW5jaG9ycy5nZXQodmFsdWUpO1xuICAgIGlmIChhbmNob3IpIGN0eC5vbkNyZWF0ZSA9IHJlcyA9PiB7XG4gICAgICBhbmNob3IucmVzID0gcmVzO1xuICAgICAgZGVsZXRlIGN0eC5vbkNyZWF0ZTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgaWYgKGFuY2hvciAmJiBjdHgub25DcmVhdGUpIGN0eC5vbkNyZWF0ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBpZiAoKCFjdHggfHwgIWN0eC5rZWVwKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5jbGFzcyBTY2FsYXIgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHRvSlNPTihhcmcsIGN0eCkge1xuICAgIHJldHVybiBjdHggJiYgY3R4LmtlZXAgPyB0aGlzLnZhbHVlIDogdG9KU09OKHRoaXMudmFsdWUsIGFyZywgY3R4KTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uRnJvbVBhdGgoc2NoZW1hLCBwYXRoLCB2YWx1ZSkge1xuICBsZXQgdiA9IHZhbHVlO1xuXG4gIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3QgayA9IHBhdGhbaV07XG5cbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihrKSAmJiBrID49IDApIHtcbiAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgIGFba10gPSB2O1xuICAgICAgdiA9IGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG8gPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrLCB7XG4gICAgICAgIHZhbHVlOiB2LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHYgPSBvO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY2hlbWEuY3JlYXRlTm9kZSh2LCBmYWxzZSk7XG59IC8vIG51bGwsIHVuZGVmaW5lZCwgb3IgYW4gZW1wdHkgbm9uLXN0cmluZyBpdGVyYWJsZSAoZS5nLiBbXSlcblxuXG5jb25zdCBpc0VtcHR5UGF0aCA9IHBhdGggPT4gcGF0aCA9PSBudWxsIHx8IHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZTtcbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIFBsYWluVmFsdWUuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXRlbXNcIiwgW10pO1xuXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIH1cblxuICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSkgdGhpcy5hZGQodmFsdWUpO2Vsc2Uge1xuICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIG5vZGUuYWRkSW4ocmVzdCwgdmFsdWUpO2Vsc2UgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNjaGVtYSkgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlSW4oW2tleSwgLi4ucmVzdF0pIHtcbiAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbikgcmV0dXJuIG5vZGUuZGVsZXRlSW4ocmVzdCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gIH1cblxuICBnZXRJbihba2V5LCAuLi5yZXN0XSwga2VlcFNjYWxhcikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuICFrZWVwU2NhbGFyICYmIG5vZGUgaW5zdGFuY2VvZiBTY2FsYXIgPyBub2RlLnZhbHVlIDogbm9kZTtlbHNlIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbiA/IG5vZGUuZ2V0SW4ocmVzdCwga2VlcFNjYWxhcikgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBoYXNBbGxOdWxsVmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmV2ZXJ5KG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gJ1BBSVInKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBuID0gbm9kZS52YWx1ZTtcbiAgICAgIHJldHVybiBuID09IG51bGwgfHwgbiBpbnN0YW5jZW9mIFNjYWxhciAmJiBuLnZhbHVlID09IG51bGwgJiYgIW4uY29tbWVudEJlZm9yZSAmJiAhbi5jb21tZW50ICYmICFuLnRhZztcbiAgICB9KTtcbiAgfVxuXG4gIGhhc0luKFtrZXksIC4uLnJlc3RdKSB7XG4gICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5oYXMoa2V5KTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIENvbGxlY3Rpb24gPyBub2RlLmhhc0luKHJlc3QpIDogZmFsc2U7XG4gIH1cblxuICBzZXRJbihba2V5LCAuLi5yZXN0XSwgdmFsdWUpIHtcbiAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGVjdGlvbikgbm9kZS5zZXRJbihyZXN0LCB2YWx1ZSk7ZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKSB0aGlzLnNldChrZXksIGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgcmVzdCwgdmFsdWUpKTtlbHNlIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICB9XG4gIH0gLy8gb3ZlcnJpZGRlbiBpbiBpbXBsZW1lbnRhdGlvbnNcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdG9TdHJpbmcoY3R4LCB7XG4gICAgYmxvY2tJdGVtLFxuICAgIGZsb3dDaGFycyxcbiAgICBpc01hcCxcbiAgICBpdGVtSW5kZW50XG4gIH0sIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRTdGVwLFxuICAgICAgc3RyaW5naWZ5XG4gICAgfSA9IGN0eDtcbiAgICBjb25zdCBpbkZsb3cgPSB0aGlzLnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5GTE9XX01BUCB8fCB0aGlzLnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5GTE9XX1NFUSB8fCBjdHguaW5GbG93O1xuICAgIGlmIChpbkZsb3cpIGl0ZW1JbmRlbnQgKz0gaW5kZW50U3RlcDtcbiAgICBjb25zdCBhbGxOdWxsVmFsdWVzID0gaXNNYXAgJiYgdGhpcy5oYXNBbGxOdWxsVmFsdWVzKCk7XG4gICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7XG4gICAgICBhbGxOdWxsVmFsdWVzLFxuICAgICAgaW5kZW50OiBpdGVtSW5kZW50LFxuICAgICAgaW5GbG93LFxuICAgICAgdHlwZTogbnVsbFxuICAgIH0pO1xuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICBsZXQgaGFzSXRlbVdpdGhOZXdMaW5lID0gZmFsc2U7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLml0ZW1zLnJlZHVjZSgobm9kZXMsIGl0ZW0sIGkpID0+IHtcbiAgICAgIGxldCBjb21tZW50O1xuXG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpdGVtLnNwYWNlQmVmb3JlKSBub2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnY29tbWVudCcsXG4gICAgICAgICAgc3RyOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0ZW0uY29tbWVudEJlZm9yZSkgaXRlbS5jb21tZW50QmVmb3JlLm1hdGNoKC9eLiokL2dtKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2NvbW1lbnQnLFxuICAgICAgICAgICAgc3RyOiBgIyR7bGluZX1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXRlbS5jb21tZW50KSBjb21tZW50ID0gaXRlbS5jb21tZW50O1xuICAgICAgICBpZiAoaW5GbG93ICYmICghY2hvbXBLZWVwICYmIGl0ZW0uc3BhY2VCZWZvcmUgfHwgaXRlbS5jb21tZW50QmVmb3JlIHx8IGl0ZW0uY29tbWVudCB8fCBpdGVtLmtleSAmJiAoaXRlbS5rZXkuY29tbWVudEJlZm9yZSB8fCBpdGVtLmtleS5jb21tZW50KSB8fCBpdGVtLnZhbHVlICYmIChpdGVtLnZhbHVlLmNvbW1lbnRCZWZvcmUgfHwgaXRlbS52YWx1ZS5jb21tZW50KSkpIGhhc0l0ZW1XaXRoTmV3TGluZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgbGV0IHN0ciA9IHN0cmluZ2lmeShpdGVtLCBjdHgsICgpID0+IGNvbW1lbnQgPSBudWxsLCAoKSA9PiBjaG9tcEtlZXAgPSB0cnVlKTtcbiAgICAgIGlmIChpbkZsb3cgJiYgIWhhc0l0ZW1XaXRoTmV3TGluZSAmJiBzdHIuaW5jbHVkZXMoJ1xcbicpKSBoYXNJdGVtV2l0aE5ld0xpbmUgPSB0cnVlO1xuICAgICAgaWYgKGluRmxvdyAmJiBpIDwgdGhpcy5pdGVtcy5sZW5ndGggLSAxKSBzdHIgKz0gJywnO1xuICAgICAgc3RyID0gYWRkQ29tbWVudChzdHIsIGl0ZW1JbmRlbnQsIGNvbW1lbnQpO1xuICAgICAgaWYgKGNob21wS2VlcCAmJiAoY29tbWVudCB8fCBpbkZsb3cpKSBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiAnaXRlbScsXG4gICAgICAgIHN0clxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfSwgW10pO1xuICAgIGxldCBzdHI7XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBzdHIgPSBmbG93Q2hhcnMuc3RhcnQgKyBmbG93Q2hhcnMuZW5kO1xuICAgIH0gZWxzZSBpZiAoaW5GbG93KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmRcbiAgICAgIH0gPSBmbG93Q2hhcnM7XG4gICAgICBjb25zdCBzdHJpbmdzID0gbm9kZXMubWFwKG4gPT4gbi5zdHIpO1xuXG4gICAgICBpZiAoaGFzSXRlbVdpdGhOZXdMaW5lIHx8IHN0cmluZ3MucmVkdWNlKChzdW0sIHN0cikgPT4gc3VtICsgc3RyLmxlbmd0aCArIDIsIDIpID4gQ29sbGVjdGlvbi5tYXhGbG93U3RyaW5nU2luZ2xlTGluZUxlbmd0aCkge1xuICAgICAgICBzdHIgPSBzdGFydDtcblxuICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc3RyaW5ncykge1xuICAgICAgICAgIHN0ciArPSBzID8gYFxcbiR7aW5kZW50U3RlcH0ke2luZGVudH0ke3N9YCA6ICdcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IGBcXG4ke2luZGVudH0ke2VuZH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gYCR7c3RhcnR9ICR7c3RyaW5ncy5qb2luKCcgJyl9ICR7ZW5kfWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmluZ3MgPSBub2Rlcy5tYXAoYmxvY2tJdGVtKTtcbiAgICAgIHN0ciA9IHN0cmluZ3Muc2hpZnQoKTtcblxuICAgICAgZm9yIChjb25zdCBzIG9mIHN0cmluZ3MpIHN0ciArPSBzID8gYFxcbiR7aW5kZW50fSR7c31gIDogJ1xcbic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29tbWVudCkge1xuICAgICAgc3RyICs9ICdcXG4nICsgdGhpcy5jb21tZW50LnJlcGxhY2UoL14vZ20sIGAke2luZGVudH0jYCk7XG4gICAgICBpZiAob25Db21tZW50KSBvbkNvbW1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGNob21wS2VlcCAmJiBvbkNob21wS2VlcCkgb25DaG9tcEtlZXAoKTtcblxuICAgIHJldHVybiBzdHI7XG4gIH1cblxufVxuXG5QbGFpblZhbHVlLl9kZWZpbmVQcm9wZXJ0eShDb2xsZWN0aW9uLCBcIm1heEZsb3dTdHJpbmdTaW5nbGVMaW5lTGVuZ3RoXCIsIDYwKTtcblxuZnVuY3Rpb24gYXNJdGVtSW5kZXgoa2V5KSB7XG4gIGxldCBpZHggPSBrZXkgaW5zdGFuY2VvZiBTY2FsYXIgPyBrZXkudmFsdWUgOiBrZXk7XG4gIGlmIChpZHggJiYgdHlwZW9mIGlkeCA9PT0gJ3N0cmluZycpIGlkeCA9IE51bWJlcihpZHgpO1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihpZHgpICYmIGlkeCA+PSAwID8gaWR4IDogbnVsbDtcbn1cblxuY2xhc3MgWUFNTFNlcSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICBhZGQodmFsdWUpIHtcbiAgICB0aGlzLml0ZW1zLnB1c2godmFsdWUpO1xuICB9XG5cbiAgZGVsZXRlKGtleSkge1xuICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UoaWR4LCAxKTtcbiAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gIH1cblxuICBnZXQoa2V5LCBrZWVwU2NhbGFyKSB7XG4gICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXQgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGl0IGluc3RhbmNlb2YgU2NhbGFyID8gaXQudmFsdWUgOiBpdDtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgIHJldHVybiB0eXBlb2YgaWR4ID09PSAnbnVtYmVyJyAmJiBpZHggPCB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgfVxuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSB2YWxpZCBpbmRleCwgbm90ICR7a2V5fS5gKTtcbiAgICB0aGlzLml0ZW1zW2lkeF0gPSB2YWx1ZTtcbiAgfVxuXG4gIHRvSlNPTihfLCBjdHgpIHtcbiAgICBjb25zdCBzZXEgPSBbXTtcbiAgICBpZiAoY3R4ICYmIGN0eC5vbkNyZWF0ZSkgY3R4Lm9uQ3JlYXRlKHNlcSk7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHNlcS5wdXNoKHRvSlNPTihpdGVtLCBTdHJpbmcoaSsrKSwgY3R4KSk7XG5cbiAgICByZXR1cm4gc2VxO1xuICB9XG5cbiAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgaWYgKCFjdHgpIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICByZXR1cm4gc3VwZXIudG9TdHJpbmcoY3R4LCB7XG4gICAgICBibG9ja0l0ZW06IG4gPT4gbi50eXBlID09PSAnY29tbWVudCcgPyBuLnN0ciA6IGAtICR7bi5zdHJ9YCxcbiAgICAgIGZsb3dDaGFyczoge1xuICAgICAgICBzdGFydDogJ1snLFxuICAgICAgICBlbmQ6ICddJ1xuICAgICAgfSxcbiAgICAgIGlzTWFwOiBmYWxzZSxcbiAgICAgIGl0ZW1JbmRlbnQ6IChjdHguaW5kZW50IHx8ICcnKSArICcgICdcbiAgICB9LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfVxuXG59XG5cbmNvbnN0IHN0cmluZ2lmeUtleSA9IChrZXksIGpzS2V5LCBjdHgpID0+IHtcbiAgaWYgKGpzS2V5ID09PSBudWxsKSByZXR1cm4gJyc7XG4gIGlmICh0eXBlb2YganNLZXkgIT09ICdvYmplY3QnKSByZXR1cm4gU3RyaW5nKGpzS2V5KTtcbiAgaWYgKGtleSBpbnN0YW5jZW9mIE5vZGUgJiYgY3R4ICYmIGN0eC5kb2MpIHJldHVybiBrZXkudG9TdHJpbmcoe1xuICAgIGFuY2hvcnM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgZG9jOiBjdHguZG9jLFxuICAgIGluZGVudDogJycsXG4gICAgaW5kZW50U3RlcDogY3R4LmluZGVudFN0ZXAsXG4gICAgaW5GbG93OiB0cnVlLFxuICAgIGluU3RyaW5naWZ5S2V5OiB0cnVlLFxuICAgIHN0cmluZ2lmeTogY3R4LnN0cmluZ2lmeVxuICB9KTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzS2V5KTtcbn07XG5cbmNsYXNzIFBhaXIgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSA9IG51bGwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnR5cGUgPSBQYWlyLlR5cGUuUEFJUjtcbiAgfVxuXG4gIGdldCBjb21tZW50QmVmb3JlKCkge1xuICAgIHJldHVybiB0aGlzLmtleSBpbnN0YW5jZW9mIE5vZGUgPyB0aGlzLmtleS5jb21tZW50QmVmb3JlIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgc2V0IGNvbW1lbnRCZWZvcmUoY2IpIHtcbiAgICBpZiAodGhpcy5rZXkgPT0gbnVsbCkgdGhpcy5rZXkgPSBuZXcgU2NhbGFyKG51bGwpO1xuICAgIGlmICh0aGlzLmtleSBpbnN0YW5jZW9mIE5vZGUpIHRoaXMua2V5LmNvbW1lbnRCZWZvcmUgPSBjYjtlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdQYWlyLmNvbW1lbnRCZWZvcmUgaXMgYW4gYWxpYXMgZm9yIFBhaXIua2V5LmNvbW1lbnRCZWZvcmUuIFRvIHNldCBpdCwgdGhlIGtleSBtdXN0IGJlIGEgTm9kZS4nO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgYWRkVG9KU01hcChjdHgsIG1hcCkge1xuICAgIGNvbnN0IGtleSA9IHRvSlNPTih0aGlzLmtleSwgJycsIGN0eCk7XG5cbiAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRvSlNPTih0aGlzLnZhbHVlLCBrZXksIGN0eCk7XG4gICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBtYXAuYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmluZ0tleSA9IHN0cmluZ2lmeUtleSh0aGlzLmtleSwga2V5LCBjdHgpO1xuICAgICAgY29uc3QgdmFsdWUgPSB0b0pTT04odGhpcy52YWx1ZSwgc3RyaW5nS2V5LCBjdHgpO1xuICAgICAgaWYgKHN0cmluZ0tleSBpbiBtYXApIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIHN0cmluZ0tleSwge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7ZWxzZSBtYXBbc3RyaW5nS2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICB0b0pTT04oXywgY3R4KSB7XG4gICAgY29uc3QgcGFpciA9IGN0eCAmJiBjdHgubWFwQXNNYXAgPyBuZXcgTWFwKCkgOiB7fTtcbiAgICByZXR1cm4gdGhpcy5hZGRUb0pTTWFwKGN0eCwgcGFpcik7XG4gIH1cblxuICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBpZiAoIWN0eCB8fCAhY3R4LmRvYykgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGVudDogaW5kZW50U2l6ZSxcbiAgICAgIGluZGVudFNlcSxcbiAgICAgIHNpbXBsZUtleXNcbiAgICB9ID0gY3R4LmRvYy5vcHRpb25zO1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBrZXlDb21tZW50ID0ga2V5IGluc3RhbmNlb2YgTm9kZSAmJiBrZXkuY29tbWVudDtcblxuICAgIGlmIChzaW1wbGVLZXlzKSB7XG4gICAgICBpZiAoa2V5Q29tbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIGtleSBub2RlcyBjYW5ub3QgaGF2ZSBjb21tZW50cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5IGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgICAgICBjb25zdCBtc2cgPSAnV2l0aCBzaW1wbGUga2V5cywgY29sbGVjdGlvbiBjYW5ub3QgYmUgdXNlZCBhcyBhIGtleSB2YWx1ZSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBleHBsaWNpdEtleSA9ICFzaW1wbGVLZXlzICYmICgha2V5IHx8IGtleUNvbW1lbnQgfHwgKGtleSBpbnN0YW5jZW9mIE5vZGUgPyBrZXkgaW5zdGFuY2VvZiBDb2xsZWN0aW9uIHx8IGtleS50eXBlID09PSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfRk9MREVEIHx8IGtleS50eXBlID09PSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfTElURVJBTCA6IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSk7XG4gICAgY29uc3Qge1xuICAgICAgZG9jLFxuICAgICAgaW5kZW50LFxuICAgICAgaW5kZW50U3RlcCxcbiAgICAgIHN0cmluZ2lmeVxuICAgIH0gPSBjdHg7XG4gICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7XG4gICAgICBpbXBsaWNpdEtleTogIWV4cGxpY2l0S2V5LFxuICAgICAgaW5kZW50OiBpbmRlbnQgKyBpbmRlbnRTdGVwXG4gICAgfSk7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoa2V5LCBjdHgsICgpID0+IGtleUNvbW1lbnQgPSBudWxsLCAoKSA9PiBjaG9tcEtlZXAgPSB0cnVlKTtcbiAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgY3R4LmluZGVudCwga2V5Q29tbWVudCk7XG5cbiAgICBpZiAoIWV4cGxpY2l0S2V5ICYmIHN0ci5sZW5ndGggPiAxMDI0KSB7XG4gICAgICBpZiAoc2ltcGxlS2V5cykgdGhyb3cgbmV3IEVycm9yKCdXaXRoIHNpbXBsZSBrZXlzLCBzaW5nbGUgbGluZSBzY2FsYXIgbXVzdCBub3Qgc3BhbiBtb3JlIHRoYW4gMTAyNCBjaGFyYWN0ZXJzJyk7XG4gICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGN0eC5hbGxOdWxsVmFsdWVzICYmICFzaW1wbGVLZXlzKSB7XG4gICAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAgIHN0ciA9IGFkZENvbW1lbnQoc3RyLCBjdHguaW5kZW50LCB0aGlzLmNvbW1lbnQpO1xuICAgICAgICBpZiAob25Db21tZW50KSBvbkNvbW1lbnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBLZWVwICYmICFrZXlDb21tZW50ICYmIG9uQ2hvbXBLZWVwKSBvbkNob21wS2VlcCgpO1xuXG4gICAgICByZXR1cm4gY3R4LmluRmxvdyAmJiAhZXhwbGljaXRLZXkgPyBzdHIgOiBgPyAke3N0cn1gO1xuICAgIH1cblxuICAgIHN0ciA9IGV4cGxpY2l0S2V5ID8gYD8gJHtzdHJ9XFxuJHtpbmRlbnR9OmAgOiBgJHtzdHJ9OmA7XG5cbiAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAvLyBleHBlY3RlZCAoYnV0IG5vdCBzdHJpY3RseSByZXF1aXJlZCkgdG8gYmUgYSBzaW5nbGUtbGluZSBjb21tZW50XG4gICAgICBzdHIgPSBhZGRDb21tZW50KHN0ciwgY3R4LmluZGVudCwgdGhpcy5jb21tZW50KTtcbiAgICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICAgIH1cblxuICAgIGxldCB2Y2IgPSAnJztcbiAgICBsZXQgdmFsdWVDb21tZW50ID0gbnVsbDtcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgIGlmICh2YWx1ZS5zcGFjZUJlZm9yZSkgdmNiID0gJ1xcbic7XG5cbiAgICAgIGlmICh2YWx1ZS5jb21tZW50QmVmb3JlKSB7XG4gICAgICAgIGNvbnN0IGNzID0gdmFsdWUuY29tbWVudEJlZm9yZS5yZXBsYWNlKC9eL2dtLCBgJHtjdHguaW5kZW50fSNgKTtcbiAgICAgICAgdmNiICs9IGBcXG4ke2NzfWA7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlQ29tbWVudCA9IHZhbHVlLmNvbW1lbnQ7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWx1ZSA9IGRvYy5zY2hlbWEuY3JlYXRlTm9kZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY3R4LmltcGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAhdGhpcy5jb21tZW50ICYmIHZhbHVlIGluc3RhbmNlb2YgU2NhbGFyKSBjdHguaW5kZW50QXRTdGFydCA9IHN0ci5sZW5ndGggKyAxO1xuICAgIGNob21wS2VlcCA9IGZhbHNlO1xuXG4gICAgaWYgKCFpbmRlbnRTZXEgJiYgaW5kZW50U2l6ZSA+PSAyICYmICFjdHguaW5GbG93ICYmICFleHBsaWNpdEtleSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFlBTUxTZXEgJiYgdmFsdWUudHlwZSAhPT0gUGxhaW5WYWx1ZS5UeXBlLkZMT1dfU0VRICYmICF2YWx1ZS50YWcgJiYgIWRvYy5hbmNob3JzLmdldE5hbWUodmFsdWUpKSB7XG4gICAgICAvLyBJZiBpbmRlbnRTZXEgPT09IGZhbHNlLCBjb25zaWRlciAnLSAnIGFzIHBhcnQgb2YgaW5kZW50YXRpb24gd2hlcmUgcG9zc2libGVcbiAgICAgIGN0eC5pbmRlbnQgPSBjdHguaW5kZW50LnN1YnN0cigyKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZVN0ciA9IHN0cmluZ2lmeSh2YWx1ZSwgY3R4LCAoKSA9PiB2YWx1ZUNvbW1lbnQgPSBudWxsLCAoKSA9PiBjaG9tcEtlZXAgPSB0cnVlKTtcbiAgICBsZXQgd3MgPSAnICc7XG5cbiAgICBpZiAodmNiIHx8IHRoaXMuY29tbWVudCkge1xuICAgICAgd3MgPSBgJHt2Y2J9XFxuJHtjdHguaW5kZW50fWA7XG4gICAgfSBlbHNlIGlmICghZXhwbGljaXRLZXkgJiYgdmFsdWUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgICBjb25zdCBmbG93ID0gdmFsdWVTdHJbMF0gPT09ICdbJyB8fCB2YWx1ZVN0clswXSA9PT0gJ3snO1xuICAgICAgaWYgKCFmbG93IHx8IHZhbHVlU3RyLmluY2x1ZGVzKCdcXG4nKSkgd3MgPSBgXFxuJHtjdHguaW5kZW50fWA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVN0clswXSA9PT0gJ1xcbicpIHdzID0gJyc7XG5cbiAgICBpZiAoY2hvbXBLZWVwICYmICF2YWx1ZUNvbW1lbnQgJiYgb25DaG9tcEtlZXApIG9uQ2hvbXBLZWVwKCk7XG4gICAgcmV0dXJuIGFkZENvbW1lbnQoc3RyICsgd3MgKyB2YWx1ZVN0ciwgY3R4LmluZGVudCwgdmFsdWVDb21tZW50KTtcbiAgfVxuXG59XG5cblBsYWluVmFsdWUuX2RlZmluZVByb3BlcnR5KFBhaXIsIFwiVHlwZVwiLCB7XG4gIFBBSVI6ICdQQUlSJyxcbiAgTUVSR0VfUEFJUjogJ01FUkdFX1BBSVInXG59KTtcblxuY29uc3QgZ2V0QWxpYXNDb3VudCA9IChub2RlLCBhbmNob3JzKSA9PiB7XG4gIGlmIChub2RlIGluc3RhbmNlb2YgQWxpYXMpIHtcbiAgICBjb25zdCBhbmNob3IgPSBhbmNob3JzLmdldChub2RlLnNvdXJjZSk7XG4gICAgcmV0dXJuIGFuY2hvci5jb3VudCAqIGFuY2hvci5hbGlhc0NvdW50O1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLml0ZW1zKSB7XG4gICAgICBjb25zdCBjID0gZ2V0QWxpYXNDb3VudChpdGVtLCBhbmNob3JzKTtcbiAgICAgIGlmIChjID4gY291bnQpIGNvdW50ID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFBhaXIpIHtcbiAgICBjb25zdCBrYyA9IGdldEFsaWFzQ291bnQobm9kZS5rZXksIGFuY2hvcnMpO1xuICAgIGNvbnN0IHZjID0gZ2V0QWxpYXNDb3VudChub2RlLnZhbHVlLCBhbmNob3JzKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoa2MsIHZjKTtcbiAgfVxuXG4gIHJldHVybiAxO1xufTtcblxuY2xhc3MgQWxpYXMgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHN0cmluZ2lmeSh7XG4gICAgcmFuZ2UsXG4gICAgc291cmNlXG4gIH0sIHtcbiAgICBhbmNob3JzLFxuICAgIGRvYyxcbiAgICBpbXBsaWNpdEtleSxcbiAgICBpblN0cmluZ2lmeUtleVxuICB9KSB7XG4gICAgbGV0IGFuY2hvciA9IE9iamVjdC5rZXlzKGFuY2hvcnMpLmZpbmQoYSA9PiBhbmNob3JzW2FdID09PSBzb3VyY2UpO1xuICAgIGlmICghYW5jaG9yICYmIGluU3RyaW5naWZ5S2V5KSBhbmNob3IgPSBkb2MuYW5jaG9ycy5nZXROYW1lKHNvdXJjZSkgfHwgZG9jLmFuY2hvcnMubmV3TmFtZSgpO1xuICAgIGlmIChhbmNob3IpIHJldHVybiBgKiR7YW5jaG9yfSR7aW1wbGljaXRLZXkgPyAnICcgOiAnJ31gO1xuICAgIGNvbnN0IG1zZyA9IGRvYy5hbmNob3JzLmdldE5hbWUoc291cmNlKSA/ICdBbGlhcyBub2RlIG11c3QgYmUgYWZ0ZXIgc291cmNlIG5vZGUnIDogJ1NvdXJjZSBub2RlIG5vdCBmb3VuZCBmb3IgYWxpYXMgbm9kZSc7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke21zZ30gWyR7cmFuZ2V9XWApO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnR5cGUgPSBQbGFpblZhbHVlLlR5cGUuQUxJQVM7XG4gIH1cblxuICBzZXQgdGFnKHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsaWFzIG5vZGVzIGNhbm5vdCBoYXZlIHRhZ3MnKTtcbiAgfVxuXG4gIHRvSlNPTihhcmcsIGN0eCkge1xuICAgIGlmICghY3R4KSByZXR1cm4gdG9KU09OKHRoaXMuc291cmNlLCBhcmcsIGN0eCk7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9ycyxcbiAgICAgIG1heEFsaWFzQ291bnRcbiAgICB9ID0gY3R4O1xuICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvcnMuZ2V0KHRoaXMuc291cmNlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgIGlmICghYW5jaG9yIHx8IGFuY2hvci5yZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbXNnID0gJ1RoaXMgc2hvdWxkIG5vdCBoYXBwZW46IEFsaWFzIGFuY2hvciB3YXMgbm90IHJlc29sdmVkPyc7XG4gICAgICBpZiAodGhpcy5jc3ROb2RlKSB0aHJvdyBuZXcgUGxhaW5WYWx1ZS5ZQU1MUmVmZXJlbmNlRXJyb3IodGhpcy5jc3ROb2RlLCBtc2cpO2Vsc2UgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKG1heEFsaWFzQ291bnQgPj0gMCkge1xuICAgICAgYW5jaG9yLmNvdW50ICs9IDE7XG4gICAgICBpZiAoYW5jaG9yLmFsaWFzQ291bnQgPT09IDApIGFuY2hvci5hbGlhc0NvdW50ID0gZ2V0QWxpYXNDb3VudCh0aGlzLnNvdXJjZSwgYW5jaG9ycyk7XG5cbiAgICAgIGlmIChhbmNob3IuY291bnQgKiBhbmNob3IuYWxpYXNDb3VudCA+IG1heEFsaWFzQ291bnQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJ0V4Y2Vzc2l2ZSBhbGlhcyBjb3VudCBpbmRpY2F0ZXMgYSByZXNvdXJjZSBleGhhdXN0aW9uIGF0dGFjayc7XG4gICAgICAgIGlmICh0aGlzLmNzdE5vZGUpIHRocm93IG5ldyBQbGFpblZhbHVlLllBTUxSZWZlcmVuY2VFcnJvcih0aGlzLmNzdE5vZGUsIG1zZyk7ZWxzZSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5jaG9yLnJlcztcbiAgfSAvLyBPbmx5IGNhbGxlZCB3aGVuIHN0cmluZ2lmeWluZyBhbiBhbGlhcyBtYXBwaW5nIGtleSB3aGlsZSBjb25zdHJ1Y3RpbmdcbiAgLy8gT2JqZWN0IG91dHB1dC5cblxuXG4gIHRvU3RyaW5nKGN0eCkge1xuICAgIHJldHVybiBBbGlhcy5zdHJpbmdpZnkodGhpcywgY3R4KTtcbiAgfVxuXG59XG5cblBsYWluVmFsdWUuX2RlZmluZVByb3BlcnR5KEFsaWFzLCBcImRlZmF1bHRcIiwgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGZpbmRQYWlyKGl0ZW1zLCBrZXkpIHtcbiAgY29uc3QgayA9IGtleSBpbnN0YW5jZW9mIFNjYWxhciA/IGtleS52YWx1ZSA6IGtleTtcblxuICBmb3IgKGNvbnN0IGl0IG9mIGl0ZW1zKSB7XG4gICAgaWYgKGl0IGluc3RhbmNlb2YgUGFpcikge1xuICAgICAgaWYgKGl0LmtleSA9PT0ga2V5IHx8IGl0LmtleSA9PT0gaykgcmV0dXJuIGl0O1xuICAgICAgaWYgKGl0LmtleSAmJiBpdC5rZXkudmFsdWUgPT09IGspIHJldHVybiBpdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgWUFNTE1hcCBleHRlbmRzIENvbGxlY3Rpb24ge1xuICBhZGQocGFpciwgb3ZlcndyaXRlKSB7XG4gICAgaWYgKCFwYWlyKSBwYWlyID0gbmV3IFBhaXIocGFpcik7ZWxzZSBpZiAoIShwYWlyIGluc3RhbmNlb2YgUGFpcikpIHBhaXIgPSBuZXcgUGFpcihwYWlyLmtleSB8fCBwYWlyLCBwYWlyLnZhbHVlKTtcbiAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywgcGFpci5rZXkpO1xuICAgIGNvbnN0IHNvcnRFbnRyaWVzID0gdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuc29ydE1hcEVudHJpZXM7XG5cbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKG92ZXJ3cml0ZSkgcHJldi52YWx1ZSA9IHBhaXIudmFsdWU7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYEtleSAke3BhaXIua2V5fSBhbHJlYWR5IHNldGApO1xuICAgIH0gZWxzZSBpZiAoc29ydEVudHJpZXMpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLml0ZW1zLmZpbmRJbmRleChpdGVtID0+IHNvcnRFbnRyaWVzKHBhaXIsIGl0ZW0pIDwgMCk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHRoaXMuaXRlbXMucHVzaChwYWlyKTtlbHNlIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIHBhaXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLml0ZW1zLnB1c2gocGFpcik7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlKGtleSkge1xuICAgIGNvbnN0IGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICBpZiAoIWl0KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGl0KSwgMSk7XG4gICAgcmV0dXJuIGRlbC5sZW5ndGggPiAwO1xuICB9XG5cbiAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgIGNvbnN0IGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICBjb25zdCBub2RlID0gaXQgJiYgaXQudmFsdWU7XG4gICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIG5vZGUgaW5zdGFuY2VvZiBTY2FsYXIgPyBub2RlLnZhbHVlIDogbm9kZTtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmFkZChuZXcgUGFpcihrZXksIHZhbHVlKSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gYXJnIGlnbm9yZWRcbiAgICogQHBhcmFtIHsqfSBjdHggQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTT04oKVxuICAgKiBAcGFyYW0ge0NsYXNzfSBUeXBlIElmIHNldCwgZm9yY2VzIHRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIHR5cGVcbiAgICogQHJldHVybnMgeyp9IEluc3RhbmNlIG9mIFR5cGUsIE1hcCwgb3IgT2JqZWN0XG4gICAqL1xuXG5cbiAgdG9KU09OKF8sIGN0eCwgVHlwZSkge1xuICAgIGNvbnN0IG1hcCA9IFR5cGUgPyBuZXcgVHlwZSgpIDogY3R4ICYmIGN0eC5tYXBBc01hcCA/IG5ldyBNYXAoKSA6IHt9O1xuICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKSBjdHgub25DcmVhdGUobWFwKTtcblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSBpdGVtLmFkZFRvSlNNYXAoY3R4LCBtYXApO1xuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGlmICghY3R4KSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFBhaXIpKSB0aHJvdyBuZXcgRXJyb3IoYE1hcCBpdGVtcyBtdXN0IGFsbCBiZSBwYWlyczsgZm91bmQgJHtKU09OLnN0cmluZ2lmeShpdGVtKX0gaW5zdGVhZGApO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci50b1N0cmluZyhjdHgsIHtcbiAgICAgIGJsb2NrSXRlbTogbiA9PiBuLnN0cixcbiAgICAgIGZsb3dDaGFyczoge1xuICAgICAgICBzdGFydDogJ3snLFxuICAgICAgICBlbmQ6ICd9J1xuICAgICAgfSxcbiAgICAgIGlzTWFwOiB0cnVlLFxuICAgICAgaXRlbUluZGVudDogY3R4LmluZGVudCB8fCAnJ1xuICAgIH0sIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9XG5cbn1cblxuY29uc3QgTUVSR0VfS0VZID0gJzw8JztcbmNsYXNzIE1lcmdlIGV4dGVuZHMgUGFpciB7XG4gIGNvbnN0cnVjdG9yKHBhaXIpIHtcbiAgICBpZiAocGFpciBpbnN0YW5jZW9mIFBhaXIpIHtcbiAgICAgIGxldCBzZXEgPSBwYWlyLnZhbHVlO1xuXG4gICAgICBpZiAoIShzZXEgaW5zdGFuY2VvZiBZQU1MU2VxKSkge1xuICAgICAgICBzZXEgPSBuZXcgWUFNTFNlcSgpO1xuICAgICAgICBzZXEuaXRlbXMucHVzaChwYWlyLnZhbHVlKTtcbiAgICAgICAgc2VxLnJhbmdlID0gcGFpci52YWx1ZS5yYW5nZTtcbiAgICAgIH1cblxuICAgICAgc3VwZXIocGFpci5rZXksIHNlcSk7XG4gICAgICB0aGlzLnJhbmdlID0gcGFpci5yYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIobmV3IFNjYWxhcihNRVJHRV9LRVkpLCBuZXcgWUFNTFNlcSgpKTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSBQYWlyLlR5cGUuTUVSR0VfUEFJUjtcbiAgfSAvLyBJZiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEgbWVyZ2Uga2V5IGlzIGEgc2luZ2xlIG1hcHBpbmcgbm9kZSwgZWFjaCBvZlxuICAvLyBpdHMga2V5L3ZhbHVlIHBhaXJzIGlzIGluc2VydGVkIGludG8gdGhlIGN1cnJlbnQgbWFwcGluZywgdW5sZXNzIHRoZSBrZXlcbiAgLy8gYWxyZWFkeSBleGlzdHMgaW4gaXQuIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lcmdlIGtleSBpcyBhXG4gIC8vIHNlcXVlbmNlLCB0aGVuIHRoaXMgc2VxdWVuY2UgaXMgZXhwZWN0ZWQgdG8gY29udGFpbiBtYXBwaW5nIG5vZGVzIGFuZCBlYWNoXG4gIC8vIG9mIHRoZXNlIG5vZGVzIGlzIG1lcmdlZCBpbiB0dXJuIGFjY29yZGluZyB0byBpdHMgb3JkZXIgaW4gdGhlIHNlcXVlbmNlLlxuICAvLyBLZXlzIGluIG1hcHBpbmcgbm9kZXMgZWFybGllciBpbiB0aGUgc2VxdWVuY2Ugb3ZlcnJpZGUga2V5cyBzcGVjaWZpZWQgaW5cbiAgLy8gbGF0ZXIgbWFwcGluZyBub2Rlcy4gLS0gaHR0cDovL3lhbWwub3JnL3R5cGUvbWVyZ2UuaHRtbFxuXG5cbiAgYWRkVG9KU01hcChjdHgsIG1hcCkge1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgc291cmNlXG4gICAgfSBvZiB0aGlzLnZhbHVlLml0ZW1zKSB7XG4gICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBZQU1MTWFwKSkgdGhyb3cgbmV3IEVycm9yKCdNZXJnZSBzb3VyY2VzIG11c3QgYmUgbWFwcycpO1xuICAgICAgY29uc3Qgc3JjTWFwID0gc291cmNlLnRvSlNPTihudWxsLCBjdHgsIE1hcCk7XG5cbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNyY01hcCkge1xuICAgICAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgaWYgKCFtYXAuaGFzKGtleSkpIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgbWFwLmFkZChrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHRvU3RyaW5nKGN0eCwgb25Db21tZW50KSB7XG4gICAgY29uc3Qgc2VxID0gdGhpcy52YWx1ZTtcbiAgICBpZiAoc2VxLml0ZW1zLmxlbmd0aCA+IDEpIHJldHVybiBzdXBlci50b1N0cmluZyhjdHgsIG9uQ29tbWVudCk7XG4gICAgdGhpcy52YWx1ZSA9IHNlcS5pdGVtc1swXTtcbiAgICBjb25zdCBzdHIgPSBzdXBlci50b1N0cmluZyhjdHgsIG9uQ29tbWVudCk7XG4gICAgdGhpcy52YWx1ZSA9IHNlcTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbn1cblxuY29uc3QgYmluYXJ5T3B0aW9ucyA9IHtcbiAgZGVmYXVsdFR5cGU6IFBsYWluVmFsdWUuVHlwZS5CTE9DS19MSVRFUkFMLFxuICBsaW5lV2lkdGg6IDc2XG59O1xuY29uc3QgYm9vbE9wdGlvbnMgPSB7XG4gIHRydWVTdHI6ICd0cnVlJyxcbiAgZmFsc2VTdHI6ICdmYWxzZSdcbn07XG5jb25zdCBpbnRPcHRpb25zID0ge1xuICBhc0JpZ0ludDogZmFsc2Vcbn07XG5jb25zdCBudWxsT3B0aW9ucyA9IHtcbiAgbnVsbFN0cjogJ251bGwnXG59O1xuY29uc3Qgc3RyT3B0aW9ucyA9IHtcbiAgZGVmYXVsdFR5cGU6IFBsYWluVmFsdWUuVHlwZS5QTEFJTixcbiAgZG91YmxlUXVvdGVkOiB7XG4gICAganNvbkVuY29kaW5nOiBmYWxzZSxcbiAgICBtaW5NdWx0aUxpbmVMZW5ndGg6IDQwXG4gIH0sXG4gIGZvbGQ6IHtcbiAgICBsaW5lV2lkdGg6IDgwLFxuICAgIG1pbkNvbnRlbnRXaWR0aDogMjBcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVNjYWxhcihzdHIsIHRhZ3MsIHNjYWxhckZhbGxiYWNrKSB7XG4gIGZvciAoY29uc3Qge1xuICAgIGZvcm1hdCxcbiAgICB0ZXN0LFxuICAgIHJlc29sdmVcbiAgfSBvZiB0YWdzKSB7XG4gICAgaWYgKHRlc3QpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gc3RyLm1hdGNoKHRlc3QpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IHJlcyA9IHJlc29sdmUuYXBwbHkobnVsbCwgbWF0Y2gpO1xuICAgICAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBTY2FsYXIpKSByZXMgPSBuZXcgU2NhbGFyKHJlcyk7XG4gICAgICAgIGlmIChmb3JtYXQpIHJlcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjYWxhckZhbGxiYWNrKSBzdHIgPSBzY2FsYXJGYWxsYmFjayhzdHIpO1xuICByZXR1cm4gbmV3IFNjYWxhcihzdHIpO1xufVxuXG5jb25zdCBGT0xEX0ZMT1cgPSAnZmxvdyc7XG5jb25zdCBGT0xEX0JMT0NLID0gJ2Jsb2NrJztcbmNvbnN0IEZPTERfUVVPVEVEID0gJ3F1b3RlZCc7IC8vIHByZXN1bWVzIGkrMSBpcyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lXG4vLyByZXR1cm5zIGluZGV4IG9mIGxhc3QgbmV3bGluZSBpbiBtb3JlLWluZGVudGVkIGJsb2NrXG5cbmNvbnN0IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyA9ICh0ZXh0LCBpKSA9PiB7XG4gIGxldCBjaCA9IHRleHRbaSArIDFdO1xuXG4gIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgIGRvIHtcbiAgICAgIGNoID0gdGV4dFtpICs9IDFdO1xuICAgIH0gd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyk7XG5cbiAgICBjaCA9IHRleHRbaSArIDFdO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59O1xuLyoqXG4gKiBUcmllcyB0byBrZWVwIGlucHV0IGF0IHVwIHRvIGBsaW5lV2lkdGhgIGNoYXJhY3RlcnMsIHNwbGl0dGluZyBvbmx5IG9uIHNwYWNlc1xuICogbm90IGZvbGxvd2VkIGJ5IG5ld2xpbmVzIG9yIHNwYWNlcyB1bmxlc3MgYG1vZGVgIGlzIGAncXVvdGVkJ2AuIExpbmVzIGFyZVxuICogdGVybWluYXRlZCB3aXRoIGBcXG5gIGFuZCBzdGFydGVkIHdpdGggYGluZGVudGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZT0nZmxvdyddIGAnYmxvY2snYCBwcmV2ZW50cyBtb3JlLWluZGVudGVkIGxpbmVzXG4gKiAgIGZyb20gYmVpbmcgZm9sZGVkOyBgJ3F1b3RlZCdgIGFsbG93cyBmb3IgYFxcYCBlc2NhcGVzLCBpbmNsdWRpbmcgZXNjYXBlZFxuICogICBuZXdsaW5lc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbmRlbnRBdFN0YXJ0XSBBY2NvdW50cyBmb3IgbGVhZGluZyBjb250ZW50cyBvblxuICogICB0aGUgZmlyc3QgbGluZSwgZGVmYXVsdGluZyB0byBgaW5kZW50Lmxlbmd0aGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lV2lkdGg9ODBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluQ29udGVudFdpZHRoPTIwXSBBbGxvdyBoaWdobHkgaW5kZW50ZWQgbGluZXMgdG9cbiAqICAgc3RyZXRjaCB0aGUgbGluZSB3aWR0aCBvciBpbmRlbnQgY29udGVudCBmcm9tIHRoZSBzdGFydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5vbkZvbGQgQ2FsbGVkIG9uY2UgaWYgdGhlIHRleHQgaXMgZm9sZGVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLm9uRm9sZCBDYWxsZWQgb25jZSBpZiBhbnkgbGluZSBvZiB0ZXh0IGV4Y2VlZHNcbiAqICAgbGluZVdpZHRoIGNoYXJhY3RlcnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvbGRGbG93TGluZXModGV4dCwgaW5kZW50LCBtb2RlLCB7XG4gIGluZGVudEF0U3RhcnQsXG4gIGxpbmVXaWR0aCA9IDgwLFxuICBtaW5Db250ZW50V2lkdGggPSAyMCxcbiAgb25Gb2xkLFxuICBvbk92ZXJmbG93XG59KSB7XG4gIGlmICghbGluZVdpZHRoIHx8IGxpbmVXaWR0aCA8IDApIHJldHVybiB0ZXh0O1xuICBjb25zdCBlbmRTdGVwID0gTWF0aC5tYXgoMSArIG1pbkNvbnRlbnRXaWR0aCwgMSArIGxpbmVXaWR0aCAtIGluZGVudC5sZW5ndGgpO1xuICBpZiAodGV4dC5sZW5ndGggPD0gZW5kU3RlcCkgcmV0dXJuIHRleHQ7XG4gIGNvbnN0IGZvbGRzID0gW107XG4gIGNvbnN0IGVzY2FwZWRGb2xkcyA9IHt9O1xuICBsZXQgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aDtcblxuICBpZiAodHlwZW9mIGluZGVudEF0U3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGluZGVudEF0U3RhcnQgPiBsaW5lV2lkdGggLSBNYXRoLm1heCgyLCBtaW5Db250ZW50V2lkdGgpKSBmb2xkcy5wdXNoKDApO2Vsc2UgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50QXRTdGFydDtcbiAgfVxuXG4gIGxldCBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgbGV0IHByZXYgPSB1bmRlZmluZWQ7XG4gIGxldCBvdmVyZmxvdyA9IGZhbHNlO1xuICBsZXQgaSA9IC0xO1xuICBsZXQgZXNjU3RhcnQgPSAtMTtcbiAgbGV0IGVzY0VuZCA9IC0xO1xuXG4gIGlmIChtb2RlID09PSBGT0xEX0JMT0NLKSB7XG4gICAgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKTtcbiAgICBpZiAoaSAhPT0gLTEpIGVuZCA9IGkgKyBlbmRTdGVwO1xuICB9XG5cbiAgZm9yIChsZXQgY2g7IGNoID0gdGV4dFtpICs9IDFdOykge1xuICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICBlc2NTdGFydCA9IGk7XG5cbiAgICAgIHN3aXRjaCAodGV4dFtpICsgMV0pIHtcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgaSArPSAzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGVzY0VuZCA9IGk7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgaWYgKG1vZGUgPT09IEZPTERfQkxPQ0spIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSk7XG4gICAgICBlbmQgPSBpICsgZW5kU3RlcDtcbiAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2ggPT09ICcgJyAmJiBwcmV2ICYmIHByZXYgIT09ICcgJyAmJiBwcmV2ICE9PSAnXFxuJyAmJiBwcmV2ICE9PSAnXFx0Jykge1xuICAgICAgICAvLyBzcGFjZSBzdXJyb3VuZGVkIGJ5IG5vbi1zcGFjZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCBuZXdsaW5lICsgaW5kZW50XG4gICAgICAgIGNvbnN0IG5leHQgPSB0ZXh0W2kgKyAxXTtcbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gJyAnICYmIG5leHQgIT09ICdcXG4nICYmIG5leHQgIT09ICdcXHQnKSBzcGxpdCA9IGk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID49IGVuZCkge1xuICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICBmb2xkcy5wdXNoKHNwbGl0KTtcbiAgICAgICAgICBlbmQgPSBzcGxpdCArIGVuZFN0ZXA7XG4gICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQpIHtcbiAgICAgICAgICAvLyB3aGl0ZS1zcGFjZSBjb2xsZWN0ZWQgYXQgZW5kIG1heSBzdHJldGNoIHBhc3QgbGluZVdpZHRoXG4gICAgICAgICAgd2hpbGUgKHByZXYgPT09ICcgJyB8fCBwcmV2ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgcHJldiA9IGNoO1xuICAgICAgICAgICAgY2ggPSB0ZXh0W2kgKz0gMV07XG4gICAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgfSAvLyBBY2NvdW50IGZvciBuZXdsaW5lIGVzY2FwZSwgYnV0IGRvbid0IGJyZWFrIHByZWNlZGluZyBlc2NhcGVcblxuXG4gICAgICAgICAgY29uc3QgaiA9IGkgPiBlc2NFbmQgKyAxID8gaSAtIDIgOiBlc2NTdGFydCAtIDE7IC8vIEJhaWwgb3V0IGlmIGxpbmVXaWR0aCAmIG1pbkNvbnRlbnRXaWR0aCBhcmUgc2hvcnRlciB0aGFuIGFuIGVzY2FwZSBzdHJpbmdcblxuICAgICAgICAgIGlmIChlc2NhcGVkRm9sZHNbal0pIHJldHVybiB0ZXh0O1xuICAgICAgICAgIGZvbGRzLnB1c2goaik7XG4gICAgICAgICAgZXNjYXBlZEZvbGRzW2pdID0gdHJ1ZTtcbiAgICAgICAgICBlbmQgPSBqICsgZW5kU3RlcDtcbiAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2ID0gY2g7XG4gIH1cblxuICBpZiAob3ZlcmZsb3cgJiYgb25PdmVyZmxvdykgb25PdmVyZmxvdygpO1xuICBpZiAoZm9sZHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGV4dDtcbiAgaWYgKG9uRm9sZCkgb25Gb2xkKCk7XG4gIGxldCByZXMgPSB0ZXh0LnNsaWNlKDAsIGZvbGRzWzBdKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgZm9sZCA9IGZvbGRzW2ldO1xuICAgIGNvbnN0IGVuZCA9IGZvbGRzW2kgKyAxXSB8fCB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoZm9sZCA9PT0gMCkgcmVzID0gYFxcbiR7aW5kZW50fSR7dGV4dC5zbGljZSgwLCBlbmQpfWA7ZWxzZSB7XG4gICAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgZXNjYXBlZEZvbGRzW2ZvbGRdKSByZXMgKz0gYCR7dGV4dFtmb2xkXX1cXFxcYDtcbiAgICAgIHJlcyArPSBgXFxuJHtpbmRlbnR9JHt0ZXh0LnNsaWNlKGZvbGQgKyAxLCBlbmQpfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgZ2V0Rm9sZE9wdGlvbnMgPSAoe1xuICBpbmRlbnRBdFN0YXJ0XG59KSA9PiBpbmRlbnRBdFN0YXJ0ID8gT2JqZWN0LmFzc2lnbih7XG4gIGluZGVudEF0U3RhcnRcbn0sIHN0ck9wdGlvbnMuZm9sZCkgOiBzdHJPcHRpb25zLmZvbGQ7IC8vIEFsc28gY2hlY2tzIGZvciBsaW5lcyBzdGFydGluZyB3aXRoICUsIGFzIHBhcnNpbmcgdGhlIG91dHB1dCBhcyBZQU1MIDEuMSB3aWxsXG4vLyBwcmVzdW1lIHRoYXQncyBzdGFydGluZyBhIG5ldyBkb2N1bWVudC5cblxuXG5jb25zdCBjb250YWluc0RvY3VtZW50TWFya2VyID0gc3RyID0+IC9eKCV8LS0tfFxcLlxcLlxcLikvbS50ZXN0KHN0cik7XG5cbmZ1bmN0aW9uIGxpbmVMZW5ndGhPdmVyTGltaXQoc3RyLCBsaW5lV2lkdGgsIGluZGVudExlbmd0aCkge1xuICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGxpbWl0ID0gbGluZVdpZHRoIC0gaW5kZW50TGVuZ3RoO1xuICBjb25zdCBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuICBpZiAoc3RyTGVuIDw9IGxpbWl0KSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gMDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gJ1xcbicpIHtcbiAgICAgIGlmIChpIC0gc3RhcnQgPiBsaW1pdCkgcmV0dXJuIHRydWU7XG4gICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgaWYgKHN0ckxlbiAtIHN0YXJ0IDw9IGxpbWl0KSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBpbXBsaWNpdEtleVxuICB9ID0gY3R4O1xuICBjb25zdCB7XG4gICAganNvbkVuY29kaW5nLFxuICAgIG1pbk11bHRpTGluZUxlbmd0aFxuICB9ID0gc3RyT3B0aW9ucy5kb3VibGVRdW90ZWQ7XG4gIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIGlmIChqc29uRW5jb2RpbmcpIHJldHVybiBqc29uO1xuICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gIGxldCBzdHIgPSAnJztcbiAgbGV0IHN0YXJ0ID0gMDtcblxuICBmb3IgKGxldCBpID0gMCwgY2ggPSBqc29uW2ldOyBjaDsgY2ggPSBqc29uWysraV0pIHtcbiAgICBpZiAoY2ggPT09ICcgJyAmJiBqc29uW2kgKyAxXSA9PT0gJ1xcXFwnICYmIGpzb25baSArIDJdID09PSAnbicpIHtcbiAgICAgIC8vIHNwYWNlIGJlZm9yZSBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcXFwgJztcbiAgICAgIGkgKz0gMTtcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICAgIGNoID0gJ1xcXFwnO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJ1xcXFwnKSBzd2l0Y2ggKGpzb25baSArIDFdKSB7XG4gICAgICBjYXNlICd1JzpcbiAgICAgICAge1xuICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICBjb25zdCBjb2RlID0ganNvbi5zdWJzdHIoaSArIDIsIDQpO1xuXG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlICcwMDAwJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcMCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDA3JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcYSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDBiJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDFiJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcZSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMDg1JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwMGEwJzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcXyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcyMDI4JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcyMDI5JzpcbiAgICAgICAgICAgICAgc3RyICs9ICdcXFxcUCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoY29kZS5zdWJzdHIoMCwgMikgPT09ICcwMCcpIHN0ciArPSAnXFxcXHgnICsgY29kZS5zdWJzdHIoMik7ZWxzZSBzdHIgKz0ganNvbi5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA1O1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ24nOlxuICAgICAgICBpZiAoaW1wbGljaXRLZXkgfHwganNvbltpICsgMl0gPT09ICdcIicgfHwganNvbi5sZW5ndGggPCBtaW5NdWx0aUxpbmVMZW5ndGgpIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZm9sZGluZyB3aWxsIGVhdCBmaXJzdCBuZXdsaW5lXG4gICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcblxcbic7XG5cbiAgICAgICAgICB3aGlsZSAoanNvbltpICsgMl0gPT09ICdcXFxcJyAmJiBqc29uW2kgKyAzXSA9PT0gJ24nICYmIGpzb25baSArIDRdICE9PSAnXCInKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyICs9IGluZGVudDsgLy8gc3BhY2UgYWZ0ZXIgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcblxuICAgICAgICAgIGlmIChqc29uW2kgKyAyXSA9PT0gJyAnKSBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGkgKz0gMTtcbiAgICB9XG4gIH1cblxuICBzdHIgPSBzdGFydCA/IHN0ciArIGpzb24uc2xpY2Uoc3RhcnQpIDoganNvbjtcbiAgcmV0dXJuIGltcGxpY2l0S2V5ID8gc3RyIDogZm9sZEZsb3dMaW5lcyhzdHIsIGluZGVudCwgRk9MRF9RVU9URUQsIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICBpZiAoY3R4LmltcGxpY2l0S2V5KSB7XG4gICAgaWYgKC9cXG4vLnRlc3QodmFsdWUpKSByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHNpbmdsZSBxdW90ZWQgc3RyaW5nIGNhbid0IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBuZXdsaW5lXG4gICAgaWYgKC9bIFxcdF1cXG58XFxuWyBcXHRdLy50ZXN0KHZhbHVlKSkgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgfVxuXG4gIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgY29uc3QgcmVzID0gXCInXCIgKyB2YWx1ZS5yZXBsYWNlKC8nL2csIFwiJydcIikucmVwbGFjZSgvXFxuKy9nLCBgJCZcXG4ke2luZGVudH1gKSArIFwiJ1wiO1xuICByZXR1cm4gY3R4LmltcGxpY2l0S2V5ID8gcmVzIDogZm9sZEZsb3dMaW5lcyhyZXMsIGluZGVudCwgRk9MRF9GTE9XLCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbn1cblxuZnVuY3Rpb24gYmxvY2tTdHJpbmcoe1xuICBjb21tZW50LFxuICB0eXBlLFxuICB2YWx1ZVxufSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gIC8vIDEuIEJsb2NrIGNhbid0IGVuZCBpbiB3aGl0ZXNwYWNlIHVubGVzcyB0aGUgbGFzdCBsaW5lIGlzIG5vbi1lbXB0eS5cbiAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICBpZiAoL1xcbltcXHQgXSskLy50ZXN0KHZhbHVlKSB8fCAvXlxccyokLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gIH1cblxuICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjdHguZm9yY2VCbG9ja0luZGVudCB8fCBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gIGNvbnN0IGluZGVudFNpemUgPSBpbmRlbnQgPyAnMicgOiAnMSc7IC8vIHJvb3QgaXMgYXQgLTFcblxuICBjb25zdCBsaXRlcmFsID0gdHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkJMT0NLX0ZPTERFRCA/IGZhbHNlIDogdHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkJMT0NLX0xJVEVSQUwgPyB0cnVlIDogIWxpbmVMZW5ndGhPdmVyTGltaXQodmFsdWUsIHN0ck9wdGlvbnMuZm9sZC5saW5lV2lkdGgsIGluZGVudC5sZW5ndGgpO1xuICBsZXQgaGVhZGVyID0gbGl0ZXJhbCA/ICd8JyA6ICc+JztcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIGhlYWRlciArICdcXG4nO1xuICBsZXQgd3NTdGFydCA9ICcnO1xuICBsZXQgd3NFbmQgPSAnJztcbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXFxuXFx0IF0qJC8sIHdzID0+IHtcbiAgICBjb25zdCBuID0gd3MuaW5kZXhPZignXFxuJyk7XG5cbiAgICBpZiAobiA9PT0gLTEpIHtcbiAgICAgIGhlYWRlciArPSAnLSc7IC8vIHN0cmlwXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gd3MgfHwgbiAhPT0gd3MubGVuZ3RoIC0gMSkge1xuICAgICAgaGVhZGVyICs9ICcrJzsgLy8ga2VlcFxuXG4gICAgICBpZiAob25DaG9tcEtlZXApIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuXG4gICAgd3NFbmQgPSB3cy5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgIHJldHVybiAnJztcbiAgfSkucmVwbGFjZSgvXltcXG4gXSovLCB3cyA9PiB7XG4gICAgaWYgKHdzLmluZGV4T2YoJyAnKSAhPT0gLTEpIGhlYWRlciArPSBpbmRlbnRTaXplO1xuICAgIGNvbnN0IG0gPSB3cy5tYXRjaCgvICskLyk7XG5cbiAgICBpZiAobSkge1xuICAgICAgd3NTdGFydCA9IHdzLnNsaWNlKDAsIC1tWzBdLmxlbmd0aCk7XG4gICAgICByZXR1cm4gbVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3NTdGFydCA9IHdzO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSk7XG4gIGlmICh3c0VuZCkgd3NFbmQgPSB3c0VuZC5yZXBsYWNlKC9cXG4rKD8hXFxufCQpL2csIGAkJiR7aW5kZW50fWApO1xuICBpZiAod3NTdGFydCkgd3NTdGFydCA9IHdzU3RhcnQucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcblxuICBpZiAoY29tbWVudCkge1xuICAgIGhlYWRlciArPSAnICMnICsgY29tbWVudC5yZXBsYWNlKC8gP1tcXHJcXG5dKy9nLCAnICcpO1xuICAgIGlmIChvbkNvbW1lbnQpIG9uQ29tbWVudCgpO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIGAke2hlYWRlcn0ke2luZGVudFNpemV9XFxuJHtpbmRlbnR9JHt3c0VuZH1gO1xuXG4gIGlmIChsaXRlcmFsKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIHJldHVybiBgJHtoZWFkZXJ9XFxuJHtpbmRlbnR9JHt3c1N0YXJ0fSR7dmFsdWV9JHt3c0VuZH1gO1xuICB9XG5cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csICdcXG4kJicpLnJlcGxhY2UoLyg/Ol58XFxuKShbXFx0IF0uKikoPzooW1xcblxcdCBdKilcXG4oPyFbXFxuXFx0IF0pKT8vZywgJyQxJDInKSAvLyBtb3JlLWluZGVudGVkIGxpbmVzIGFyZW4ndCBmb2xkZWRcbiAgLy8gICAgICAgICBeIGluZC5saW5lICBeIGVtcHR5ICAgICBeIGNhcHR1cmUgbmV4dCBlbXB0eSBsaW5lcyBvbmx5IGF0IGVuZCBvZiBpbmRlbnRcbiAgLnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gIGNvbnN0IGJvZHkgPSBmb2xkRmxvd0xpbmVzKGAke3dzU3RhcnR9JHt2YWx1ZX0ke3dzRW5kfWAsIGluZGVudCwgRk9MRF9CTE9DSywgc3RyT3B0aW9ucy5mb2xkKTtcbiAgcmV0dXJuIGAke2hlYWRlcn1cXG4ke2luZGVudH0ke2JvZHl9YDtcbn1cblxuZnVuY3Rpb24gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gIGNvbnN0IHtcbiAgICBjb21tZW50LFxuICAgIHR5cGUsXG4gICAgdmFsdWVcbiAgfSA9IGl0ZW07XG4gIGNvbnN0IHtcbiAgICBhY3R1YWxTdHJpbmcsXG4gICAgaW1wbGljaXRLZXksXG4gICAgaW5kZW50LFxuICAgIGluRmxvd1xuICB9ID0gY3R4O1xuXG4gIGlmIChpbXBsaWNpdEtleSAmJiAvW1xcbltcXF17fSxdLy50ZXN0KHZhbHVlKSB8fCBpbkZsb3cgJiYgL1tbXFxde30sXS8udGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSB8fCAvXltcXG5cXHQgLFtcXF17fSMmKiF8PidcIiVAYF18Xls/LV0kfF5bPy1dWyBcXHRdfFtcXG46XVsgXFx0XXxbIFxcdF1cXG58W1xcblxcdCBdI3xbXFxuXFx0IDpdJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAvLyBub3QgYWxsb3dlZDpcbiAgICAvLyAtIGVtcHR5IHN0cmluZywgJy0nIG9yICc/J1xuICAgIC8vIC0gc3RhcnQgd2l0aCBhbiBpbmRpY2F0b3IgY2hhcmFjdGVyIChleGNlcHQgWz86LV0pIG9yIC9bPy1dIC9cbiAgICAvLyAtICdcXG4gJywgJzogJyBvciAnIFxcbicgYW55d2hlcmVcbiAgICAvLyAtICcjJyBub3QgcHJlY2VkZWQgYnkgYSBub24tc3BhY2UgY2hhclxuICAgIC8vIC0gZW5kIHdpdGggJyAnIG9yICc6J1xuICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3cgfHwgdmFsdWUuaW5kZXhPZignXFxuJykgPT09IC0xID8gdmFsdWUuaW5kZXhPZignXCInKSAhPT0gLTEgJiYgdmFsdWUuaW5kZXhPZihcIidcIikgPT09IC0xID8gc2luZ2xlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIDogZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIDogYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfVxuXG4gIGlmICghaW1wbGljaXRLZXkgJiYgIWluRmxvdyAmJiB0eXBlICE9PSBQbGFpblZhbHVlLlR5cGUuUExBSU4gJiYgdmFsdWUuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgLy8gV2hlcmUgYWxsb3dlZCAmIHR5cGUgbm90IHNldCBleHBsaWNpdGx5LCBwcmVmZXIgYmxvY2sgc3R5bGUgZm9yIG11bHRpbGluZSBzdHJpbmdzXG4gICAgcmV0dXJuIGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gIH1cblxuICBpZiAoaW5kZW50ID09PSAnJyAmJiBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSkge1xuICAgIGN0eC5mb3JjZUJsb2NrSW5kZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfVxuXG4gIGNvbnN0IHN0ciA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgYCQmXFxuJHtpbmRlbnR9YCk7IC8vIFZlcmlmeSB0aGF0IG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgYXMgZS5nLiBwbGFpbiBudW1iZXJzIGFuZFxuICAvLyBib29sZWFucyBnZXQgcGFyc2VkIHdpdGggdGhvc2UgdHlwZXMgaW4gdjEuMiAoZS5nLiAnNDInLCAndHJ1ZScgJiAnMC45ZS0zJyksXG4gIC8vIGFuZCBvdGhlcnMgaW4gdjEuMS5cblxuICBpZiAoYWN0dWFsU3RyaW5nKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFnc1xuICAgIH0gPSBjdHguZG9jLnNjaGVtYTtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVTY2FsYXIoc3RyLCB0YWdzLCB0YWdzLnNjYWxhckZhbGxiYWNrKS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVkICE9PSAnc3RyaW5nJykgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgfVxuXG4gIGNvbnN0IGJvZHkgPSBpbXBsaWNpdEtleSA/IHN0ciA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG5cbiAgaWYgKGNvbW1lbnQgJiYgIWluRmxvdyAmJiAoYm9keS5pbmRleE9mKCdcXG4nKSAhPT0gLTEgfHwgY29tbWVudC5pbmRleE9mKCdcXG4nKSAhPT0gLTEpKSB7XG4gICAgaWYgKG9uQ29tbWVudCkgb25Db21tZW50KCk7XG4gICAgcmV0dXJuIGFkZENvbW1lbnRCZWZvcmUoYm9keSwgaW5kZW50LCBjb21tZW50KTtcbiAgfVxuXG4gIHJldHVybiBib2R5O1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gIGNvbnN0IHtcbiAgICBkZWZhdWx0VHlwZVxuICB9ID0gc3RyT3B0aW9ucztcbiAgY29uc3Qge1xuICAgIGltcGxpY2l0S2V5LFxuICAgIGluRmxvd1xuICB9ID0gY3R4O1xuICBsZXQge1xuICAgIHR5cGUsXG4gICAgdmFsdWVcbiAgfSA9IGl0ZW07XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0sIHtcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBfc3RyaW5naWZ5ID0gX3R5cGUgPT4ge1xuICAgIHN3aXRjaCAoX3R5cGUpIHtcbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkJMT0NLX0ZPTERFRDpcbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkJMT0NLX0xJVEVSQUw6XG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuXG4gICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5RVU9URV9ET1VCTEU6XG4gICAgICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG5cbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLlFVT1RFX1NJTkdMRTpcbiAgICAgICAgcmV0dXJuIHNpbmdsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcblxuICAgICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuUExBSU46XG4gICAgICAgIHJldHVybiBwbGFpblN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgaWYgKHR5cGUgIT09IFBsYWluVmFsdWUuVHlwZS5RVU9URV9ET1VCTEUgJiYgL1tcXHgwMC1cXHgwOFxceDBiLVxceDFmXFx4N2YtXFx4OWZdLy50ZXN0KHZhbHVlKSkge1xuICAgIC8vIGZvcmNlIGRvdWJsZSBxdW90ZXMgb24gY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgdHlwZSA9IFBsYWluVmFsdWUuVHlwZS5RVU9URV9ET1VCTEU7XG4gIH0gZWxzZSBpZiAoKGltcGxpY2l0S2V5IHx8IGluRmxvdykgJiYgKHR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5CTE9DS19GT0xERUQgfHwgdHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkJMT0NLX0xJVEVSQUwpKSB7XG4gICAgLy8gc2hvdWxkIG5vdCBoYXBwZW47IGJsb2NrcyBhcmUgbm90IHZhbGlkIGluc2lkZSBmbG93IGNvbnRhaW5lcnNcbiAgICB0eXBlID0gUGxhaW5WYWx1ZS5UeXBlLlFVT1RFX0RPVUJMRTtcbiAgfVxuXG4gIGxldCByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuXG4gIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICByZXMgPSBfc3RyaW5naWZ5KGRlZmF1bHRUeXBlKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlZmF1bHQgc3RyaW5nIHR5cGUgJHtkZWZhdWx0VHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU51bWJlcih7XG4gIGZvcm1hdCxcbiAgbWluRnJhY3Rpb25EaWdpdHMsXG4gIHRhZyxcbiAgdmFsdWVcbn0pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICBpZiAoIWlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIGlzTmFOKHZhbHVlKSA/ICcubmFuJyA6IHZhbHVlIDwgMCA/ICctLmluZicgOiAnLmluZic7XG4gIGxldCBuID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gIGlmICghZm9ybWF0ICYmIG1pbkZyYWN0aW9uRGlnaXRzICYmICghdGFnIHx8IHRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JykgJiYgL15cXGQvLnRlc3QobikpIHtcbiAgICBsZXQgaSA9IG4uaW5kZXhPZignLicpO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBpID0gbi5sZW5ndGg7XG4gICAgICBuICs9ICcuJztcbiAgICB9XG5cbiAgICBsZXQgZCA9IG1pbkZyYWN0aW9uRGlnaXRzIC0gKG4ubGVuZ3RoIC0gaSAtIDEpO1xuXG4gICAgd2hpbGUgKGQtLSA+IDApIG4gKz0gJzAnO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGNoZWNrRmxvd0NvbGxlY3Rpb25FbmQoZXJyb3JzLCBjc3QpIHtcbiAgbGV0IGNoYXIsIG5hbWU7XG5cbiAgc3dpdGNoIChjc3QudHlwZSkge1xuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkZMT1dfTUFQOlxuICAgICAgY2hhciA9ICd9JztcbiAgICAgIG5hbWUgPSAnZmxvdyBtYXAnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5GTE9XX1NFUTpcbiAgICAgIGNoYXIgPSAnXSc7XG4gICAgICBuYW1lID0gJ2Zsb3cgc2VxdWVuY2UnO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoY3N0LCAnTm90IGEgZmxvdyBjb2xsZWN0aW9uIT8nKSk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBsZXQgbGFzdEl0ZW07XG5cbiAgZm9yIChsZXQgaSA9IGNzdC5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGNvbnN0IGl0ZW0gPSBjc3QuaXRlbXNbaV07XG5cbiAgICBpZiAoIWl0ZW0gfHwgaXRlbS50eXBlICE9PSBQbGFpblZhbHVlLlR5cGUuQ09NTUVOVCkge1xuICAgICAgbGFzdEl0ZW0gPSBpdGVtO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhc3RJdGVtICYmIGxhc3RJdGVtLmNoYXIgIT09IGNoYXIpIHtcbiAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtuYW1lfSB0byBlbmQgd2l0aCAke2NoYXJ9YDtcbiAgICBsZXQgZXJyO1xuXG4gICAgaWYgKHR5cGVvZiBsYXN0SXRlbS5vZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnIgPSBuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihjc3QsIG1zZyk7XG4gICAgICBlcnIub2Zmc2V0ID0gbGFzdEl0ZW0ub2Zmc2V0ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyID0gbmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IobGFzdEl0ZW0sIG1zZyk7XG4gICAgICBpZiAobGFzdEl0ZW0ucmFuZ2UgJiYgbGFzdEl0ZW0ucmFuZ2UuZW5kKSBlcnIub2Zmc2V0ID0gbGFzdEl0ZW0ucmFuZ2UuZW5kIC0gbGFzdEl0ZW0ucmFuZ2Uuc3RhcnQ7XG4gICAgfVxuXG4gICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tGbG93Q29tbWVudFNwYWNlKGVycm9ycywgY29tbWVudCkge1xuICBjb25zdCBwcmV2ID0gY29tbWVudC5jb250ZXh0LnNyY1tjb21tZW50LnJhbmdlLnN0YXJ0IC0gMV07XG5cbiAgaWYgKHByZXYgIT09ICdcXG4nICYmIHByZXYgIT09ICdcXHQnICYmIHByZXYgIT09ICcgJykge1xuICAgIGNvbnN0IG1zZyA9ICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJztcbiAgICBlcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihjb21tZW50LCBtc2cpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9uZ0tleUVycm9yKHNvdXJjZSwga2V5KSB7XG4gIGNvbnN0IHNrID0gU3RyaW5nKGtleSk7XG4gIGNvbnN0IGsgPSBzay5zdWJzdHIoMCwgOCkgKyAnLi4uJyArIHNrLnN1YnN0cigtOCk7XG4gIHJldHVybiBuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihzb3VyY2UsIGBUaGUgXCIke2t9XCIga2V5IGlzIHRvbyBsb25nYCk7XG59XG5mdW5jdGlvbiByZXNvbHZlQ29tbWVudHMoY29sbGVjdGlvbiwgY29tbWVudHMpIHtcbiAgZm9yIChjb25zdCB7XG4gICAgYWZ0ZXJLZXksXG4gICAgYmVmb3JlLFxuICAgIGNvbW1lbnRcbiAgfSBvZiBjb21tZW50cykge1xuICAgIGxldCBpdGVtID0gY29sbGVjdGlvbi5pdGVtc1tiZWZvcmVdO1xuXG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uLmNvbW1lbnQpIGNvbGxlY3Rpb24uY29tbWVudCArPSAnXFxuJyArIGNvbW1lbnQ7ZWxzZSBjb2xsZWN0aW9uLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYWZ0ZXJLZXkgJiYgaXRlbS52YWx1ZSkgaXRlbSA9IGl0ZW0udmFsdWU7XG5cbiAgICAgIGlmIChjb21tZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFmdGVyS2V5IHx8ICFpdGVtLmNvbW1lbnRCZWZvcmUpIGl0ZW0uc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW0uY29tbWVudEJlZm9yZSkgaXRlbS5jb21tZW50QmVmb3JlICs9ICdcXG4nICsgY29tbWVudDtlbHNlIGl0ZW0uY29tbWVudEJlZm9yZSA9IGNvbW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIG9uIGVycm9yLCB3aWxsIHJldHVybiB7IHN0cjogc3RyaW5nLCBlcnJvcnM6IEVycm9yW10gfVxuZnVuY3Rpb24gcmVzb2x2ZVN0cmluZyhkb2MsIG5vZGUpIHtcbiAgY29uc3QgcmVzID0gbm9kZS5zdHJWYWx1ZTtcbiAgaWYgKCFyZXMpIHJldHVybiAnJztcbiAgaWYgKHR5cGVvZiByZXMgPT09ICdzdHJpbmcnKSByZXR1cm4gcmVzO1xuICByZXMuZXJyb3JzLmZvckVhY2goZXJyb3IgPT4ge1xuICAgIGlmICghZXJyb3Iuc291cmNlKSBlcnJvci5zb3VyY2UgPSBub2RlO1xuICAgIGRvYy5lcnJvcnMucHVzaChlcnJvcik7XG4gIH0pO1xuICByZXR1cm4gcmVzLnN0cjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZ0hhbmRsZShkb2MsIG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZSxcbiAgICBzdWZmaXhcbiAgfSA9IG5vZGUudGFnO1xuICBsZXQgcHJlZml4ID0gZG9jLnRhZ1ByZWZpeGVzLmZpbmQocCA9PiBwLmhhbmRsZSA9PT0gaGFuZGxlKTtcblxuICBpZiAoIXByZWZpeCkge1xuICAgIGNvbnN0IGR0cCA9IGRvYy5nZXREZWZhdWx0cygpLnRhZ1ByZWZpeGVzO1xuICAgIGlmIChkdHApIHByZWZpeCA9IGR0cC5maW5kKHAgPT4gcC5oYW5kbGUgPT09IGhhbmRsZSk7XG4gICAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIGBUaGUgJHtoYW5kbGV9IHRhZyBoYW5kbGUgaXMgbm9uLWRlZmF1bHQgYW5kIHdhcyBub3QgZGVjbGFyZWQuYCk7XG4gIH1cblxuICBpZiAoIXN1ZmZpeCkgdGhyb3cgbmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgYFRoZSAke2hhbmRsZX0gdGFnIGhhcyBubyBzdWZmaXguYCk7XG5cbiAgaWYgKGhhbmRsZSA9PT0gJyEnICYmIChkb2MudmVyc2lvbiB8fCBkb2Mub3B0aW9ucy52ZXJzaW9uKSA9PT0gJzEuMCcpIHtcbiAgICBpZiAoc3VmZml4WzBdID09PSAnXicpIHtcbiAgICAgIGRvYy53YXJuaW5ncy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxXYXJuaW5nKG5vZGUsICdZQU1MIDEuMCBeIHRhZyBleHBhbnNpb24gaXMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgIHJldHVybiBzdWZmaXg7XG4gICAgfVxuXG4gICAgaWYgKC9bOi9dLy50ZXN0KHN1ZmZpeCkpIHtcbiAgICAgIC8vIHdvcmQvZm9vIC0+IHRhZzp3b3JkLnlhbWwub3JnLDIwMDI6Zm9vXG4gICAgICBjb25zdCB2b2NhYiA9IHN1ZmZpeC5tYXRjaCgvXihbYS16MC05LV0rKVxcLyguKikvaSk7XG4gICAgICByZXR1cm4gdm9jYWIgPyBgdGFnOiR7dm9jYWJbMV19LnlhbWwub3JnLDIwMDI6JHt2b2NhYlsyXX1gIDogYHRhZzoke3N1ZmZpeH1gO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmVmaXgucHJlZml4ICsgZGVjb2RlVVJJQ29tcG9uZW50KHN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUYWdOYW1lKGRvYywgbm9kZSkge1xuICBjb25zdCB7XG4gICAgdGFnLFxuICAgIHR5cGVcbiAgfSA9IG5vZGU7XG4gIGxldCBub25TcGVjaWZpYyA9IGZhbHNlO1xuXG4gIGlmICh0YWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBoYW5kbGUsXG4gICAgICBzdWZmaXgsXG4gICAgICB2ZXJiYXRpbVxuICAgIH0gPSB0YWc7XG5cbiAgICBpZiAodmVyYmF0aW0pIHtcbiAgICAgIGlmICh2ZXJiYXRpbSAhPT0gJyEnICYmIHZlcmJhdGltICE9PSAnISEnKSByZXR1cm4gdmVyYmF0aW07XG4gICAgICBjb25zdCBtc2cgPSBgVmVyYmF0aW0gdGFncyBhcmVuJ3QgcmVzb2x2ZWQsIHNvICR7dmVyYmF0aW19IGlzIGludmFsaWQuYDtcbiAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihub2RlLCBtc2cpKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZSA9PT0gJyEnICYmICFzdWZmaXgpIHtcbiAgICAgIG5vblNwZWNpZmljID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUYWdIYW5kbGUoZG9jLCBub2RlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRvYy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuQkxPQ0tfRk9MREVEOlxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkJMT0NLX0xJVEVSQUw6XG4gICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuUVVPVEVfRE9VQkxFOlxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLlFVT1RFX1NJTkdMRTpcbiAgICAgIHJldHVybiBQbGFpblZhbHVlLmRlZmF1bHRUYWdzLlNUUjtcblxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkZMT1dfTUFQOlxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLk1BUDpcbiAgICAgIHJldHVybiBQbGFpblZhbHVlLmRlZmF1bHRUYWdzLk1BUDtcblxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkZMT1dfU0VROlxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLlNFUTpcbiAgICAgIHJldHVybiBQbGFpblZhbHVlLmRlZmF1bHRUYWdzLlNFUTtcblxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLlBMQUlOOlxuICAgICAgcmV0dXJuIG5vblNwZWNpZmljID8gUGxhaW5WYWx1ZS5kZWZhdWx0VGFncy5TVFIgOiBudWxsO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVCeVRhZ05hbWUoZG9jLCBub2RlLCB0YWdOYW1lKSB7XG4gIGNvbnN0IHtcbiAgICB0YWdzXG4gIH0gPSBkb2Muc2NoZW1hO1xuICBjb25zdCBtYXRjaFdpdGhUZXN0ID0gW107XG5cbiAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgIGlmICh0YWcudGFnID09PSB0YWdOYW1lKSB7XG4gICAgICBpZiAodGFnLnRlc3QpIG1hdGNoV2l0aFRlc3QucHVzaCh0YWcpO2Vsc2Uge1xuICAgICAgICBjb25zdCByZXMgPSB0YWcucmVzb2x2ZShkb2MsIG5vZGUpO1xuICAgICAgICByZXR1cm4gcmVzIGluc3RhbmNlb2YgQ29sbGVjdGlvbiA/IHJlcyA6IG5ldyBTY2FsYXIocmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHIgPSByZXNvbHZlU3RyaW5nKGRvYywgbm9kZSk7XG4gIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJiBtYXRjaFdpdGhUZXN0Lmxlbmd0aCA+IDApIHJldHVybiByZXNvbHZlU2NhbGFyKHN0ciwgbWF0Y2hXaXRoVGVzdCwgdGFncy5zY2FsYXJGYWxsYmFjayk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRGYWxsYmFja1RhZ05hbWUoe1xuICB0eXBlXG59KSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkZMT1dfTUFQOlxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLk1BUDpcbiAgICAgIHJldHVybiBQbGFpblZhbHVlLmRlZmF1bHRUYWdzLk1BUDtcblxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLkZMT1dfU0VROlxuICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLlNFUTpcbiAgICAgIHJldHVybiBQbGFpblZhbHVlLmRlZmF1bHRUYWdzLlNFUTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUGxhaW5WYWx1ZS5kZWZhdWx0VGFncy5TVFI7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhZyhkb2MsIG5vZGUsIHRhZ05hbWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSByZXNvbHZlQnlUYWdOYW1lKGRvYywgbm9kZSwgdGFnTmFtZSk7XG5cbiAgICBpZiAocmVzKSB7XG4gICAgICBpZiAodGFnTmFtZSAmJiBub2RlLnRhZykgcmVzLnRhZyA9IHRhZ05hbWU7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWVycm9yLnNvdXJjZSkgZXJyb3Iuc291cmNlID0gbm9kZTtcbiAgICBkb2MuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBmYWxsYmFjayA9IGdldEZhbGxiYWNrVGFnTmFtZShub2RlKTtcbiAgICBpZiAoIWZhbGxiYWNrKSB0aHJvdyBuZXcgRXJyb3IoYFRoZSB0YWcgJHt0YWdOYW1lfSBpcyB1bmF2YWlsYWJsZWApO1xuICAgIGNvbnN0IG1zZyA9IGBUaGUgdGFnICR7dGFnTmFtZX0gaXMgdW5hdmFpbGFibGUsIGZhbGxpbmcgYmFjayB0byAke2ZhbGxiYWNrfWA7XG4gICAgZG9jLndhcm5pbmdzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFdhcm5pbmcobm9kZSwgbXNnKSk7XG4gICAgY29uc3QgcmVzID0gcmVzb2x2ZUJ5VGFnTmFtZShkb2MsIG5vZGUsIGZhbGxiYWNrKTtcbiAgICByZXMudGFnID0gdGFnTmFtZTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IHJlZkVycm9yID0gbmV3IFBsYWluVmFsdWUuWUFNTFJlZmVyZW5jZUVycm9yKG5vZGUsIGVycm9yLm1lc3NhZ2UpO1xuICAgIHJlZkVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgZG9jLmVycm9ycy5wdXNoKHJlZkVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBpc0NvbGxlY3Rpb25JdGVtID0gbm9kZSA9PiB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gbm9kZTtcbiAgcmV0dXJuIHR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5NQVBfS0VZIHx8IHR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5NQVBfVkFMVUUgfHwgdHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLlNFUV9JVEVNO1xufTtcblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGVQcm9wcyhlcnJvcnMsIG5vZGUpIHtcbiAgY29uc3QgY29tbWVudHMgPSB7XG4gICAgYmVmb3JlOiBbXSxcbiAgICBhZnRlcjogW11cbiAgfTtcbiAgbGV0IGhhc0FuY2hvciA9IGZhbHNlO1xuICBsZXQgaGFzVGFnID0gZmFsc2U7XG4gIGNvbnN0IHByb3BzID0gaXNDb2xsZWN0aW9uSXRlbShub2RlLmNvbnRleHQucGFyZW50KSA/IG5vZGUuY29udGV4dC5wYXJlbnQucHJvcHMuY29uY2F0KG5vZGUucHJvcHMpIDogbm9kZS5wcm9wcztcblxuICBmb3IgKGNvbnN0IHtcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgfSBvZiBwcm9wcykge1xuICAgIHN3aXRjaCAobm9kZS5jb250ZXh0LnNyY1tzdGFydF0pIHtcbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5DaGFyLkNPTU1FTlQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIW5vZGUuY29tbWVudEhhc1JlcXVpcmVkV2hpdGVzcGFjZShzdGFydCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJztcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIG1zZykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgIHZhbHVlUmFuZ2VcbiAgICAgICAgICB9ID0gbm9kZTtcbiAgICAgICAgICBjb25zdCBjYyA9IHZhbHVlUmFuZ2UgJiYgKHN0YXJ0ID4gdmFsdWVSYW5nZS5zdGFydCB8fCBoZWFkZXIgJiYgc3RhcnQgPiBoZWFkZXIuc3RhcnQpID8gY29tbWVudHMuYWZ0ZXIgOiBjb21tZW50cy5iZWZvcmU7XG4gICAgICAgICAgY2MucHVzaChub2RlLmNvbnRleHQuc3JjLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIEFjdHVhbCBhbmNob3IgJiB0YWcgcmVzb2x1dGlvbiBpcyBoYW5kbGVkIGJ5IHNjaGVtYSwgaGVyZSB3ZSBqdXN0IGNvbXBsYWluXG5cbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5DaGFyLkFOQ0hPUjpcbiAgICAgICAgaWYgKGhhc0FuY2hvcikge1xuICAgICAgICAgIGNvbnN0IG1zZyA9ICdBIG5vZGUgY2FuIGhhdmUgYXQgbW9zdCBvbmUgYW5jaG9yJztcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0FuY2hvciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFBsYWluVmFsdWUuQ2hhci5UQUc6XG4gICAgICAgIGlmIChoYXNUYWcpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIHRhZyc7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3Iobm9kZSwgbXNnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNUYWcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbW1lbnRzLFxuICAgIGhhc0FuY2hvcixcbiAgICBoYXNUYWdcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGVWYWx1ZShkb2MsIG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvcnMsXG4gICAgZXJyb3JzLFxuICAgIHNjaGVtYVxuICB9ID0gZG9jO1xuXG4gIGlmIChub2RlLnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5BTElBUykge1xuICAgIGNvbnN0IG5hbWUgPSBub2RlLnJhd1ZhbHVlO1xuICAgIGNvbnN0IHNyYyA9IGFuY2hvcnMuZ2V0Tm9kZShuYW1lKTtcblxuICAgIGlmICghc3JjKSB7XG4gICAgICBjb25zdCBtc2cgPSBgQWxpYXNlZCBhbmNob3Igbm90IGZvdW5kOiAke25hbWV9YDtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxSZWZlcmVuY2VFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gTGF6eSByZXNvbHV0aW9uIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXG5cblxuICAgIGNvbnN0IHJlcyA9IG5ldyBBbGlhcyhzcmMpO1xuXG4gICAgYW5jaG9ycy5fY3N0QWxpYXNlcy5wdXNoKHJlcyk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgY29uc3QgdGFnTmFtZSA9IHJlc29sdmVUYWdOYW1lKGRvYywgbm9kZSk7XG4gIGlmICh0YWdOYW1lKSByZXR1cm4gcmVzb2x2ZVRhZyhkb2MsIG5vZGUsIHRhZ05hbWUpO1xuXG4gIGlmIChub2RlLnR5cGUgIT09IFBsYWluVmFsdWUuVHlwZS5QTEFJTikge1xuICAgIGNvbnN0IG1zZyA9IGBGYWlsZWQgdG8gcmVzb2x2ZSAke25vZGUudHlwZX0gbm9kZSBoZXJlYDtcbiAgICBlcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU3ludGF4RXJyb3Iobm9kZSwgbXNnKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHN0ciA9IHJlc29sdmVTdHJpbmcoZG9jLCBub2RlKTtcbiAgICByZXR1cm4gcmVzb2x2ZVNjYWxhcihzdHIsIHNjaGVtYS50YWdzLCBzY2hlbWEudGFncy5zY2FsYXJGYWxsYmFjayk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFlcnJvci5zb3VyY2UpIGVycm9yLnNvdXJjZSA9IG5vZGU7XG4gICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59IC8vIHNldHMgbm9kZS5yZXNvbHZlZCBvbiBzdWNjZXNzXG5cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUoZG9jLCBub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gIGlmIChub2RlLmVycm9yKSBkb2MuZXJyb3JzLnB1c2gobm9kZS5lcnJvcik7XG4gIGNvbnN0IHtcbiAgICBjb21tZW50cyxcbiAgICBoYXNBbmNob3IsXG4gICAgaGFzVGFnXG4gIH0gPSByZXNvbHZlTm9kZVByb3BzKGRvYy5lcnJvcnMsIG5vZGUpO1xuXG4gIGlmIChoYXNBbmNob3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JzXG4gICAgfSA9IGRvYztcbiAgICBjb25zdCBuYW1lID0gbm9kZS5hbmNob3I7XG4gICAgY29uc3QgcHJldiA9IGFuY2hvcnMuZ2V0Tm9kZShuYW1lKTsgLy8gQXQgdGhpcyBwb2ludCwgYWxpYXNlcyBmb3IgYW55IHByZWNlZGluZyBub2RlIHdpdGggdGhlIHNhbWUgYW5jaG9yXG4gICAgLy8gbmFtZSBoYXZlIGFscmVhZHkgYmVlbiByZXNvbHZlZCwgc28gaXQgbWF5IHNhZmVseSBiZSByZW5hbWVkLlxuXG4gICAgaWYgKHByZXYpIGFuY2hvcnMubWFwW2FuY2hvcnMubmV3TmFtZShuYW1lKV0gPSBwcmV2OyAvLyBEdXJpbmcgcGFyc2luZywgd2UgbmVlZCB0byBzdG9yZSB0aGUgQ1NUIG5vZGUgaW4gYW5jaG9ycy5tYXAgYXNcbiAgICAvLyBhbmNob3JzIG5lZWQgdG8gYmUgYXZhaWxhYmxlIGR1cmluZyByZXNvbHV0aW9uIHRvIGFsbG93IGZvclxuICAgIC8vIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG5cbiAgICBhbmNob3JzLm1hcFtuYW1lXSA9IG5vZGU7XG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSBQbGFpblZhbHVlLlR5cGUuQUxJQVMgJiYgKGhhc0FuY2hvciB8fCBoYXNUYWcpKSB7XG4gICAgY29uc3QgbXNnID0gJ0FuIGFsaWFzIG5vZGUgbXVzdCBub3Qgc3BlY2lmeSBhbnkgcHJvcGVydGllcyc7XG4gICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKG5vZGUsIG1zZykpO1xuICB9XG5cbiAgY29uc3QgcmVzID0gcmVzb2x2ZU5vZGVWYWx1ZShkb2MsIG5vZGUpO1xuXG4gIGlmIChyZXMpIHtcbiAgICByZXMucmFuZ2UgPSBbbm9kZS5yYW5nZS5zdGFydCwgbm9kZS5yYW5nZS5lbmRdO1xuICAgIGlmIChkb2Mub3B0aW9ucy5rZWVwQ3N0Tm9kZXMpIHJlcy5jc3ROb2RlID0gbm9kZTtcbiAgICBpZiAoZG9jLm9wdGlvbnMua2VlcE5vZGVUeXBlcykgcmVzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgY29uc3QgY2IgPSBjb21tZW50cy5iZWZvcmUuam9pbignXFxuJyk7XG5cbiAgICBpZiAoY2IpIHtcbiAgICAgIHJlcy5jb21tZW50QmVmb3JlID0gcmVzLmNvbW1lbnRCZWZvcmUgPyBgJHtyZXMuY29tbWVudEJlZm9yZX1cXG4ke2NifWAgOiBjYjtcbiAgICB9XG5cbiAgICBjb25zdCBjYSA9IGNvbW1lbnRzLmFmdGVyLmpvaW4oJ1xcbicpO1xuICAgIGlmIChjYSkgcmVzLmNvbW1lbnQgPSByZXMuY29tbWVudCA/IGAke3Jlcy5jb21tZW50fVxcbiR7Y2F9YCA6IGNhO1xuICB9XG5cbiAgcmV0dXJuIG5vZGUucmVzb2x2ZWQgPSByZXM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNYXAoZG9jLCBjc3QpIHtcbiAgaWYgKGNzdC50eXBlICE9PSBQbGFpblZhbHVlLlR5cGUuTUFQICYmIGNzdC50eXBlICE9PSBQbGFpblZhbHVlLlR5cGUuRkxPV19NQVApIHtcbiAgICBjb25zdCBtc2cgPSBgQSAke2NzdC50eXBlfSBub2RlIGNhbm5vdCBiZSByZXNvbHZlZCBhcyBhIG1hcHBpbmdgO1xuICAgIGRvYy5lcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU3ludGF4RXJyb3IoY3N0LCBtc2cpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBjb21tZW50cyxcbiAgICBpdGVtc1xuICB9ID0gY3N0LnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5GTE9XX01BUCA/IHJlc29sdmVGbG93TWFwSXRlbXMoZG9jLCBjc3QpIDogcmVzb2x2ZUJsb2NrTWFwSXRlbXMoZG9jLCBjc3QpO1xuICBjb25zdCBtYXAgPSBuZXcgWUFNTE1hcCgpO1xuICBtYXAuaXRlbXMgPSBpdGVtcztcbiAgcmVzb2x2ZUNvbW1lbnRzKG1hcCwgY29tbWVudHMpO1xuICBsZXQgaGFzQ29sbGVjdGlvbktleSA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCB7XG4gICAgICBrZXk6IGlLZXlcbiAgICB9ID0gaXRlbXNbaV07XG4gICAgaWYgKGlLZXkgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSBoYXNDb2xsZWN0aW9uS2V5ID0gdHJ1ZTtcblxuICAgIGlmIChkb2Muc2NoZW1hLm1lcmdlICYmIGlLZXkgJiYgaUtleS52YWx1ZSA9PT0gTUVSR0VfS0VZKSB7XG4gICAgICBpdGVtc1tpXSA9IG5ldyBNZXJnZShpdGVtc1tpXSk7XG4gICAgICBjb25zdCBzb3VyY2VzID0gaXRlbXNbaV0udmFsdWUuaXRlbXM7XG4gICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgc291cmNlcy5zb21lKG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFsaWFzKSB7XG4gICAgICAgICAgLy8gRHVyaW5nIHBhcnNpbmcsIGFsaWFzIHNvdXJjZXMgYXJlIENTVCBub2RlczsgdG8gYWNjb3VudCBmb3JcbiAgICAgICAgICAvLyBjaXJjdWxhciByZWZlcmVuY2VzIHRoZWlyIHJlc29sdmVkIHZhbHVlcyBjYW4ndCBiZSB1c2VkIGhlcmUuXG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0gPSBub2RlLnNvdXJjZTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLk1BUCB8fCB0eXBlID09PSBQbGFpblZhbHVlLlR5cGUuRkxPV19NQVApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IgPSAnTWVyZ2Ugbm9kZXMgYWxpYXNlcyBjYW4gb25seSBwb2ludCB0byBtYXBzJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvciA9ICdNZXJnZSBub2RlcyBjYW4gb25seSBoYXZlIEFsaWFzIG5vZGVzIGFzIHZhbHVlcyc7XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnJvcikgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGNzdCwgZXJyb3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgaXRlbXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGtleTogaktleVxuICAgICAgICB9ID0gaXRlbXNbal07XG5cbiAgICAgICAgaWYgKGlLZXkgPT09IGpLZXkgfHwgaUtleSAmJiBqS2V5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpS2V5LCAndmFsdWUnKSAmJiBpS2V5LnZhbHVlID09PSBqS2V5LnZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYE1hcCBrZXlzIG11c3QgYmUgdW5pcXVlOyBcIiR7aUtleX1cIiBpcyByZXBlYXRlZGA7XG4gICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaGFzQ29sbGVjdGlvbktleSAmJiAhZG9jLm9wdGlvbnMubWFwQXNNYXApIHtcbiAgICBjb25zdCB3YXJuID0gJ0tleXMgd2l0aCBjb2xsZWN0aW9uIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkIGFzIFlBTUwgZHVlIHRvIEpTIE9iamVjdCByZXN0cmljdGlvbnMuIFVzZSBtYXBBc01hcDogdHJ1ZSB0byBhdm9pZCB0aGlzLic7XG4gICAgZG9jLndhcm5pbmdzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFdhcm5pbmcoY3N0LCB3YXJuKSk7XG4gIH1cblxuICBjc3QucmVzb2x2ZWQgPSBtYXA7XG4gIHJldHVybiBtYXA7XG59XG5cbmNvbnN0IHZhbHVlSGFzUGFpckNvbW1lbnQgPSAoe1xuICBjb250ZXh0OiB7XG4gICAgbGluZVN0YXJ0LFxuICAgIG5vZGUsXG4gICAgc3JjXG4gIH0sXG4gIHByb3BzXG59KSA9PiB7XG4gIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0XG4gIH0gPSBwcm9wc1swXTtcbiAgaWYgKG5vZGUgJiYgc3RhcnQgPiBub2RlLnZhbHVlUmFuZ2Uuc3RhcnQpIHJldHVybiBmYWxzZTtcbiAgaWYgKHNyY1tzdGFydF0gIT09IFBsYWluVmFsdWUuQ2hhci5DT01NRU5UKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IGxpbmVTdGFydDsgaSA8IHN0YXJ0OyArK2kpIGlmIChzcmNbaV0gPT09ICdcXG4nKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlUGFpckNvbW1lbnQoaXRlbSwgcGFpcikge1xuICBpZiAoIXZhbHVlSGFzUGFpckNvbW1lbnQoaXRlbSkpIHJldHVybjtcbiAgY29uc3QgY29tbWVudCA9IGl0ZW0uZ2V0UHJvcFZhbHVlKDAsIFBsYWluVmFsdWUuQ2hhci5DT01NRU5ULCB0cnVlKTtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGNvbnN0IGNiID0gcGFpci52YWx1ZS5jb21tZW50QmVmb3JlO1xuXG4gIGlmIChjYiAmJiBjYi5zdGFydHNXaXRoKGNvbW1lbnQpKSB7XG4gICAgcGFpci52YWx1ZS5jb21tZW50QmVmb3JlID0gY2Iuc3Vic3RyKGNvbW1lbnQubGVuZ3RoICsgMSk7XG4gICAgZm91bmQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNjID0gcGFpci52YWx1ZS5jb21tZW50O1xuXG4gICAgaWYgKCFpdGVtLm5vZGUgJiYgY2MgJiYgY2Muc3RhcnRzV2l0aChjb21tZW50KSkge1xuICAgICAgcGFpci52YWx1ZS5jb21tZW50ID0gY2Muc3Vic3RyKGNvbW1lbnQubGVuZ3RoICsgMSk7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvdW5kKSBwYWlyLmNvbW1lbnQgPSBjb21tZW50O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tNYXBJdGVtcyhkb2MsIGNzdCkge1xuICBjb25zdCBjb21tZW50cyA9IFtdO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICBsZXQga2V5U3RhcnQgPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3N0Lml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IGNzdC5pdGVtc1tpXTtcblxuICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5CTEFOS19MSU5FOlxuICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICBhZnRlcktleTogISFrZXksXG4gICAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5DT01NRU5UOlxuICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICBhZnRlcktleTogISFrZXksXG4gICAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgY29tbWVudDogaXRlbS5jb21tZW50XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuTUFQX0tFWTpcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgICBpZiAoaXRlbS5lcnJvcikgZG9jLmVycm9ycy5wdXNoKGl0ZW0uZXJyb3IpO1xuICAgICAgICBrZXkgPSByZXNvbHZlTm9kZShkb2MsIGl0ZW0ubm9kZSk7XG4gICAgICAgIGtleVN0YXJ0ID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUGxhaW5WYWx1ZS5UeXBlLk1BUF9WQUxVRTpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkga2V5ID0gbnVsbDtcbiAgICAgICAgICBpZiAoaXRlbS5lcnJvcikgZG9jLmVycm9ycy5wdXNoKGl0ZW0uZXJyb3IpO1xuXG4gICAgICAgICAgaWYgKCFpdGVtLmNvbnRleHQuYXRMaW5lU3RhcnQgJiYgaXRlbS5ub2RlICYmIGl0ZW0ubm9kZS50eXBlID09PSBQbGFpblZhbHVlLlR5cGUuTUFQICYmICFpdGVtLm5vZGUuY29udGV4dC5hdExpbmVTdGFydCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ05lc3RlZCBtYXBwaW5ncyBhcmUgbm90IGFsbG93ZWQgaW4gY29tcGFjdCBtYXBwaW5ncyc7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoaXRlbS5ub2RlLCBtc2cpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdmFsdWVOb2RlID0gaXRlbS5ub2RlO1xuXG4gICAgICAgICAgaWYgKCF2YWx1ZU5vZGUgJiYgaXRlbS5wcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBDb21tZW50cyBvbiBhbiBlbXB0eSBtYXBwaW5nIHZhbHVlIG5lZWQgdG8gYmUgcHJlc2VydmVkLCBzbyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byBjb25zdHJ1Y3QgYSBtaW5pbWFsIGVtcHR5IG5vZGUgaGVyZSB0byB1c2UgaW5zdGVhZCBvZiB0aGVcbiAgICAgICAgICAgIC8vIG1pc3NpbmcgYGl0ZW0ubm9kZWAuIC0tIGVlbWVsaS95YW1sIzE5XG4gICAgICAgICAgICB2YWx1ZU5vZGUgPSBuZXcgUGxhaW5WYWx1ZS5QbGFpblZhbHVlKFBsYWluVmFsdWUuVHlwZS5QTEFJTiwgW10pO1xuICAgICAgICAgICAgdmFsdWVOb2RlLmNvbnRleHQgPSB7XG4gICAgICAgICAgICAgIHBhcmVudDogaXRlbSxcbiAgICAgICAgICAgICAgc3JjOiBpdGVtLmNvbnRleHQuc3JjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcG9zID0gaXRlbS5yYW5nZS5zdGFydCArIDE7XG4gICAgICAgICAgICB2YWx1ZU5vZGUucmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICAgICAgICAgIGVuZDogcG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWVOb2RlLnZhbHVlUmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICAgICAgICAgIGVuZDogcG9zXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0ucmFuZ2Uub3JpZ1N0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBjb25zdCBvcmlnUG9zID0gaXRlbS5yYW5nZS5vcmlnU3RhcnQgKyAxO1xuICAgICAgICAgICAgICB2YWx1ZU5vZGUucmFuZ2Uub3JpZ1N0YXJ0ID0gdmFsdWVOb2RlLnJhbmdlLm9yaWdFbmQgPSBvcmlnUG9zO1xuICAgICAgICAgICAgICB2YWx1ZU5vZGUudmFsdWVSYW5nZS5vcmlnU3RhcnQgPSB2YWx1ZU5vZGUudmFsdWVSYW5nZS5vcmlnRW5kID0gb3JpZ1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIoa2V5LCByZXNvbHZlTm9kZShkb2MsIHZhbHVlTm9kZSkpO1xuICAgICAgICAgIHJlc29sdmVQYWlyQ29tbWVudChpdGVtLCBwYWlyKTtcbiAgICAgICAgICBpdGVtcy5wdXNoKHBhaXIpO1xuXG4gICAgICAgICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5U3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5yYW5nZS5zdGFydCA+IGtleVN0YXJ0ICsgMTAyNCkgZG9jLmVycm9ycy5wdXNoKGdldExvbmdLZXlFcnJvcihjc3QsIGtleSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBrZXlTdGFydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgICAgICAga2V5ID0gcmVzb2x2ZU5vZGUoZG9jLCBpdGVtKTtcbiAgICAgICAga2V5U3RhcnQgPSBpdGVtLnJhbmdlLnN0YXJ0O1xuICAgICAgICBpZiAoaXRlbS5lcnJvcikgZG9jLmVycm9ycy5wdXNoKGl0ZW0uZXJyb3IpO1xuXG4gICAgICAgIG5leHQ6IGZvciAobGV0IGogPSBpICsgMTs7ICsraikge1xuICAgICAgICAgIGNvbnN0IG5leHRJdGVtID0gY3N0Lml0ZW1zW2pdO1xuXG4gICAgICAgICAgc3dpdGNoIChuZXh0SXRlbSAmJiBuZXh0SXRlbS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5CTEFOS19MSU5FOlxuICAgICAgICAgICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuQ09NTUVOVDpcbiAgICAgICAgICAgICAgY29udGludWUgbmV4dDtcblxuICAgICAgICAgICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuTUFQX1ZBTFVFOlxuICAgICAgICAgICAgICBicmVhayBuZXh0O1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ0ltcGxpY2l0IG1hcCBrZXlzIG5lZWQgdG8gYmUgZm9sbG93ZWQgYnkgbWFwIHZhbHVlcyc7XG4gICAgICAgICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGl0ZW0sIG1zZykpO1xuICAgICAgICAgICAgICAgIGJyZWFrIG5leHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS52YWx1ZVJhbmdlQ29udGFpbnNOZXdsaW5lKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ0ltcGxpY2l0IG1hcCBrZXlzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZSc7XG4gICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGl0ZW0sIG1zZykpO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gIHJldHVybiB7XG4gICAgY29tbWVudHMsXG4gICAgaXRlbXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZsb3dNYXBJdGVtcyhkb2MsIGNzdCkge1xuICBjb25zdCBjb21tZW50cyA9IFtdO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICBsZXQgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgbGV0IG5leHQgPSAneyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3QuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gY3N0Lml0ZW1zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVtLmNoYXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoYXIsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGl0ZW07XG5cbiAgICAgIGlmIChjaGFyID09PSAnPycgJiYga2V5ID09PSB1bmRlZmluZWQgJiYgIWV4cGxpY2l0S2V5KSB7XG4gICAgICAgIGV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgbmV4dCA9ICc6JztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFyID09PSAnOicpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSBrZXkgPSBudWxsO1xuXG4gICAgICAgIGlmIChuZXh0ID09PSAnOicpIHtcbiAgICAgICAgICBuZXh0ID0gJywnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgJiYgY2hhciAhPT0gJywnKSBrZXkgPSBudWxsO1xuICAgICAgICAgIGV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgICAgIGtleSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChjaGFyID09PSAnLCcpIHtcbiAgICAgICAgICAgIG5leHQgPSAnOic7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXIgPT09ICd9Jykge1xuICAgICAgICBpZiAoaSA9PT0gY3N0Lml0ZW1zLmxlbmd0aCAtIDEpIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBuZXh0KSB7XG4gICAgICAgIG5leHQgPSAnOic7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtc2cgPSBgRmxvdyBtYXAgY29udGFpbnMgYW4gdW5leHBlY3RlZCAke2NoYXJ9YDtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBQbGFpblZhbHVlLllBTUxTeW50YXhFcnJvcihjc3QsIG1zZyk7XG4gICAgICBlcnIub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgZG9jLmVycm9ycy5wdXNoKGVycik7XG4gICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5CTEFOS19MSU5FKSB7XG4gICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgYWZ0ZXJLZXk6ICEha2V5LFxuICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5DT01NRU5UKSB7XG4gICAgICBjaGVja0Zsb3dDb21tZW50U3BhY2UoZG9jLmVycm9ycywgaXRlbSk7XG4gICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgYWZ0ZXJLZXk6ICEha2V5LFxuICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgY29tbWVudDogaXRlbS5jb21tZW50XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobmV4dCA9PT0gJywnKSBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgJ1NlcGFyYXRvciAsIG1pc3NpbmcgaW4gZmxvdyBtYXAnKSk7XG4gICAgICBrZXkgPSByZXNvbHZlTm9kZShkb2MsIGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dCAhPT0gJywnKSBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgJ0luZGljYXRvciA6IG1pc3NpbmcgaW4gZmxvdyBtYXAgZW50cnknKSk7XG4gICAgICBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSwgcmVzb2x2ZU5vZGUoZG9jLCBpdGVtKSkpO1xuICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgZXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjaGVja0Zsb3dDb2xsZWN0aW9uRW5kKGRvYy5lcnJvcnMsIGNzdCk7XG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkgaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tZW50cyxcbiAgICBpdGVtc1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2VxKGRvYywgY3N0KSB7XG4gIGlmIChjc3QudHlwZSAhPT0gUGxhaW5WYWx1ZS5UeXBlLlNFUSAmJiBjc3QudHlwZSAhPT0gUGxhaW5WYWx1ZS5UeXBlLkZMT1dfU0VRKSB7XG4gICAgY29uc3QgbXNnID0gYEEgJHtjc3QudHlwZX0gbm9kZSBjYW5ub3QgYmUgcmVzb2x2ZWQgYXMgYSBzZXF1ZW5jZWA7XG4gICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTeW50YXhFcnJvcihjc3QsIG1zZykpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGNvbW1lbnRzLFxuICAgIGl0ZW1zXG4gIH0gPSBjc3QudHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkZMT1dfU0VRID8gcmVzb2x2ZUZsb3dTZXFJdGVtcyhkb2MsIGNzdCkgOiByZXNvbHZlQmxvY2tTZXFJdGVtcyhkb2MsIGNzdCk7XG4gIGNvbnN0IHNlcSA9IG5ldyBZQU1MU2VxKCk7XG4gIHNlcS5pdGVtcyA9IGl0ZW1zO1xuICByZXNvbHZlQ29tbWVudHMoc2VxLCBjb21tZW50cyk7XG5cbiAgaWYgKCFkb2Mub3B0aW9ucy5tYXBBc01hcCAmJiBpdGVtcy5zb21lKGl0ID0+IGl0IGluc3RhbmNlb2YgUGFpciAmJiBpdC5rZXkgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSkge1xuICAgIGNvbnN0IHdhcm4gPSAnS2V5cyB3aXRoIGNvbGxlY3Rpb24gdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQgYXMgWUFNTCBkdWUgdG8gSlMgT2JqZWN0IHJlc3RyaWN0aW9ucy4gVXNlIG1hcEFzTWFwOiB0cnVlIHRvIGF2b2lkIHRoaXMuJztcbiAgICBkb2Mud2FybmluZ3MucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MV2FybmluZyhjc3QsIHdhcm4pKTtcbiAgfVxuXG4gIGNzdC5yZXNvbHZlZCA9IHNlcTtcbiAgcmV0dXJuIHNlcTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrU2VxSXRlbXMoZG9jLCBjc3QpIHtcbiAgY29uc3QgY29tbWVudHMgPSBbXTtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNzdC5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBjc3QuaXRlbXNbaV07XG5cbiAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgY2FzZSBQbGFpblZhbHVlLlR5cGUuQkxBTktfTElORTpcbiAgICAgICAgY29tbWVudHMucHVzaCh7XG4gICAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5DT01NRU5UOlxuICAgICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgICBjb21tZW50OiBpdGVtLmNvbW1lbnQsXG4gICAgICAgICAgYmVmb3JlOiBpdGVtcy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFBsYWluVmFsdWUuVHlwZS5TRVFfSVRFTTpcbiAgICAgICAgaWYgKGl0ZW0uZXJyb3IpIGRvYy5lcnJvcnMucHVzaChpdGVtLmVycm9yKTtcbiAgICAgICAgaXRlbXMucHVzaChyZXNvbHZlTm9kZShkb2MsIGl0ZW0ubm9kZSkpO1xuXG4gICAgICAgIGlmIChpdGVtLmhhc1Byb3BzKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ1NlcXVlbmNlIGl0ZW1zIGNhbm5vdCBoYXZlIHRhZ3Mgb3IgYW5jaG9ycyBiZWZvcmUgdGhlIC0gaW5kaWNhdG9yJztcbiAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoaXRlbSwgbXNnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGl0ZW0uZXJyb3IpIGRvYy5lcnJvcnMucHVzaChpdGVtLmVycm9yKTtcbiAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTeW50YXhFcnJvcihpdGVtLCBgVW5leHBlY3RlZCAke2l0ZW0udHlwZX0gbm9kZSBpbiBzZXF1ZW5jZWApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbW1lbnRzLFxuICAgIGl0ZW1zXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGbG93U2VxSXRlbXMoZG9jLCBjc3QpIHtcbiAgY29uc3QgY29tbWVudHMgPSBbXTtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgbGV0IGV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gIGxldCBrZXkgPSB1bmRlZmluZWQ7XG4gIGxldCBrZXlTdGFydCA9IG51bGw7XG4gIGxldCBuZXh0ID0gJ1snO1xuICBsZXQgcHJldkl0ZW0gPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3N0Lml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IGNzdC5pdGVtc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaXRlbS5jaGFyID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjaGFyLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBpdGVtO1xuXG4gICAgICBpZiAoY2hhciAhPT0gJzonICYmIChleHBsaWNpdEtleSB8fCBrZXkgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgaWYgKGV4cGxpY2l0S2V5ICYmIGtleSA9PT0gdW5kZWZpbmVkKSBrZXkgPSBuZXh0ID8gaXRlbXMucG9wKCkgOiBudWxsO1xuICAgICAgICBpdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgICBleHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGtleVN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXIgPT09IG5leHQpIHtcbiAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCFuZXh0ICYmIGNoYXIgPT09ICc/Jykge1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5leHQgIT09ICdbJyAmJiBjaGFyID09PSAnOicgJiYga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG5leHQgPT09ICcsJykge1xuICAgICAgICAgIGtleSA9IGl0ZW1zLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIFBhaXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdDaGFpbmluZyBmbG93IHNlcXVlbmNlIHBhaXJzIGlzIGludmFsaWQnO1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IFBsYWluVmFsdWUuWUFNTFNlbWFudGljRXJyb3IoY3N0LCBtc2cpO1xuICAgICAgICAgICAgZXJyLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZXhwbGljaXRLZXkgJiYgdHlwZW9mIGtleVN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3Qga2V5RW5kID0gaXRlbS5yYW5nZSA/IGl0ZW0ucmFuZ2Uuc3RhcnQgOiBpdGVtLm9mZnNldDtcbiAgICAgICAgICAgIGlmIChrZXlFbmQgPiBrZXlTdGFydCArIDEwMjQpIGRvYy5lcnJvcnMucHVzaChnZXRMb25nS2V5RXJyb3IoY3N0LCBrZXkpKTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICB9ID0gcHJldkl0ZW0uY29udGV4dDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGtleVN0YXJ0OyBpIDwga2V5RW5kOyArK2kpIGlmIChzcmNbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdJbXBsaWNpdCBrZXlzIG9mIGZsb3cgc2VxdWVuY2UgcGFpcnMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJztcbiAgICAgICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKHByZXZJdGVtLCBtc2cpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBrZXlTdGFydCA9IG51bGw7XG4gICAgICAgIGV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIG5leHQgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChuZXh0ID09PSAnWycgfHwgY2hhciAhPT0gJ10nIHx8IGkgPCBjc3QuaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgRmxvdyBzZXF1ZW5jZSBjb250YWlucyBhbiB1bmV4cGVjdGVkICR7Y2hhcn1gO1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgUGxhaW5WYWx1ZS5ZQU1MU3ludGF4RXJyb3IoY3N0LCBtc2cpO1xuICAgICAgICBlcnIub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBkb2MuZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkJMQU5LX0xJTkUpIHtcbiAgICAgIGNvbW1lbnRzLnB1c2goe1xuICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFBsYWluVmFsdWUuVHlwZS5DT01NRU5UKSB7XG4gICAgICBjaGVja0Zsb3dDb21tZW50U3BhY2UoZG9jLmVycm9ycywgaXRlbSk7XG4gICAgICBjb21tZW50cy5wdXNoKHtcbiAgICAgICAgY29tbWVudDogaXRlbS5jb21tZW50LFxuICAgICAgICBiZWZvcmU6IGl0ZW1zLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCBhICR7bmV4dH0gaW4gZmxvdyBzZXF1ZW5jZWA7XG4gICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihpdGVtLCBtc2cpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlTm9kZShkb2MsIGl0ZW0pO1xuXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHByZXZJdGVtID0gaXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5LCB2YWx1ZSkpO1xuICAgICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGtleVN0YXJ0ID0gaXRlbS5yYW5nZS5zdGFydDtcbiAgICAgIG5leHQgPSAnLCc7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tGbG93Q29sbGVjdGlvbkVuZChkb2MuZXJyb3JzLCBjc3QpO1xuICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIGl0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gIHJldHVybiB7XG4gICAgY29tbWVudHMsXG4gICAgaXRlbXNcbiAgfTtcbn1cblxuZXhwb3J0cy5BbGlhcyA9IEFsaWFzO1xuZXhwb3J0cy5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjtcbmV4cG9ydHMuTWVyZ2UgPSBNZXJnZTtcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG5leHBvcnRzLlBhaXIgPSBQYWlyO1xuZXhwb3J0cy5TY2FsYXIgPSBTY2FsYXI7XG5leHBvcnRzLllBTUxNYXAgPSBZQU1MTWFwO1xuZXhwb3J0cy5ZQU1MU2VxID0gWUFNTFNlcTtcbmV4cG9ydHMuYWRkQ29tbWVudCA9IGFkZENvbW1lbnQ7XG5leHBvcnRzLmJpbmFyeU9wdGlvbnMgPSBiaW5hcnlPcHRpb25zO1xuZXhwb3J0cy5ib29sT3B0aW9ucyA9IGJvb2xPcHRpb25zO1xuZXhwb3J0cy5maW5kUGFpciA9IGZpbmRQYWlyO1xuZXhwb3J0cy5pbnRPcHRpb25zID0gaW50T3B0aW9ucztcbmV4cG9ydHMuaXNFbXB0eVBhdGggPSBpc0VtcHR5UGF0aDtcbmV4cG9ydHMubnVsbE9wdGlvbnMgPSBudWxsT3B0aW9ucztcbmV4cG9ydHMucmVzb2x2ZU1hcCA9IHJlc29sdmVNYXA7XG5leHBvcnRzLnJlc29sdmVOb2RlID0gcmVzb2x2ZU5vZGU7XG5leHBvcnRzLnJlc29sdmVTZXEgPSByZXNvbHZlU2VxO1xuZXhwb3J0cy5yZXNvbHZlU3RyaW5nID0gcmVzb2x2ZVN0cmluZztcbmV4cG9ydHMuc3RyT3B0aW9ucyA9IHN0ck9wdGlvbnM7XG5leHBvcnRzLnN0cmluZ2lmeU51bWJlciA9IHN0cmluZ2lmeU51bWJlcjtcbmV4cG9ydHMuc3RyaW5naWZ5U3RyaW5nID0gc3RyaW5naWZ5U3RyaW5nO1xuZXhwb3J0cy50b0pTT04gPSB0b0pTT047XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQbGFpblZhbHVlID0gcmVxdWlyZSgnLi9QbGFpblZhbHVlLWVjOGU1ODhlLmpzJyk7XG52YXIgcmVzb2x2ZVNlcSA9IHJlcXVpcmUoJy4vcmVzb2x2ZVNlcS1kMDNjYjAzNy5qcycpO1xuXG4vKiBnbG9iYWwgYXRvYiwgYnRvYSwgQnVmZmVyICovXG5jb25zdCBiaW5hcnkgPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksXG4gIC8vIEJ1ZmZlciBpbmhlcml0cyBmcm9tIFVpbnQ4QXJyYXlcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCdWZmZXIgaW4gbm9kZSBhbmQgYW4gVWludDhBcnJheSBpbiBicm93c2Vyc1xuICAgKlxuICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgKlxuICAgKiAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSlcbiAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAqL1xuICByZXNvbHZlOiAoZG9jLCBub2RlKSA9PiB7XG4gICAgY29uc3Qgc3JjID0gcmVzb2x2ZVNlcS5yZXNvbHZlU3RyaW5nKGRvYywgbm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNyYywgJ2Jhc2U2NCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIE9uIElFIDExLCBhdG9iKCkgY2FuJ3QgaGFuZGxlIG5ld2xpbmVzXG4gICAgICBjb25zdCBzdHIgPSBhdG9iKHNyYy5yZXBsYWNlKC9bXFxuXFxyXS9nLCAnJykpO1xuICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSBidWZmZXJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGF0b2IgaXMgcmVxdWlyZWQnO1xuICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBQbGFpblZhbHVlLllBTUxSZWZlcmVuY2VFcnJvcihub2RlLCBtc2cpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgb3B0aW9uczogcmVzb2x2ZVNlcS5iaW5hcnlPcHRpb25zLFxuICBzdHJpbmdpZnk6ICh7XG4gICAgY29tbWVudCxcbiAgICB0eXBlLFxuICAgIHZhbHVlXG4gIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkgPT4ge1xuICAgIGxldCBzcmM7XG5cbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3JjID0gdmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIgPyB2YWx1ZS50b1N0cmluZygnYmFzZTY0JykgOiBCdWZmZXIuZnJvbSh2YWx1ZS5idWZmZXIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsZXQgcyA9ICcnO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWVbaV0pO1xuXG4gICAgICBzcmMgPSBidG9hKHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3cml0aW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGJ0b2EgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHR5cGUgPSByZXNvbHZlU2VxLmJpbmFyeU9wdGlvbnMuZGVmYXVsdFR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLlFVT1RFX0RPVUJMRSkge1xuICAgICAgdmFsdWUgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9ID0gcmVzb2x2ZVNlcS5iaW5hcnlPcHRpb25zO1xuICAgICAgY29uc3QgbiA9IE1hdGguY2VpbChzcmMubGVuZ3RoIC8gbGluZVdpZHRoKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gbmV3IEFycmF5KG4pO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbyA9IDA7IGkgPCBuOyArK2ksIG8gKz0gbGluZVdpZHRoKSB7XG4gICAgICAgIGxpbmVzW2ldID0gc3JjLnN1YnN0cihvLCBsaW5lV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGxpbmVzLmpvaW4odHlwZSA9PT0gUGxhaW5WYWx1ZS5UeXBlLkJMT0NLX0xJVEVSQUwgPyAnXFxuJyA6ICcgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc29sdmVTZXEuc3RyaW5naWZ5U3RyaW5nKHtcbiAgICAgIGNvbW1lbnQsXG4gICAgICB0eXBlLFxuICAgICAgdmFsdWVcbiAgICB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZVBhaXJzKGRvYywgY3N0KSB7XG4gIGNvbnN0IHNlcSA9IHJlc29sdmVTZXEucmVzb2x2ZVNlcShkb2MsIGNzdCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXEuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgaXRlbSA9IHNlcS5pdGVtc1tpXTtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIHJlc29sdmVTZXEuUGFpcikgY29udGludWU7ZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIHJlc29sdmVTZXEuWUFNTE1hcCkge1xuICAgICAgaWYgKGl0ZW0uaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBtc2cgPSAnRWFjaCBwYWlyIG11c3QgaGF2ZSBpdHMgb3duIHNlcXVlbmNlIGluZGljYXRvcic7XG4gICAgICAgIHRocm93IG5ldyBQbGFpblZhbHVlLllBTUxTZW1hbnRpY0Vycm9yKGNzdCwgbXNnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFpciA9IGl0ZW0uaXRlbXNbMF0gfHwgbmV3IHJlc29sdmVTZXEuUGFpcigpO1xuICAgICAgaWYgKGl0ZW0uY29tbWVudEJlZm9yZSkgcGFpci5jb21tZW50QmVmb3JlID0gcGFpci5jb21tZW50QmVmb3JlID8gYCR7aXRlbS5jb21tZW50QmVmb3JlfVxcbiR7cGFpci5jb21tZW50QmVmb3JlfWAgOiBpdGVtLmNvbW1lbnRCZWZvcmU7XG4gICAgICBpZiAoaXRlbS5jb21tZW50KSBwYWlyLmNvbW1lbnQgPSBwYWlyLmNvbW1lbnQgPyBgJHtpdGVtLmNvbW1lbnR9XFxuJHtwYWlyLmNvbW1lbnR9YCA6IGl0ZW0uY29tbWVudDtcbiAgICAgIGl0ZW0gPSBwYWlyO1xuICAgIH1cbiAgICBzZXEuaXRlbXNbaV0gPSBpdGVtIGluc3RhbmNlb2YgcmVzb2x2ZVNlcS5QYWlyID8gaXRlbSA6IG5ldyByZXNvbHZlU2VxLlBhaXIoaXRlbSk7XG4gIH1cblxuICByZXR1cm4gc2VxO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gIGNvbnN0IHBhaXJzID0gbmV3IHJlc29sdmVTZXEuWUFNTFNlcShzY2hlbWEpO1xuICBwYWlycy50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnO1xuXG4gIGZvciAoY29uc3QgaXQgb2YgaXRlcmFibGUpIHtcbiAgICBsZXQga2V5LCB2YWx1ZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0KSkge1xuICAgICAgaWYgKGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICBrZXkgPSBpdFswXTtcbiAgICAgICAgdmFsdWUgPSBpdFsxXTtcbiAgICAgIH0gZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBba2V5LCB2YWx1ZV0gdHVwbGU6ICR7aXR9YCk7XG4gICAgfSBlbHNlIGlmIChpdCAmJiBpdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0KTtcblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGtleSA9IGtleXNbMF07XG4gICAgICAgIHZhbHVlID0gaXRba2V5XTtcbiAgICAgIH0gZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB7IGtleTogdmFsdWUgfSB0dXBsZTogJHtpdH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gaXQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGFpciA9IHNjaGVtYS5jcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCk7XG4gICAgcGFpcnMuaXRlbXMucHVzaChwYWlyKTtcbiAgfVxuXG4gIHJldHVybiBwYWlycztcbn1cbmNvbnN0IHBhaXJzID0ge1xuICBkZWZhdWx0OiBmYWxzZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLFxuICByZXNvbHZlOiBwYXJzZVBhaXJzLFxuICBjcmVhdGVOb2RlOiBjcmVhdGVQYWlyc1xufTtcblxuY2xhc3MgWUFNTE9NYXAgZXh0ZW5kcyByZXNvbHZlU2VxLllBTUxTZXEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJhZGRcIiwgcmVzb2x2ZVNlcS5ZQU1MTWFwLnByb3RvdHlwZS5hZGQuYmluZCh0aGlzKSk7XG5cbiAgICBQbGFpblZhbHVlLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlbGV0ZVwiLCByZXNvbHZlU2VxLllBTUxNYXAucHJvdG90eXBlLmRlbGV0ZS5iaW5kKHRoaXMpKTtcblxuICAgIFBsYWluVmFsdWUuX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0XCIsIHJlc29sdmVTZXEuWUFNTE1hcC5wcm90b3R5cGUuZ2V0LmJpbmQodGhpcykpO1xuXG4gICAgUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYXNcIiwgcmVzb2x2ZVNlcS5ZQU1MTWFwLnByb3RvdHlwZS5oYXMuYmluZCh0aGlzKSk7XG5cbiAgICBQbGFpblZhbHVlLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFwiLCByZXNvbHZlU2VxLllBTUxNYXAucHJvdG90eXBlLnNldC5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMudGFnID0gWUFNTE9NYXAudGFnO1xuICB9XG5cbiAgdG9KU09OKF8sIGN0eCkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBpZiAoY3R4ICYmIGN0eC5vbkNyZWF0ZSkgY3R4Lm9uQ3JlYXRlKG1hcCk7XG5cbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgdGhpcy5pdGVtcykge1xuICAgICAgbGV0IGtleSwgdmFsdWU7XG5cbiAgICAgIGlmIChwYWlyIGluc3RhbmNlb2YgcmVzb2x2ZVNlcS5QYWlyKSB7XG4gICAgICAgIGtleSA9IHJlc29sdmVTZXEudG9KU09OKHBhaXIua2V5LCAnJywgY3R4KTtcbiAgICAgICAgdmFsdWUgPSByZXNvbHZlU2VxLnRvSlNPTihwYWlyLnZhbHVlLCBrZXksIGN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSByZXNvbHZlU2VxLnRvSlNPTihwYWlyLCAnJywgY3R4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcC5oYXMoa2V5KSkgdGhyb3cgbmV3IEVycm9yKCdPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5cycpO1xuICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbn1cblxuUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkoWUFNTE9NYXAsIFwidGFnXCIsICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJyk7XG5cbmZ1bmN0aW9uIHBhcnNlT01hcChkb2MsIGNzdCkge1xuICBjb25zdCBwYWlycyA9IHBhcnNlUGFpcnMoZG9jLCBjc3QpO1xuICBjb25zdCBzZWVuS2V5cyA9IFtdO1xuXG4gIGZvciAoY29uc3Qge1xuICAgIGtleVxuICB9IG9mIHBhaXJzLml0ZW1zKSB7XG4gICAgaWYgKGtleSBpbnN0YW5jZW9mIHJlc29sdmVTZXEuU2NhbGFyKSB7XG4gICAgICBpZiAoc2VlbktleXMuaW5jbHVkZXMoa2V5LnZhbHVlKSkge1xuICAgICAgICBjb25zdCBtc2cgPSAnT3JkZXJlZCBtYXBzIG11c3Qgbm90IGluY2x1ZGUgZHVwbGljYXRlIGtleXMnO1xuICAgICAgICB0aHJvdyBuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihjc3QsIG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuS2V5cy5wdXNoKGtleS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxPTWFwKCksIHBhaXJzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT01hcChzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgY29uc3QgcGFpcnMgPSBjcmVhdGVQYWlycyhzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpO1xuICBjb25zdCBvbWFwID0gbmV3IFlBTUxPTWFwKCk7XG4gIG9tYXAuaXRlbXMgPSBwYWlycy5pdGVtcztcbiAgcmV0dXJuIG9tYXA7XG59XG5cbmNvbnN0IG9tYXAgPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCxcbiAgbm9kZUNsYXNzOiBZQU1MT01hcCxcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLFxuICByZXNvbHZlOiBwYXJzZU9NYXAsXG4gIGNyZWF0ZU5vZGU6IGNyZWF0ZU9NYXBcbn07XG5cbmNsYXNzIFlBTUxTZXQgZXh0ZW5kcyByZXNvbHZlU2VxLllBTUxNYXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGFnID0gWUFNTFNldC50YWc7XG4gIH1cblxuICBhZGQoa2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGtleSBpbnN0YW5jZW9mIHJlc29sdmVTZXEuUGFpciA/IGtleSA6IG5ldyByZXNvbHZlU2VxLlBhaXIoa2V5KTtcbiAgICBjb25zdCBwcmV2ID0gcmVzb2x2ZVNlcS5maW5kUGFpcih0aGlzLml0ZW1zLCBwYWlyLmtleSk7XG4gICAgaWYgKCFwcmV2KSB0aGlzLml0ZW1zLnB1c2gocGFpcik7XG4gIH1cblxuICBnZXQoa2V5LCBrZWVwUGFpcikge1xuICAgIGNvbnN0IHBhaXIgPSByZXNvbHZlU2VxLmZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgcmV0dXJuICFrZWVwUGFpciAmJiBwYWlyIGluc3RhbmNlb2YgcmVzb2x2ZVNlcS5QYWlyID8gcGFpci5rZXkgaW5zdGFuY2VvZiByZXNvbHZlU2VxLlNjYWxhciA/IHBhaXIua2V5LnZhbHVlIDogcGFpci5rZXkgOiBwYWlyO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiB2YWx1ZSBmb3Igc2V0KGtleSwgdmFsdWUpIGluIGEgWUFNTCBzZXQsIG5vdCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICBjb25zdCBwcmV2ID0gcmVzb2x2ZVNlcS5maW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuXG4gICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocHJldiksIDEpO1xuICAgIH0gZWxzZSBpZiAoIXByZXYgJiYgdmFsdWUpIHtcbiAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgcmVzb2x2ZVNlcS5QYWlyKGtleSkpO1xuICAgIH1cbiAgfVxuXG4gIHRvSlNPTihfLCBjdHgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9KU09OKF8sIGN0eCwgU2V0KTtcbiAgfVxuXG4gIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGlmICghY3R4KSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgaWYgKHRoaXMuaGFzQWxsTnVsbFZhbHVlcygpKSByZXR1cm4gc3VwZXIudG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtlbHNlIHRocm93IG5ldyBFcnJvcignU2V0IGl0ZW1zIG11c3QgYWxsIGhhdmUgbnVsbCB2YWx1ZXMnKTtcbiAgfVxuXG59XG5cblBsYWluVmFsdWUuX2RlZmluZVByb3BlcnR5KFlBTUxTZXQsIFwidGFnXCIsICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnKTtcblxuZnVuY3Rpb24gcGFyc2VTZXQoZG9jLCBjc3QpIHtcbiAgY29uc3QgbWFwID0gcmVzb2x2ZVNlcS5yZXNvbHZlTWFwKGRvYywgY3N0KTtcbiAgaWYgKCFtYXAuaGFzQWxsTnVsbFZhbHVlcygpKSB0aHJvdyBuZXcgUGxhaW5WYWx1ZS5ZQU1MU2VtYW50aWNFcnJvcihjc3QsICdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTFNldCgpLCBtYXApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTZXQoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gIGNvbnN0IHNldCA9IG5ldyBZQU1MU2V0KCk7XG5cbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkgc2V0Lml0ZW1zLnB1c2goc2NoZW1hLmNyZWF0ZVBhaXIodmFsdWUsIG51bGwsIGN0eCkpO1xuXG4gIHJldHVybiBzZXQ7XG59XG5cbmNvbnN0IHNldCA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgU2V0LFxuICBub2RlQ2xhc3M6IFlBTUxTZXQsXG4gIGRlZmF1bHQ6IGZhbHNlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLFxuICByZXNvbHZlOiBwYXJzZVNldCxcbiAgY3JlYXRlTm9kZTogY3JlYXRlU2V0XG59O1xuXG5jb25zdCBwYXJzZVNleGFnZXNpbWFsID0gKHNpZ24sIHBhcnRzKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJ0cy5zcGxpdCgnOicpLnJlZHVjZSgobiwgcCkgPT4gbiAqIDYwICsgTnVtYmVyKHApLCAwKTtcbiAgcmV0dXJuIHNpZ24gPT09ICctJyA/IC1uIDogbjtcbn07IC8vIGhoaGg6bW06c3Muc3NzXG5cblxuY29uc3Qgc3RyaW5naWZ5U2V4YWdlc2ltYWwgPSAoe1xuICB2YWx1ZVxufSkgPT4ge1xuICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHJldHVybiByZXNvbHZlU2VxLnN0cmluZ2lmeU51bWJlcih2YWx1ZSk7XG4gIGxldCBzaWduID0gJyc7XG5cbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIHNpZ24gPSAnLSc7XG4gICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG4gIH1cblxuICBjb25zdCBwYXJ0cyA9IFt2YWx1ZSAlIDYwXTsgLy8gc2Vjb25kcywgaW5jbHVkaW5nIG1zXG5cbiAgaWYgKHZhbHVlIDwgNjApIHtcbiAgICBwYXJ0cy51bnNoaWZ0KDApOyAvLyBhdCBsZWFzdCBvbmUgOiBpcyByZXF1aXJlZFxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gTWF0aC5yb3VuZCgodmFsdWUgLSBwYXJ0c1swXSkgLyA2MCk7XG4gICAgcGFydHMudW5zaGlmdCh2YWx1ZSAlIDYwKTsgLy8gbWludXRlc1xuXG4gICAgaWYgKHZhbHVlID49IDYwKSB7XG4gICAgICB2YWx1ZSA9IE1hdGgucm91bmQoKHZhbHVlIC0gcGFydHNbMF0pIC8gNjApO1xuICAgICAgcGFydHMudW5zaGlmdCh2YWx1ZSk7IC8vIGhvdXJzXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNpZ24gKyBwYXJ0cy5tYXAobiA9PiBuIDwgMTAgPyAnMCcgKyBTdHJpbmcobikgOiBTdHJpbmcobikpLmpvaW4oJzonKS5yZXBsYWNlKC8wMDAwMDBcXGQqJC8sICcnKSAvLyAlIDYwIG1heSBpbnRyb2R1Y2UgZXJyb3JcbiAgO1xufTtcblxuY29uc3QgaW50VGltZSA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIGZvcm1hdDogJ1RJTUUnLFxuICB0ZXN0OiAvXihbLStdPykoWzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKSspJC8sXG4gIHJlc29sdmU6IChzdHIsIHNpZ24sIHBhcnRzKSA9PiBwYXJzZVNleGFnZXNpbWFsKHNpZ24sIHBhcnRzLnJlcGxhY2UoL18vZywgJycpKSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbmNvbnN0IGZsb2F0VGltZSA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgZm9ybWF0OiAnVElNRScsXG4gIHRlc3Q6IC9eKFstK10/KShbMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcLlswLTlfXSopJC8sXG4gIHJlc29sdmU6IChzdHIsIHNpZ24sIHBhcnRzKSA9PiBwYXJzZVNleGFnZXNpbWFsKHNpZ24sIHBhcnRzLnJlcGxhY2UoL18vZywgJycpKSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbmNvbnN0IHRpbWVzdGFtcCA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJyxcbiAgLy8gSWYgdGhlIHRpbWUgem9uZSBpcyBvbWl0dGVkLCB0aGUgdGltZXN0YW1wIGlzIGFzc3VtZWQgdG8gYmUgc3BlY2lmaWVkIGluIFVUQy4gVGhlIHRpbWUgcGFydFxuICAvLyBtYXkgYmUgb21pdHRlZCBhbHRvZ2V0aGVyLCByZXN1bHRpbmcgaW4gYSBkYXRlIGZvcm1hdC4gSW4gc3VjaCBhIGNhc2UsIHRoZSB0aW1lIHBhcnQgaXNcbiAgLy8gYXNzdW1lZCB0byBiZSAwMDowMDowMFogKHN0YXJ0IG9mIGRheSwgVVRDKS5cbiAgdGVzdDogUmVnRXhwKCdeKD86JyArICcoWzAtOV17NH0pLShbMC05XXsxLDJ9KS0oWzAtOV17MSwyfSknICsgLy8gWVlZWS1NbS1EZFxuICAnKD86KD86dHxUfFsgXFxcXHRdKyknICsgLy8gdCB8IFQgfCB3aGl0ZXNwYWNlXG4gICcoWzAtOV17MSwyfSk6KFswLTldezEsMn0pOihbMC05XXsxLDJ9KFxcXFwuWzAtOV0rKT8pJyArIC8vIEhoOk1tOlNzKC5zcyk/XG4gICcoPzpbIFxcXFx0XSooWnxbLStdWzAxMl0/WzAtOV0oPzo6WzAtOV17Mn0pPykpPycgKyAvLyBaIHwgKzUgfCAtMDM6MzBcbiAgJyk/JyArICcpJCcpLFxuICByZXNvbHZlOiAoc3RyLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWMsIHR6KSA9PiB7XG4gICAgaWYgKG1pbGxpc2VjKSBtaWxsaXNlYyA9IChtaWxsaXNlYyArICcwMCcpLnN1YnN0cigxLCAzKTtcbiAgICBsZXQgZGF0ZSA9IERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyIHx8IDAsIG1pbnV0ZSB8fCAwLCBzZWNvbmQgfHwgMCwgbWlsbGlzZWMgfHwgMCk7XG5cbiAgICBpZiAodHogJiYgdHogIT09ICdaJykge1xuICAgICAgbGV0IGQgPSBwYXJzZVNleGFnZXNpbWFsKHR6WzBdLCB0ei5zbGljZSgxKSk7XG4gICAgICBpZiAoTWF0aC5hYnMoZCkgPCAzMCkgZCAqPSA2MDtcbiAgICAgIGRhdGUgLT0gNjAwMDAgKiBkO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgfSxcbiAgc3RyaW5naWZ5OiAoe1xuICAgIHZhbHVlXG4gIH0pID0+IHZhbHVlLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvKChUMDA6MDApPzowMCk/XFwuMDAwWiQvLCAnJylcbn07XG5cbi8qIGdsb2JhbCBjb25zb2xlLCBwcm9jZXNzLCBZQU1MX1NJTEVOQ0VfREVQUkVDQVRJT05fV0FSTklOR1MsIFlBTUxfU0lMRU5DRV9XQVJOSU5HUyAqL1xuZnVuY3Rpb24gc2hvdWxkV2FybihkZXByZWNhdGlvbikge1xuICBjb25zdCBlbnYgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgfHwge307XG5cbiAgaWYgKGRlcHJlY2F0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBZQU1MX1NJTEVOQ0VfREVQUkVDQVRJT05fV0FSTklOR1MgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gIVlBTUxfU0lMRU5DRV9ERVBSRUNBVElPTl9XQVJOSU5HUztcbiAgICByZXR1cm4gIWVudi5ZQU1MX1NJTEVOQ0VfREVQUkVDQVRJT05fV0FSTklOR1M7XG4gIH1cblxuICBpZiAodHlwZW9mIFlBTUxfU0lMRU5DRV9XQVJOSU5HUyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiAhWUFNTF9TSUxFTkNFX1dBUk5JTkdTO1xuICByZXR1cm4gIWVudi5ZQU1MX1NJTEVOQ0VfV0FSTklOR1M7XG59XG5cbmZ1bmN0aW9uIHdhcm4od2FybmluZywgdHlwZSkge1xuICBpZiAoc2hvdWxkV2FybihmYWxzZSkpIHtcbiAgICBjb25zdCBlbWl0ID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW1pdFdhcm5pbmc7IC8vIFRoaXMgd2lsbCB0aHJvdyBpbiBKZXN0IGlmIGB3YXJuaW5nYCBpcyBhbiBFcnJvciBpbnN0YW5jZSBkdWUgdG9cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svamVzdC9pc3N1ZXMvMjU0OVxuXG4gICAgaWYgKGVtaXQpIGVtaXQod2FybmluZywgdHlwZSk7ZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKHR5cGUgPyBgJHt0eXBlfTogJHt3YXJuaW5nfWAgOiB3YXJuaW5nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5GaWxlRGVwcmVjYXRpb24oZmlsZW5hbWUpIHtcbiAgaWYgKHNob3VsZFdhcm4odHJ1ZSkpIHtcbiAgICBjb25zdCBwYXRoID0gZmlsZW5hbWUucmVwbGFjZSgvLip5YW1sWy9cXFxcXS9pLCAnJykucmVwbGFjZSgvXFwuanMkLywgJycpLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICB3YXJuKGBUaGUgZW5kcG9pbnQgJ3lhbWwvJHtwYXRofScgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuYCwgJ0RlcHJlY2F0aW9uV2FybmluZycpO1xuICB9XG59XG5jb25zdCB3YXJuZWQgPSB7fTtcbmZ1bmN0aW9uIHdhcm5PcHRpb25EZXByZWNhdGlvbihuYW1lLCBhbHRlcm5hdGl2ZSkge1xuICBpZiAoIXdhcm5lZFtuYW1lXSAmJiBzaG91bGRXYXJuKHRydWUpKSB7XG4gICAgd2FybmVkW25hbWVdID0gdHJ1ZTtcbiAgICBsZXQgbXNnID0gYFRoZSBvcHRpb24gJyR7bmFtZX0nIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlYDtcbiAgICBtc2cgKz0gYWx0ZXJuYXRpdmUgPyBgLCB1c2UgJyR7YWx0ZXJuYXRpdmV9JyBpbnN0ZWFkLmAgOiAnLic7XG4gICAgd2Fybihtc2csICdEZXByZWNhdGlvbldhcm5pbmcnKTtcbiAgfVxufVxuXG5leHBvcnRzLmJpbmFyeSA9IGJpbmFyeTtcbmV4cG9ydHMuZmxvYXRUaW1lID0gZmxvYXRUaW1lO1xuZXhwb3J0cy5pbnRUaW1lID0gaW50VGltZTtcbmV4cG9ydHMub21hcCA9IG9tYXA7XG5leHBvcnRzLnBhaXJzID0gcGFpcnM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuZXhwb3J0cy53YXJuID0gd2FybjtcbmV4cG9ydHMud2FybkZpbGVEZXByZWNhdGlvbiA9IHdhcm5GaWxlRGVwcmVjYXRpb247XG5leHBvcnRzLndhcm5PcHRpb25EZXByZWNhdGlvbiA9IHdhcm5PcHRpb25EZXByZWNhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBsYWluVmFsdWUgPSByZXF1aXJlKCcuL1BsYWluVmFsdWUtZWM4ZTU4OGUuanMnKTtcbnZhciByZXNvbHZlU2VxID0gcmVxdWlyZSgnLi9yZXNvbHZlU2VxLWQwM2NiMDM3LmpzJyk7XG52YXIgd2FybmluZ3MgPSByZXF1aXJlKCcuL3dhcm5pbmdzLTEwMDBhMzcyLmpzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcChzY2hlbWEsIG9iaiwgY3R4KSB7XG4gIGNvbnN0IG1hcCA9IG5ldyByZXNvbHZlU2VxLllBTUxNYXAoc2NoZW1hKTtcblxuICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKSBtYXAuaXRlbXMucHVzaChzY2hlbWEuY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgfSBlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSBtYXAuaXRlbXMucHVzaChzY2hlbWEuY3JlYXRlUGFpcihrZXksIG9ialtrZXldLCBjdHgpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2NoZW1hLnNvcnRNYXBFbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWFwLml0ZW1zLnNvcnQoc2NoZW1hLnNvcnRNYXBFbnRyaWVzKTtcbiAgfVxuXG4gIHJldHVybiBtYXA7XG59XG5cbmNvbnN0IG1hcCA9IHtcbiAgY3JlYXRlTm9kZTogY3JlYXRlTWFwLFxuICBkZWZhdWx0OiB0cnVlLFxuICBub2RlQ2xhc3M6IHJlc29sdmVTZXEuWUFNTE1hcCxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bWFwJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVNlcS5yZXNvbHZlTWFwXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTZXEoc2NoZW1hLCBvYmosIGN0eCkge1xuICBjb25zdCBzZXEgPSBuZXcgcmVzb2x2ZVNlcS5ZQU1MU2VxKHNjaGVtYSk7XG5cbiAgaWYgKG9iaiAmJiBvYmpbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgIGZvciAoY29uc3QgaXQgb2Ygb2JqKSB7XG4gICAgICBjb25zdCB2ID0gc2NoZW1hLmNyZWF0ZU5vZGUoaXQsIGN0eC53cmFwU2NhbGFycywgbnVsbCwgY3R4KTtcbiAgICAgIHNlcS5pdGVtcy5wdXNoKHYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXE7XG59XG5cbmNvbnN0IHNlcSA9IHtcbiAgY3JlYXRlTm9kZTogY3JlYXRlU2VxLFxuICBkZWZhdWx0OiB0cnVlLFxuICBub2RlQ2xhc3M6IHJlc29sdmVTZXEuWUFNTFNlcSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVNlcS5yZXNvbHZlU2VxXG59O1xuXG5jb25zdCBzdHJpbmcgPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICByZXNvbHZlOiByZXNvbHZlU2VxLnJlc29sdmVTdHJpbmcsXG5cbiAgc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYWN0dWFsU3RyaW5nOiB0cnVlXG4gICAgfSwgY3R4KTtcbiAgICByZXR1cm4gcmVzb2x2ZVNlcS5zdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgfSxcblxuICBvcHRpb25zOiByZXNvbHZlU2VxLnN0ck9wdGlvbnNcbn07XG5cbmNvbnN0IGZhaWxzYWZlID0gW21hcCwgc2VxLCBzdHJpbmddO1xuXG4vKiBnbG9iYWwgQmlnSW50ICovXG5cbmNvbnN0IGludElkZW50aWZ5JDIgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuXG5jb25zdCBpbnRSZXNvbHZlJDEgPSAoc3JjLCBwYXJ0LCByYWRpeCkgPT4gcmVzb2x2ZVNlcS5pbnRPcHRpb25zLmFzQmlnSW50ID8gQmlnSW50KHNyYykgOiBwYXJzZUludChwYXJ0LCByYWRpeCk7XG5cbmZ1bmN0aW9uIGludFN0cmluZ2lmeSQxKG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgY29uc3Qge1xuICAgIHZhbHVlXG4gIH0gPSBub2RlO1xuICBpZiAoaW50SWRlbnRpZnkkMih2YWx1ZSkgJiYgdmFsdWUgPj0gMCkgcmV0dXJuIHByZWZpeCArIHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgcmV0dXJuIHJlc29sdmVTZXEuc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuXG5jb25zdCBudWxsT2JqID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCxcbiAgY3JlYXRlTm9kZTogKHNjaGVtYSwgdmFsdWUsIGN0eCkgPT4gY3R4LndyYXBTY2FsYXJzID8gbmV3IHJlc29sdmVTZXEuU2NhbGFyKG51bGwpIDogbnVsbCxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsXG4gIHRlc3Q6IC9eKD86fnxbTm5ddWxsfE5VTEwpPyQvLFxuICByZXNvbHZlOiAoKSA9PiBudWxsLFxuICBvcHRpb25zOiByZXNvbHZlU2VxLm51bGxPcHRpb25zLFxuICBzdHJpbmdpZnk6ICgpID0+IHJlc29sdmVTZXEubnVsbE9wdGlvbnMubnVsbFN0clxufTtcbmNvbnN0IGJvb2xPYmogPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gIHRlc3Q6IC9eKD86W1R0XXJ1ZXxUUlVFfFtGZl1hbHNlfEZBTFNFKSQvLFxuICByZXNvbHZlOiBzdHIgPT4gc3RyWzBdID09PSAndCcgfHwgc3RyWzBdID09PSAnVCcsXG4gIG9wdGlvbnM6IHJlc29sdmVTZXEuYm9vbE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogKHtcbiAgICB2YWx1ZVxuICB9KSA9PiB2YWx1ZSA/IHJlc29sdmVTZXEuYm9vbE9wdGlvbnMudHJ1ZVN0ciA6IHJlc29sdmVTZXEuYm9vbE9wdGlvbnMuZmFsc2VTdHJcbn07XG5jb25zdCBvY3RPYmogPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiBpbnRJZGVudGlmeSQyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdPQ1QnLFxuICB0ZXN0OiAvXjBvKFswLTddKykkLyxcbiAgcmVzb2x2ZTogKHN0ciwgb2N0KSA9PiBpbnRSZXNvbHZlJDEoc3RyLCBvY3QsIDgpLFxuICBvcHRpb25zOiByZXNvbHZlU2VxLmludE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkkMShub2RlLCA4LCAnMG8nKVxufTtcbmNvbnN0IGludE9iaiA9IHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5JDIsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIHRlc3Q6IC9eWy0rXT9bMC05XSskLyxcbiAgcmVzb2x2ZTogc3RyID0+IGludFJlc29sdmUkMShzdHIsIHN0ciwgMTApLFxuICBvcHRpb25zOiByZXNvbHZlU2VxLmludE9wdGlvbnMsXG4gIHN0cmluZ2lmeTogcmVzb2x2ZVNlcS5zdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBoZXhPYmogPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiBpbnRJZGVudGlmeSQyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdIRVgnLFxuICB0ZXN0OiAvXjB4KFswLTlhLWZBLUZdKykkLyxcbiAgcmVzb2x2ZTogKHN0ciwgaGV4KSA9PiBpbnRSZXNvbHZlJDEoc3RyLCBoZXgsIDE2KSxcbiAgb3B0aW9uczogcmVzb2x2ZVNlcS5pbnRPcHRpb25zLFxuICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5JDEobm9kZSwgMTYsICcweCcpXG59O1xuY29uc3QgbmFuT2JqID0ge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICB0ZXN0OiAvXig/OlstK10/XFwuaW5mfChcXC5uYW4pKSQvaSxcbiAgcmVzb2x2ZTogKHN0ciwgbmFuKSA9PiBuYW4gPyBOYU4gOiBzdHJbMF0gPT09ICctJyA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgc3RyaW5naWZ5OiByZXNvbHZlU2VxLnN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGV4cE9iaiA9IHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgZm9ybWF0OiAnRVhQJyxcbiAgdGVzdDogL15bLStdPyg/OlxcLlswLTldK3xbMC05XSsoPzpcXC5bMC05XSopPylbZUVdWy0rXT9bMC05XSskLyxcbiAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgc3RyaW5naWZ5OiAoe1xuICAgIHZhbHVlXG4gIH0pID0+IE51bWJlcih2YWx1ZSkudG9FeHBvbmVudGlhbCgpXG59O1xuY29uc3QgZmxvYXRPYmogPSB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIHRlc3Q6IC9eWy0rXT8oPzpcXC4oWzAtOV0rKXxbMC05XStcXC4oWzAtOV0qKSkkLyxcblxuICByZXNvbHZlKHN0ciwgZnJhYzEsIGZyYWMyKSB7XG4gICAgY29uc3QgZnJhYyA9IGZyYWMxIHx8IGZyYWMyO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgcmVzb2x2ZVNlcS5TY2FsYXIocGFyc2VGbG9hdChzdHIpKTtcbiAgICBpZiAoZnJhYyAmJiBmcmFjW2ZyYWMubGVuZ3RoIC0gMV0gPT09ICcwJykgbm9kZS5taW5GcmFjdGlvbkRpZ2l0cyA9IGZyYWMubGVuZ3RoO1xuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIHN0cmluZ2lmeTogcmVzb2x2ZVNlcS5zdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBjb3JlID0gZmFpbHNhZmUuY29uY2F0KFtudWxsT2JqLCBib29sT2JqLCBvY3RPYmosIGludE9iaiwgaGV4T2JqLCBuYW5PYmosIGV4cE9iaiwgZmxvYXRPYmpdKTtcblxuLyogZ2xvYmFsIEJpZ0ludCAqL1xuXG5jb25zdCBpbnRJZGVudGlmeSQxID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcblxuY29uc3Qgc3RyaW5naWZ5SlNPTiA9ICh7XG4gIHZhbHVlXG59KSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbmNvbnN0IGpzb24gPSBbbWFwLCBzZXEsIHtcbiAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gIHJlc29sdmU6IHJlc29sdmVTZXEucmVzb2x2ZVN0cmluZyxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsLFxuICBjcmVhdGVOb2RlOiAoc2NoZW1hLCB2YWx1ZSwgY3R4KSA9PiBjdHgud3JhcFNjYWxhcnMgPyBuZXcgcmVzb2x2ZVNlcS5TY2FsYXIobnVsbCkgOiBudWxsLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgdGVzdDogL15udWxsJC8sXG4gIHJlc29sdmU6ICgpID0+IG51bGwsXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxufSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICB0ZXN0OiAvXnRydWV8ZmFsc2UkLyxcbiAgcmVzb2x2ZTogc3RyID0+IHN0ciA9PT0gJ3RydWUnLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbn0sIHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5JDEsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvLFxuICByZXNvbHZlOiBzdHIgPT4gcmVzb2x2ZVNlcS5pbnRPcHRpb25zLmFzQmlnSW50ID8gQmlnSW50KHN0cikgOiBwYXJzZUludChzdHIsIDEwKSxcbiAgc3RyaW5naWZ5OiAoe1xuICAgIHZhbHVlXG4gIH0pID0+IGludElkZW50aWZ5JDEodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxufSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikoPzpcXC5bMC05XSopPyg/OltlRV1bLStdP1swLTldKyk/JC8sXG4gIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxufV07XG5cbmpzb24uc2NhbGFyRmFsbGJhY2sgPSBzdHIgPT4ge1xuICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVucmVzb2x2ZWQgcGxhaW4gc2NhbGFyICR7SlNPTi5zdHJpbmdpZnkoc3RyKX1gKTtcbn07XG5cbi8qIGdsb2JhbCBCaWdJbnQgKi9cblxuY29uc3QgYm9vbFN0cmluZ2lmeSA9ICh7XG4gIHZhbHVlXG59KSA9PiB2YWx1ZSA/IHJlc29sdmVTZXEuYm9vbE9wdGlvbnMudHJ1ZVN0ciA6IHJlc29sdmVTZXEuYm9vbE9wdGlvbnMuZmFsc2VTdHI7XG5cbmNvbnN0IGludElkZW50aWZ5ID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcblxuZnVuY3Rpb24gaW50UmVzb2x2ZShzaWduLCBzcmMsIHJhZGl4KSB7XG4gIGxldCBzdHIgPSBzcmMucmVwbGFjZSgvXy9nLCAnJyk7XG5cbiAgaWYgKHJlc29sdmVTZXEuaW50T3B0aW9ucy5hc0JpZ0ludCkge1xuICAgIHN3aXRjaCAocmFkaXgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgc3RyID0gYDBiJHtzdHJ9YDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgODpcbiAgICAgICAgc3RyID0gYDBvJHtzdHJ9YDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTY6XG4gICAgICAgIHN0ciA9IGAweCR7c3RyfWA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IG4gPSBCaWdJbnQoc3RyKTtcbiAgICByZXR1cm4gc2lnbiA9PT0gJy0nID8gQmlnSW50KC0xKSAqIG4gOiBuO1xuICB9XG5cbiAgY29uc3QgbiA9IHBhcnNlSW50KHN0ciwgcmFkaXgpO1xuICByZXR1cm4gc2lnbiA9PT0gJy0nID8gLTEgKiBuIDogbjtcbn1cblxuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgY29uc3Qge1xuICAgIHZhbHVlXG4gIH0gPSBub2RlO1xuXG4gIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkpIHtcbiAgICBjb25zdCBzdHIgPSB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgcmV0dXJuIHZhbHVlIDwgMCA/ICctJyArIHByZWZpeCArIHN0ci5zdWJzdHIoMSkgOiBwcmVmaXggKyBzdHI7XG4gIH1cblxuICByZXR1cm4gcmVzb2x2ZVNlcS5zdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5cbmNvbnN0IHlhbWwxMSA9IGZhaWxzYWZlLmNvbmNhdChbe1xuICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCxcbiAgY3JlYXRlTm9kZTogKHNjaGVtYSwgdmFsdWUsIGN0eCkgPT4gY3R4LndyYXBTY2FsYXJzID8gbmV3IHJlc29sdmVTZXEuU2NhbGFyKG51bGwpIDogbnVsbCxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsXG4gIHRlc3Q6IC9eKD86fnxbTm5ddWxsfE5VTEwpPyQvLFxuICByZXNvbHZlOiAoKSA9PiBudWxsLFxuICBvcHRpb25zOiByZXNvbHZlU2VxLm51bGxPcHRpb25zLFxuICBzdHJpbmdpZnk6ICgpID0+IHJlc29sdmVTZXEubnVsbE9wdGlvbnMubnVsbFN0clxufSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gIGRlZmF1bHQ6IHRydWUsXG4gIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICB0ZXN0OiAvXig/Oll8eXxbWXldZXN8WUVTfFtUdF1ydWV8VFJVRXxbT29dbnxPTikkLyxcbiAgcmVzb2x2ZTogKCkgPT4gdHJ1ZSxcbiAgb3B0aW9uczogcmVzb2x2ZVNlcS5ib29sT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gIHRlc3Q6IC9eKD86TnxufFtObl1vfE5PfFtGZl1hbHNlfEZBTFNFfFtPb11mZnxPRkYpJC9pLFxuICByZXNvbHZlOiAoKSA9PiBmYWxzZSxcbiAgb3B0aW9uczogcmVzb2x2ZVNlcS5ib29sT3B0aW9ucyxcbiAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59LCB7XG4gIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgZm9ybWF0OiAnQklOJyxcbiAgdGVzdDogL14oWy0rXT8pMGIoWzAtMV9dKykkLyxcbiAgcmVzb2x2ZTogKHN0ciwgc2lnbiwgYmluKSA9PiBpbnRSZXNvbHZlKHNpZ24sIGJpbiwgMiksXG4gIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMiwgJzBiJylcbn0sIHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdPQ1QnLFxuICB0ZXN0OiAvXihbLStdPykwKFswLTdfXSspJC8sXG4gIHJlc29sdmU6IChzdHIsIHNpZ24sIG9jdCkgPT4gaW50UmVzb2x2ZShzaWduLCBvY3QsIDgpLFxuICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwJylcbn0sIHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICB0ZXN0OiAvXihbLStdPykoWzAtOV1bMC05X10qKSQvLFxuICByZXNvbHZlOiAoc3RyLCBzaWduLCBhYnMpID0+IGludFJlc29sdmUoc2lnbiwgYWJzLCAxMCksXG4gIHN0cmluZ2lmeTogcmVzb2x2ZVNlcS5zdHJpbmdpZnlOdW1iZXJcbn0sIHtcbiAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICBmb3JtYXQ6ICdIRVgnLFxuICB0ZXN0OiAvXihbLStdPykweChbMC05YS1mQS1GX10rKSQvLFxuICByZXNvbHZlOiAoc3RyLCBzaWduLCBoZXgpID0+IGludFJlc29sdmUoc2lnbiwgaGV4LCAxNiksXG4gIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMTYsICcweCcpXG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIHRlc3Q6IC9eKD86Wy0rXT9cXC5pbmZ8KFxcLm5hbikpJC9pLFxuICByZXNvbHZlOiAoc3RyLCBuYW4pID0+IG5hbiA/IE5hTiA6IHN0clswXSA9PT0gJy0nID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICBzdHJpbmdpZnk6IHJlc29sdmVTZXEuc3RyaW5naWZ5TnVtYmVyXG59LCB7XG4gIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBkZWZhdWx0OiB0cnVlLFxuICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gIGZvcm1hdDogJ0VYUCcsXG4gIHRlc3Q6IC9eWy0rXT8oWzAtOV1bMC05X10qKT8oXFwuWzAtOV9dKik/W2VFXVstK10/WzAtOV0rJC8sXG4gIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csICcnKSksXG4gIHN0cmluZ2lmeTogKHtcbiAgICB2YWx1ZVxuICB9KSA9PiBOdW1iZXIodmFsdWUpLnRvRXhwb25lbnRpYWwoKVxufSwge1xuICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICB0ZXN0OiAvXlstK10/KD86WzAtOV1bMC05X10qKT9cXC4oWzAtOV9dKikkLyxcblxuICByZXNvbHZlKHN0ciwgZnJhYykge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgcmVzb2x2ZVNlcS5TY2FsYXIocGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpKTtcblxuICAgIGlmIChmcmFjKSB7XG4gICAgICBjb25zdCBmID0gZnJhYy5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgIGlmIChmW2YubGVuZ3RoIC0gMV0gPT09ICcwJykgbm9kZS5taW5GcmFjdGlvbkRpZ2l0cyA9IGYubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIHN0cmluZ2lmeTogcmVzb2x2ZVNlcS5zdHJpbmdpZnlOdW1iZXJcbn1dLCB3YXJuaW5ncy5iaW5hcnksIHdhcm5pbmdzLm9tYXAsIHdhcm5pbmdzLnBhaXJzLCB3YXJuaW5ncy5zZXQsIHdhcm5pbmdzLmludFRpbWUsIHdhcm5pbmdzLmZsb2F0VGltZSwgd2FybmluZ3MudGltZXN0YW1wKTtcblxuY29uc3Qgc2NoZW1hcyA9IHtcbiAgY29yZSxcbiAgZmFpbHNhZmUsXG4gIGpzb24sXG4gIHlhbWwxMVxufTtcbmNvbnN0IHRhZ3MgPSB7XG4gIGJpbmFyeTogd2FybmluZ3MuYmluYXJ5LFxuICBib29sOiBib29sT2JqLFxuICBmbG9hdDogZmxvYXRPYmosXG4gIGZsb2F0RXhwOiBleHBPYmosXG4gIGZsb2F0TmFOOiBuYW5PYmosXG4gIGZsb2F0VGltZTogd2FybmluZ3MuZmxvYXRUaW1lLFxuICBpbnQ6IGludE9iaixcbiAgaW50SGV4OiBoZXhPYmosXG4gIGludE9jdDogb2N0T2JqLFxuICBpbnRUaW1lOiB3YXJuaW5ncy5pbnRUaW1lLFxuICBtYXAsXG4gIG51bGw6IG51bGxPYmosXG4gIG9tYXA6IHdhcm5pbmdzLm9tYXAsXG4gIHBhaXJzOiB3YXJuaW5ncy5wYWlycyxcbiAgc2VxLFxuICBzZXQ6IHdhcm5pbmdzLnNldCxcbiAgdGltZXN0YW1wOiB3YXJuaW5ncy50aW1lc3RhbXBcbn07XG5cbmZ1bmN0aW9uIGZpbmRUYWdPYmplY3QodmFsdWUsIHRhZ05hbWUsIHRhZ3MpIHtcbiAgaWYgKHRhZ05hbWUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHRhZ3MuZmlsdGVyKHQgPT4gdC50YWcgPT09IHRhZ05hbWUpO1xuICAgIGNvbnN0IHRhZ09iaiA9IG1hdGNoLmZpbmQodCA9PiAhdC5mb3JtYXQpIHx8IG1hdGNoWzBdO1xuICAgIGlmICghdGFnT2JqKSB0aHJvdyBuZXcgRXJyb3IoYFRhZyAke3RhZ05hbWV9IG5vdCBmb3VuZGApO1xuICAgIHJldHVybiB0YWdPYmo7XG4gIH0gLy8gVE9ETzogZGVwcmVjYXRlL3JlbW92ZSBjbGFzcyBjaGVja1xuXG5cbiAgcmV0dXJuIHRhZ3MuZmluZCh0ID0+ICh0LmlkZW50aWZ5ICYmIHQuaWRlbnRpZnkodmFsdWUpIHx8IHQuY2xhc3MgJiYgdmFsdWUgaW5zdGFuY2VvZiB0LmNsYXNzKSAmJiAhdC5mb3JtYXQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlLCB0YWdOYW1lLCBjdHgpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgcmVzb2x2ZVNlcS5Ob2RlKSByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHtcbiAgICBkZWZhdWx0UHJlZml4LFxuICAgIG9uVGFnT2JqLFxuICAgIHByZXZPYmplY3RzLFxuICAgIHNjaGVtYSxcbiAgICB3cmFwU2NhbGFyc1xuICB9ID0gY3R4O1xuICBpZiAodGFnTmFtZSAmJiB0YWdOYW1lLnN0YXJ0c1dpdGgoJyEhJykpIHRhZ05hbWUgPSBkZWZhdWx0UHJlZml4ICsgdGFnTmFtZS5zbGljZSgyKTtcbiAgbGV0IHRhZ09iaiA9IGZpbmRUYWdPYmplY3QodmFsdWUsIHRhZ05hbWUsIHNjaGVtYS50YWdzKTtcblxuICBpZiAoIXRhZ09iaikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB2YWx1ZSA9IHZhbHVlLnRvSlNPTigpO1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgcmV0dXJuIHdyYXBTY2FsYXJzID8gbmV3IHJlc29sdmVTZXEuU2NhbGFyKHZhbHVlKSA6IHZhbHVlO1xuICAgIHRhZ09iaiA9IHZhbHVlIGluc3RhbmNlb2YgTWFwID8gbWFwIDogdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSA/IHNlcSA6IG1hcDtcbiAgfVxuXG4gIGlmIChvblRhZ09iaikge1xuICAgIG9uVGFnT2JqKHRhZ09iaik7XG4gICAgZGVsZXRlIGN0eC5vblRhZ09iajtcbiAgfSAvLyBEZXRlY3QgZHVwbGljYXRlIHJlZmVyZW5jZXMgdG8gdGhlIHNhbWUgb2JqZWN0ICYgdXNlIEFsaWFzIG5vZGVzIGZvciBhbGxcbiAgLy8gYWZ0ZXIgZmlyc3QuIFRoZSBgb2JqYCB3cmFwcGVyIGFsbG93cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byByZXNvbHZlLlxuXG5cbiAgY29uc3Qgb2JqID0ge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgbm9kZTogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgcHJldk9iamVjdHMpIHtcbiAgICBjb25zdCBwcmV2ID0gcHJldk9iamVjdHMuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChwcmV2KSB7XG4gICAgICBjb25zdCBhbGlhcyA9IG5ldyByZXNvbHZlU2VxLkFsaWFzKHByZXYpOyAvLyBsZWF2ZXMgc291cmNlIGRpcnR5OyBtdXN0IGJlIGNsZWFuZWQgYnkgY2FsbGVyXG5cbiAgICAgIGN0eC5hbGlhc05vZGVzLnB1c2goYWxpYXMpOyAvLyBkZWZpbmVkIGFsb25nIHdpdGggcHJldk9iamVjdHNcblxuICAgICAgcmV0dXJuIGFsaWFzO1xuICAgIH1cblxuICAgIG9iai52YWx1ZSA9IHZhbHVlO1xuICAgIHByZXZPYmplY3RzLnNldCh2YWx1ZSwgb2JqKTtcbiAgfVxuXG4gIG9iai5ub2RlID0gdGFnT2JqLmNyZWF0ZU5vZGUgPyB0YWdPYmouY3JlYXRlTm9kZShjdHguc2NoZW1hLCB2YWx1ZSwgY3R4KSA6IHdyYXBTY2FsYXJzID8gbmV3IHJlc29sdmVTZXEuU2NhbGFyKHZhbHVlKSA6IHZhbHVlO1xuICBpZiAodGFnTmFtZSAmJiBvYmoubm9kZSBpbnN0YW5jZW9mIHJlc29sdmVTZXEuTm9kZSkgb2JqLm5vZGUudGFnID0gdGFnTmFtZTtcbiAgcmV0dXJuIG9iai5ub2RlO1xufVxuXG5mdW5jdGlvbiBnZXRTY2hlbWFUYWdzKHNjaGVtYXMsIGtub3duVGFncywgY3VzdG9tVGFncywgc2NoZW1hSWQpIHtcbiAgbGV0IHRhZ3MgPSBzY2hlbWFzW3NjaGVtYUlkLnJlcGxhY2UoL1xcVy9nLCAnJyldOyAvLyAneWFtbC0xLjEnIC0+ICd5YW1sMTEnXG5cbiAgaWYgKCF0YWdzKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYXMpLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSkuam9pbignLCAnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2NoZW1hIFwiJHtzY2hlbWFJZH1cIjsgdXNlIG9uZSBvZiAke2tleXN9YCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSkge1xuICAgIGZvciAoY29uc3QgdGFnIG9mIGN1c3RvbVRhZ3MpIHRhZ3MgPSB0YWdzLmNvbmNhdCh0YWcpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjdXN0b21UYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGFncyA9IGN1c3RvbVRhZ3ModGFncy5zbGljZSgpKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHRhZyA9IHRhZ3NbaV07XG5cbiAgICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHRhZ09iaiA9IGtub3duVGFnc1t0YWddO1xuXG4gICAgICBpZiAoIXRhZ09iaikge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoa25vd25UYWdzKS5tYXAoa2V5ID0+IEpTT04uc3RyaW5naWZ5KGtleSkpLmpvaW4oJywgJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjdXN0b20gdGFnIFwiJHt0YWd9XCI7IHVzZSBvbmUgb2YgJHtrZXlzfWApO1xuICAgICAgfVxuXG4gICAgICB0YWdzW2ldID0gdGFnT2JqO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWdzO1xufVxuXG5jb25zdCBzb3J0TWFwRW50cmllc0J5S2V5ID0gKGEsIGIpID0+IGEua2V5IDwgYi5rZXkgPyAtMSA6IGEua2V5ID4gYi5rZXkgPyAxIDogMDtcblxuY2xhc3MgU2NoZW1hIHtcbiAgLy8gVE9ETzogcmVtb3ZlIGluIHYyXG4gIC8vIFRPRE86IHJlbW92ZSBpbiB2MlxuICBjb25zdHJ1Y3Rvcih7XG4gICAgY3VzdG9tVGFncyxcbiAgICBtZXJnZSxcbiAgICBzY2hlbWEsXG4gICAgc29ydE1hcEVudHJpZXMsXG4gICAgdGFnczogZGVwcmVjYXRlZEN1c3RvbVRhZ3NcbiAgfSkge1xuICAgIHRoaXMubWVyZ2UgPSAhIW1lcmdlO1xuICAgIHRoaXMubmFtZSA9IHNjaGVtYTtcbiAgICB0aGlzLnNvcnRNYXBFbnRyaWVzID0gc29ydE1hcEVudHJpZXMgPT09IHRydWUgPyBzb3J0TWFwRW50cmllc0J5S2V5IDogc29ydE1hcEVudHJpZXMgfHwgbnVsbDtcbiAgICBpZiAoIWN1c3RvbVRhZ3MgJiYgZGVwcmVjYXRlZEN1c3RvbVRhZ3MpIHdhcm5pbmdzLndhcm5PcHRpb25EZXByZWNhdGlvbigndGFncycsICdjdXN0b21UYWdzJyk7XG4gICAgdGhpcy50YWdzID0gZ2V0U2NoZW1hVGFncyhzY2hlbWFzLCB0YWdzLCBjdXN0b21UYWdzIHx8IGRlcHJlY2F0ZWRDdXN0b21UYWdzLCBzY2hlbWEpO1xuICB9XG5cbiAgY3JlYXRlTm9kZSh2YWx1ZSwgd3JhcFNjYWxhcnMsIHRhZ05hbWUsIGN0eCkge1xuICAgIGNvbnN0IGJhc2VDdHggPSB7XG4gICAgICBkZWZhdWx0UHJlZml4OiBTY2hlbWEuZGVmYXVsdFByZWZpeCxcbiAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgIHdyYXBTY2FsYXJzXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVDdHggPSBjdHggPyBPYmplY3QuYXNzaWduKGN0eCwgYmFzZUN0eCkgOiBiYXNlQ3R4O1xuICAgIHJldHVybiBjcmVhdGVOb2RlKHZhbHVlLCB0YWdOYW1lLCBjcmVhdGVDdHgpO1xuICB9XG5cbiAgY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpIHtcbiAgICBpZiAoIWN0eCkgY3R4ID0ge1xuICAgICAgd3JhcFNjYWxhcnM6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IGsgPSB0aGlzLmNyZWF0ZU5vZGUoa2V5LCBjdHgud3JhcFNjYWxhcnMsIG51bGwsIGN0eCk7XG4gICAgY29uc3QgdiA9IHRoaXMuY3JlYXRlTm9kZSh2YWx1ZSwgY3R4LndyYXBTY2FsYXJzLCBudWxsLCBjdHgpO1xuICAgIHJldHVybiBuZXcgcmVzb2x2ZVNlcS5QYWlyKGssIHYpO1xuICB9XG5cbn1cblxuUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkoU2NoZW1hLCBcImRlZmF1bHRQcmVmaXhcIiwgUGxhaW5WYWx1ZS5kZWZhdWx0VGFnUHJlZml4KTtcblxuUGxhaW5WYWx1ZS5fZGVmaW5lUHJvcGVydHkoU2NoZW1hLCBcImRlZmF1bHRUYWdzXCIsIFBsYWluVmFsdWUuZGVmYXVsdFRhZ3MpO1xuXG5leHBvcnRzLlNjaGVtYSA9IFNjaGVtYTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmVTZXEgPSByZXF1aXJlKCcuL3Jlc29sdmVTZXEtZDAzY2IwMzcuanMnKTtcbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuL1NjaGVtYS04OGUzMjNhNy5qcycpO1xucmVxdWlyZSgnLi9QbGFpblZhbHVlLWVjOGU1ODhlLmpzJyk7XG5yZXF1aXJlKCcuL3dhcm5pbmdzLTEwMDBhMzcyLmpzJyk7XG5cblxuXG5leHBvcnRzLkFsaWFzID0gcmVzb2x2ZVNlcS5BbGlhcztcbmV4cG9ydHMuQ29sbGVjdGlvbiA9IHJlc29sdmVTZXEuQ29sbGVjdGlvbjtcbmV4cG9ydHMuTWVyZ2UgPSByZXNvbHZlU2VxLk1lcmdlO1xuZXhwb3J0cy5Ob2RlID0gcmVzb2x2ZVNlcS5Ob2RlO1xuZXhwb3J0cy5QYWlyID0gcmVzb2x2ZVNlcS5QYWlyO1xuZXhwb3J0cy5TY2FsYXIgPSByZXNvbHZlU2VxLlNjYWxhcjtcbmV4cG9ydHMuWUFNTE1hcCA9IHJlc29sdmVTZXEuWUFNTE1hcDtcbmV4cG9ydHMuWUFNTFNlcSA9IHJlc29sdmVTZXEuWUFNTFNlcTtcbmV4cG9ydHMuYmluYXJ5T3B0aW9ucyA9IHJlc29sdmVTZXEuYmluYXJ5T3B0aW9ucztcbmV4cG9ydHMuYm9vbE9wdGlvbnMgPSByZXNvbHZlU2VxLmJvb2xPcHRpb25zO1xuZXhwb3J0cy5pbnRPcHRpb25zID0gcmVzb2x2ZVNlcS5pbnRPcHRpb25zO1xuZXhwb3J0cy5udWxsT3B0aW9ucyA9IHJlc29sdmVTZXEubnVsbE9wdGlvbnM7XG5leHBvcnRzLnN0ck9wdGlvbnMgPSByZXNvbHZlU2VxLnN0ck9wdGlvbnM7XG5leHBvcnRzLlNjaGVtYSA9IFNjaGVtYS5TY2hlbWE7XG4iLCJjb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vZGlzdC90eXBlcycpXG5cbmV4cG9ydHMuYmluYXJ5T3B0aW9ucyA9IHR5cGVzLmJpbmFyeU9wdGlvbnNcbmV4cG9ydHMuYm9vbE9wdGlvbnMgPSB0eXBlcy5ib29sT3B0aW9uc1xuZXhwb3J0cy5pbnRPcHRpb25zID0gdHlwZXMuaW50T3B0aW9uc1xuZXhwb3J0cy5udWxsT3B0aW9ucyA9IHR5cGVzLm51bGxPcHRpb25zXG5leHBvcnRzLnN0ck9wdGlvbnMgPSB0eXBlcy5zdHJPcHRpb25zXG5cbmV4cG9ydHMuU2NoZW1hID0gdHlwZXMuU2NoZW1hXG5leHBvcnRzLkFsaWFzID0gdHlwZXMuQWxpYXNcbmV4cG9ydHMuQ29sbGVjdGlvbiA9IHR5cGVzLkNvbGxlY3Rpb25cbmV4cG9ydHMuTWVyZ2UgPSB0eXBlcy5NZXJnZVxuZXhwb3J0cy5Ob2RlID0gdHlwZXMuTm9kZVxuZXhwb3J0cy5QYWlyID0gdHlwZXMuUGFpclxuZXhwb3J0cy5TY2FsYXIgPSB0eXBlcy5TY2FsYXJcbmV4cG9ydHMuWUFNTE1hcCA9IHR5cGVzLllBTUxNYXBcbmV4cG9ydHMuWUFNTFNlcSA9IHR5cGVzLllBTUxTZXFcbiIsImltcG9ydCB5YW1sIGZyb20gJ3lhbWwnO1xuaW1wb3J0IHsgWUFNTE1hcCwgWUFNTFNlcSB9IGZyb20gJ3lhbWwvdHlwZXMnO1xuaW1wb3J0IG9wdGlvbkFQSSBmcm9tICcuLi9hcGkvb3B0aW9uJztcblxuZnVuY3Rpb24gZ2V0SW4ob2JqLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZSgodiwgaykgPT4gKGsgaW4gdiA/IHZba10gOiB7fSksIG9iaik7XG59XG5cbmZ1bmN0aW9uIGFkZENvbW1lbnRzKGNvbnRleHQsIHBhdGgsIGNvbW1lbnROb2RlLCBpdGVyTm9kZSA9IGNvbW1lbnROb2RlKSB7XG4gIGNvbnN0IHsgdGl0bGUsIGRlc2NyaXB0aW9uLCBjb21tZW50IH0gPSBnZXRJbihjb250ZXh0LCBwYXRoKTtcbiAgY29uc3QgbGluZXMgPSBbXTtcblxuICBpZiAob3B0aW9uQVBJKCdyZW5kZXJUaXRsZScpICYmIHRpdGxlKSB7XG4gICAgbGluZXMucHVzaChgICR7dGl0bGV9YCwgJycpO1xuICB9XG4gIGlmIChvcHRpb25BUEkoJ3JlbmRlckRlc2NyaXB0aW9uJykgJiYgZGVzY3JpcHRpb24pIHtcbiAgICBsaW5lcy5wdXNoKGAgJHtkZXNjcmlwdGlvbn1gKTtcbiAgfVxuICBpZiAob3B0aW9uQVBJKCdyZW5kZXJDb21tZW50JykgJiYgY29tbWVudCkge1xuICAgIGxpbmVzLnB1c2goYCAke2NvbW1lbnR9YCk7XG4gIH1cblxuICBjb21tZW50Tm9kZS5jb21tZW50QmVmb3JlID0gbGluZXMuam9pbignXFxuJyk7XG5cbiAgaWYgKGl0ZXJOb2RlIGluc3RhbmNlb2YgWUFNTE1hcCkge1xuICAgIGl0ZXJOb2RlLml0ZW1zLmZvckVhY2gobiA9PiB7XG4gICAgICBhZGRDb21tZW50cyhjb250ZXh0LCBbLi4ucGF0aCwgJ2l0ZW1zJywgbi5rZXkudmFsdWVdLCBuLmtleSwgbi52YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXRlck5vZGUgaW5zdGFuY2VvZiBZQU1MU2VxKSB7XG4gICAgaXRlck5vZGUuaXRlbXMuZm9yRWFjaCgobiwgaSkgPT4ge1xuICAgICAgYWRkQ29tbWVudHMoY29udGV4dCwgWy4uLnBhdGgsICdpdGVtcycsIGldLCBuKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiogUmVuZGVyIFlBTUwgc3RyaW5nIGZyb20gdGhlIGdlbmVyYXRlZCB2YWx1ZSBhbmQgY29udGV4dFxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIGNvbnRleHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbmRlcllBTUwoeyB2YWx1ZSwgY29udGV4dCB9KSB7XG4gIGNvbnN0IG5vZGVzID0geWFtbC5jcmVhdGVOb2RlKHZhbHVlKTtcblxuICBhZGRDb21tZW50cyhjb250ZXh0LCBbXSwgbm9kZXMpO1xuXG4gIGNvbnN0IGRvYyA9IG5ldyB5YW1sLkRvY3VtZW50KCk7XG4gIGRvYy5jb250ZW50cyA9IG5vZGVzO1xuXG4gIHJldHVybiBkb2MudG9TdHJpbmcoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyWUFNTDtcbiIsImltcG9ydCByZW5kZXJKUyBmcm9tICcuL2pzJztcbmltcG9ydCByZW5kZXJZQU1MIGZyb20gJy4veWFtbCc7XG5cbmV4cG9ydCB7XG4gIHJlbmRlckpTLFxuICByZW5kZXJZQU1MLFxufTtcbiIsImltcG9ydCB7IGdldERlcGVuZGVuY2llcyB9IGZyb20gJy4vdmVuZG9yJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9jbGFzcy9Db250YWluZXInO1xuaW1wb3J0IGZvcm1hdCBmcm9tICcuL2FwaS9mb3JtYXQnO1xuaW1wb3J0IG9wdGlvbiBmcm9tICcuL2FwaS9vcHRpb24nO1xuaW1wb3J0IGVudiBmcm9tICcuL2NvcmUvY29uc3RhbnRzJztcbmltcG9ydCByYW5kb20gZnJvbSAnLi9jb3JlL3JhbmRvbSc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi9jb3JlL3V0aWxzJztcbmltcG9ydCBydW4gZnJvbSAnLi9jb3JlL3J1bic7XG5pbXBvcnQgeyByZW5kZXJKUywgcmVuZGVyWUFNTCB9IGZyb20gJy4vcmVuZGVyZXJzJztcblxuY29uc3QgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcigpO1xuXG5mdW5jdGlvbiBzZXR1cEtleXdvcmRzKCkge1xuICAvLyBzYWZlIGF1dG8taW5jcmVtZW50IHZhbHVlc1xuICBjb250YWluZXIuZGVmaW5lKCdhdXRvSW5jcmVtZW50JywgZnVuY3Rpb24gYXV0b0luY3JlbWVudCh2YWx1ZSwgc2NoZW1hKSB7XG4gICAgaWYgKCF0aGlzLm9mZnNldCkge1xuICAgICAgY29uc3QgbWluID0gc2NoZW1hLm1pbmltdW0gfHwgMTtcbiAgICAgIGNvbnN0IG1heCA9IG1pbiArIGVudi5NQVhfTlVNQkVSO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gdmFsdWUuaW5pdGlhbE9mZnNldCB8fCBzY2hlbWEuaW5pdGlhbE9mZnNldDtcblxuICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQgfHwgcmFuZG9tLm51bWJlcihtaW4sIG1heCk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQrKzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWE7XG4gIH0pO1xuXG4gIC8vIHNhZmUtYW5kLXNlcXVlbnRpYWwgZGF0ZXNcbiAgY29udGFpbmVyLmRlZmluZSgnc2VxdWVudGlhbERhdGUnLCBmdW5jdGlvbiBzZXF1ZW50aWFsRGF0ZSh2YWx1ZSwgc2NoZW1hKSB7XG4gICAgaWYgKCF0aGlzLm5vdykge1xuICAgICAgdGhpcy5ub3cgPSByYW5kb20uZGF0ZSgpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc2NoZW1hID0gdGhpcy5ub3cudG9JU09TdHJpbmcoKTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IHRydWVcbiAgICAgICAgPyAnZGF5cydcbiAgICAgICAgOiB2YWx1ZTtcblxuICAgICAgaWYgKFsnc2Vjb25kcycsICdtaW51dGVzJywgJ2hvdXJzJywgJ2RheXMnLCAnd2Vla3MnLCAnbW9udGhzJywgJ3llYXJzJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgaW5jcmVtZW50IGJ5ICR7dXRpbHMuc2hvcnQodmFsdWUpfWApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdy5zZXRUaW1lKHRoaXMubm93LmdldFRpbWUoKSArIHJhbmRvbS5kYXRlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlZnMocmVmcywgc2NoZW1hKSB7XG4gIGxldCAkcmVmcyA9IHt9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHJlZnMpKSB7XG4gICAgcmVmcy5mb3JFYWNoKF9zY2hlbWEgPT4ge1xuICAgICAgJHJlZnNbX3NjaGVtYS4kaWQgfHwgX3NjaGVtYS5pZF0gPSBfc2NoZW1hO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgICRyZWZzID0gcmVmcyB8fCB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhbGsob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHJldHVybjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLmZvckVhY2god2Fsayk7XG5cbiAgICBjb25zdCBfaWQgPSBvYmouJGlkIHx8IG9iai5pZDtcblxuICAgIGlmICh0eXBlb2YgX2lkID09PSAnc3RyaW5nJyAmJiAhJHJlZnNbX2lkXSkge1xuICAgICAgJHJlZnNbX2lkXSA9IG9iajtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHdhbGsob2JqW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgd2FsayhyZWZzKTtcbiAgd2FsayhzY2hlbWEpO1xuXG4gIHJldHVybiAkcmVmcztcbn1cblxuY29uc3QganNmID0gKHNjaGVtYSwgcmVmcywgY3dkKSA9PiB7XG4gIGNvbnNvbGUubG9nKCdbanNvbi1zY2hlbWEtZmFrZXJdIGNhbGxpbmcgSnNvblNjaGVtYUZha2VyKCkgaXMgZGVwcmVjYXRlZCwgY2FsbCBlaXRoZXIgLmdlbmVyYXRlKCkgb3IgLnJlc29sdmUoKScpO1xuXG4gIGlmIChjd2QpIHtcbiAgICBjb25zb2xlLmxvZygnW2pzb24tc2NoZW1hLWZha2VyXSByZWZlcmVuY2VzIGFyZSBvbmx5IHN1cHBvcnRlZCBieSBjYWxsaW5nIC5yZXNvbHZlKCknKTtcbiAgfVxuXG4gIHJldHVybiBqc2YuZ2VuZXJhdGUoc2NoZW1hLCByZWZzKTtcbn07XG5cbmpzZi5nZW5lcmF0ZVdpdGhDb250ZXh0ID0gKHNjaGVtYSwgcmVmcykgPT4ge1xuICBjb25zdCAkcmVmcyA9IGdldFJlZnMocmVmcywgc2NoZW1hKTtcblxuICByZXR1cm4gcnVuKCRyZWZzLCBzY2hlbWEsIGNvbnRhaW5lciwgdHJ1ZSk7XG59O1xuXG5qc2YuZ2VuZXJhdGUgPSAoc2NoZW1hLCByZWZzKSA9PiByZW5kZXJKUyhcbiAgICBqc2YuZ2VuZXJhdGVXaXRoQ29udGV4dChzY2hlbWEsIHJlZnMpLFxuICApO1xuXG5qc2YuZ2VuZXJhdGVZQU1MID0gKHNjaGVtYSwgcmVmcykgPT4gcmVuZGVyWUFNTChcbiAgICBqc2YuZ2VuZXJhdGVXaXRoQ29udGV4dChzY2hlbWEsIHJlZnMpLFxuICApO1xuXG5qc2YucmVzb2x2ZVdpdGhDb250ZXh0ID0gKHNjaGVtYSwgcmVmcywgY3dkKSA9PiB7XG4gIGlmICh0eXBlb2YgcmVmcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjd2QgPSByZWZzO1xuICAgIHJlZnMgPSB7fTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBiYXNlZGlyIChicm93c2VyIGF3YXJlKVxuICBjd2QgPSBjd2QgfHwgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MuY3dkKCkgOiAnJyk7XG4gIGN3ZCA9IGAke2N3ZC5yZXBsYWNlKC9cXC8rJC8sICcnKX0vYDtcblxuICBjb25zdCAkcmVmcyA9IGdldFJlZnMocmVmcywgc2NoZW1hKTtcblxuICAvLyBpZGVudGljYWwgc2V0dXAgYXMganNvbi1zY2hlbWEtc2VxdWVsaXplclxuICBjb25zdCBmaXhlZFJlZnMgPSB7XG4gICAgb3JkZXI6IDEsXG4gICAgY2FuUmVhZChmaWxlKSB7XG4gICAgICBjb25zdCBrZXkgPSBmaWxlLnVybC5yZXBsYWNlKCcvOicsICc6Jyk7XG5cbiAgICAgIHJldHVybiAkcmVmc1trZXldIHx8ICRyZWZzW2tleS5zcGxpdCgnLycpLnBvcCgpXTtcbiAgICB9LFxuICAgIHJlYWQoZmlsZSwgY2FsbGJhY2spIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuY2FuUmVhZChmaWxlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgY29uc3QgeyAkUmVmUGFyc2VyIH0gPSBnZXREZXBlbmRlbmNpZXMoKTtcblxuICByZXR1cm4gJFJlZlBhcnNlclxuICAgIC5idW5kbGUoY3dkLCBzY2hlbWEsIHtcbiAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgZmlsZTogeyBvcmRlcjogMTAwIH0sXG4gICAgICAgIGh0dHA6IHsgb3JkZXI6IDIwMCB9LFxuICAgICAgICBmaXhlZFJlZnMsXG4gICAgICB9LFxuICAgICAgZGVyZWZlcmVuY2U6IHtcbiAgICAgICAgY2lyY3VsYXI6ICdpZ25vcmUnLFxuICAgICAgfSxcbiAgICB9KS50aGVuKHN1YiA9PiBydW4oJHJlZnMsIHN1YiwgY29udGFpbmVyKSlcbiAgICAuY2F0Y2goZSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdoaWxlIHJlc29sdmluZyBzY2hlbWEgKCR7ZS5tZXNzYWdlfSlgKTtcbiAgICB9KTtcbn07XG5cbmpzZi5yZXNvbHZlID0gKHNjaGVtYSwgcmVmcywgY3dkKSA9PiBqc2YucmVzb2x2ZVdpdGhDb250ZXh0KHNjaGVtYSwgcmVmcywgY3dkKS50aGVuKHJlbmRlckpTKTtcblxuanNmLnJlc29sdmVZQU1MID0gKHNjaGVtYSwgcmVmcywgY3dkKSA9PiBqc2YucmVzb2x2ZVdpdGhDb250ZXh0KHNjaGVtYSwgcmVmcywgY3dkKS50aGVuKHJlbmRlcllBTUwpO1xuXG5zZXR1cEtleXdvcmRzKCk7XG5cbmpzZi5mb3JtYXQgPSBmb3JtYXQ7XG5qc2Yub3B0aW9uID0gb3B0aW9uO1xuanNmLnJhbmRvbSA9IHJhbmRvbTtcblxuLy8gcmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nXG5qc2YuZXh0ZW5kID0gKG5hbWUsIGNiKSA9PiB7XG4gIGNvbnRhaW5lci5leHRlbmQobmFtZSwgY2IpO1xuICByZXR1cm4ganNmO1xufTtcblxuanNmLmRlZmluZSA9IChuYW1lLCBjYikgPT4ge1xuICBjb250YWluZXIuZGVmaW5lKG5hbWUsIGNiKTtcbiAgcmV0dXJuIGpzZjtcbn07XG5cbmpzZi5yZXNldCA9IG5hbWUgPT4ge1xuICBjb250YWluZXIucmVzZXQobmFtZSk7XG4gIHNldHVwS2V5d29yZHMoKTtcbiAgcmV0dXJuIGpzZjtcbn07XG5cbmpzZi5sb2NhdGUgPSBuYW1lID0+IHtcbiAgcmV0dXJuIGNvbnRhaW5lci5nZXQobmFtZSk7XG59O1xuXG5cbmlmICh0eXBlb2YgVkVSU0lPTiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAganNmLlZFUlNJT04gPSBWRVJTSU9OO1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc2Y7XG4iLCJpbXBvcnQgJFJlZlBhcnNlciBmcm9tICdqc29uLXNjaGVtYS1yZWYtcGFyc2VyJztcbmltcG9ydCB7IEpTT05QYXRoIH0gZnJvbSAnanNvbnBhdGgtcGx1cyc7XG5cbmltcG9ydCB7IHNldERlcGVuZGVuY2llcyB9IGZyb20gJy4vbGliL3ZlbmRvcic7XG5cbnNldERlcGVuZGVuY2llcyh7ICRSZWZQYXJzZXIsIEpTT05QYXRoIH0pO1xuXG5leHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9saWInO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7UUFBTSxlQUFlO0FBRWQsUUFBTSxrQkFBa0IsTUFBTTtBQUNuQyxhQUFPOztBQUdGLFFBQU0sbUJBQWtCLENBQUEsVUFBUztBQUN0QyxhQUFPLE9BQU8sY0FBYzs7Ozs7OztBQ0o5Qjs7eUJBQWU7TUFDYixjQUFjO0FBRVosYUFBSyxPQUFPOztNQU9kLFdBQVcsTUFBTTtBQUNmLFlBQUksQ0FBQyxNQUFNO0FBQ1QsZUFBSyxPQUFPO2VBQ1A7QUFDTCxpQkFBTyxLQUFLLEtBQUs7OztNQU9yQixTQUFTLE1BQU0sVUFBVTtBQUN2QixhQUFLLEtBQUssUUFBUTs7TUFNcEIsYUFBYSxTQUFTO0FBQ3BCLGVBQU8sS0FBSyxTQUFTLFFBQVEsQ0FBQSxTQUFRO0FBQ25DLGVBQUssS0FBSyxRQUFRLFFBQVE7OztNQU85QixJQUFJLE1BQU07QUFDUixjQUFNLFNBQVMsS0FBSyxLQUFLO0FBRXpCLGVBQU87O01BTVQsT0FBTztBQUNMLGVBQU8sS0FBSzs7O0FBSWhCLFFBQU8sbUJBQVE7Ozs7OztBQ3REZjs7UUFBTSxXQUFXO0FBRWpCLFFBQU8sbUJBQVE7QUFFZixhQUFTLDRCQUE0QjtBQUNyQyxhQUFTLG9CQUFvQjtBQUU3QixhQUFTLGtCQUFrQjtB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
